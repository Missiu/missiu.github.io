[{"title":"JVM 相关知识与面试题的结合","path":"/JVM.html","content":"JVM 概述 什么是JVM，说说jvm的组织架构JVM，也就是 Java 虚拟机，在运行Java程序的时候编译器会把Java源文件编译成平台无关的class字节码文件，然后再由虚拟机进行解释，把字节码文件翻译成对应的二进制指令。这也是Java为什么具有跨平台性的核心原因。JVM由类加载器、运行时数据区、执行引擎三大部分组成。首先Java类被编译成class文件之后，会进到类加载子系统，经过验证、准备、解析、初始化之后把类加载成class对象到内存的方法区。在内存中有方法区、堆、本地方法栈、虚拟机栈，被加载到方法区的类对象会执行其二进制指令，其中每个线程方法会被压入虚拟机栈，虚拟机栈有每个方法对应一个栈帧，每个栈帧有局部变量表、操作树栈、动态链接、放回方法地址等，方法会在栈帧中执行，如果创建了对象，则对象会被放在堆中，堆一般被分为新生代和老生代，这还涉及到GC算法。 类加载器：负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。 运行时数据区：JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域主要包括方法区、堆、虚拟机栈、程序计数器和本地方法栈。 执行引擎：是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器，还包括即时编译器（JIT Compiler）和垃圾回收器（Garbage Collector）。 类加载子系统 类加载子系统是如和工作的？将编译好的字节码文件（.class 文件）加载到 Java 虚拟机 (JVM) 中 加载：类加载器读取字节码文件，并将其内容转换为二进制流，再在内存中创建一个 java.lang.Class 对象来表示这个类。 验证：对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。 准备：对类变量（也称为静态变量，static 关键字修饰的变量）分配内存并初始化，初始化为数据类型的默认值，如 0、0L、null、false 等，但是不包括static静态代码块。 解析：是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、成员方法等。 初始化：在准备阶段，类变量已经被赋过默认初始值了，而在初始化阶段，类变量将被赋值为代码期望赋的值。 类加载子系统是将class文件加载成内存中的方法区的class对象，类加载过程主要包含三个阶段：加载、链接、初始化；他会先从文件系统、网络或其他来源加载 Class 文件，读取类的二进制数据到内存中。然后进行验证，确保加载的类符合 JVM 规范，比如说验证文件格式继承结构的正确性、常量池中的常量是否有效。然后进行准备，为类的静态变量分配内存并设置默认初始值。再然后进行解析，把类中的符号引用转换为直接引用，比如类和接口的符号引用、字段和方法的符号引用解析为直接引用。解析完后进行初始化，比如初始化类的静态变量和执行静态代码块。 类加载器有哪些？他们是如何工作的 Bootstrap ClassLoader（启动类加载器）：负责加载 JVM 的核心类库，是c&#x2F;c++写的是最顶层的加载器。 Extension ClassLoader（扩展类加载器）：负责加载JAVA_HOME/jre/lib/ext目录下，或者由系统属性java.ext.dirs指定位置的类库 Application ClassLoader（应用程序类加载器）：负责加载系统类路径CLASSPATH上的类库，通常是我们在开发 Java 应用程序时的主要类加载器。 User-defined ClassLoader（用户自定义类加载器）：我们可以通过继承java.lang.ClassLoader类来创建自己的类加载器。 这四个加载器从用户自定义加载器到启动类加载器，从下到上构成了分层非继承的关系，也就是用户类加载器的上一级是应用程序加载器，每层都是往上如此，当加载请求到来时他们会从下往上依次把请求交给上一级，直到最顶层。如果父类加载器能够加载该类，则直接返回；如果不能那么子类加载器才会尝试加载。这种加载机制构成了双亲委派模型。 双亲委派模型有什么好处？如果用户自定义了一个java.long.String类，通过这种加载机制也会先找到顶层的类加载器加载并返回Class对象，既可以防止核心API被篡改，保证Java体系的稳定，也可以避免类的重复加载，如果没有这种模型，可能会导致同一个类被不同的类加载器重复加载到内存中 为什么要打破双亲委派模型，怎么打破？ 要打破双亲委派模型肯定是有对应的需求 自定义类加载需求：可以通过继承java.lang.ClassLoader类并重写findClass方法来实现自定义的类加载器，比如直接加载类而不是委托给父加载器 插件化需求：比如我们熟悉的JDBC各个厂商都有不同的JDBC实现，但是Java核心包里也有，而各个厂商的实现，是没办法放在核心包里的，只能放在classpath里，也就只能由AppClassLoder 进行加载，如果遵循模型，那么只会优先加载Java核心包里的。那么我们可以通过设置线程上下文类加载器来让某个线程使用不同的类加载器加载类 热更新：比如例如代码热替换（Hot Swap），因为双亲委派模型是使用已经加载的类而不是尝试重新加载，那么我们监控类文件或配置文件的变更来触发热部署，重写findClass()方法，当需要跟新时就把类加载器换掉。 为什么Tomcat需要自定义类加载器？Tomact 是 web 容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。所以，Tomcat 破坏了双亲委派模型，提供隔离的机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。并且Tomcat的热加载也是需要破坏双亲委派模型 JVM内存能简单说一下 JVM 的内存区域吗？ JVM 的内存区域，有时叫 JVM 的内存结构，有时也叫 JVM 运行时数据区，其中包含方法区、堆，Java方法栈、本地方法栈、程序计数器 其中方法区和堆是线程共享的，其他的都是线程私有的，然后我把每个都大致说一下功能 程序计数器：较小内存空间，不存在内存溢出问题，前线程所执行的字节码行号指示器 Java虚拟机栈：线程独有的，生命周期和线程一致，执行一个方法时压入一个栈帧，执行完毕后被移除，栈不存在垃圾回收问题，但是存在内存溢出问题 本地方法栈：其实和虚拟机栈差不多，只是虚拟机栈是由Java写的，而本地方法栈是为 Java 调用本地（native）方法服务的，由 C&#x2F;C++ 编写。 堆：是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储对象的。也是垃圾回收器作用的主要区域。 方法区：方法区并不真实存在，属于 Java 虚拟机规范中的一个逻辑概念，用于存储已被 JVM 加载的类信息、常量、静态变量，在JDK1.8前叫永久代，后面就改名为直接内存中划出一块区域作为元空间，运行时常量池、类常量池都移动到元空间。 为什么PC寄存器为什么会被设定为线程私有的？首先多线程如果共享一个计数器，当一个线程被中断，另一个线程开始执行的时候程序计数器会被错误的更新，这样会破坏前一个线程的状态。如果是线程独享的，那么在进行线程调度的时候他都可以保存当前执行状态，这种隔离性在多线程中至关重要。 Java虚拟机栈如何进行方法计算的？ 局部变量表（Local Variable Array）：当方法被调用时，传入的参数会被存储在局部变量表中。对于实例方法，第一个局部变量总是this引用，指向调用该方法的对象。局部变量表中的变量可以通过索引来访问。 操作数栈（Operand Stack）：用于临时存储中间结果，以及作为方法调用和返回过程中参数传递的工具。 动态链接（Dynamic Linking）：因为多态概念的存在，所以编译器在编译的时候并不知道对象类型，所以只有在运行时才能确定对象，指向常量池里方法的引用。 方法返回地址（Return Address）：当方法执行完成后，返回到调用方法的地址。 当一个线程调用一个方法时，JVM会为这个方法分配一个新的栈帧，并将其压入当前线程的JVM栈中，栈帧里有局部遍历表、操作数栈、动态链接、方法返回地址等等。JVM中的解释器会逐条读取并执行方法中的字节码指令，比如将操作数栈中的值进行算术运算后存储到局部变量表，将局部变量表中的值加载到操作数栈，具体操作会根据字节码指令来，比如在不同数据类型之间进行转换、创建和操作对象、条件判断、循环和方法调用等。 对象创建的过程了解吗？销毁呢当我们使用 new 关键字创建一个对象的时候，JVM 首先会检查 new 指令的参数是否能在常量池中定位到一个类的符号引用，然后检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程。 如果已经加载，JVM 会为新生对象分配内存，内存分配完成之后，JVM 将分配到的内存空间初始化为零值（成员变量，数值类型是 0，布尔类型是 false，对象类型是 null），接下来设置对象头，对象头里包含了对象是哪个类的实例、对象的哈希码、对象的 GC 分代年龄等信息。 最后，JVM 会执行构造方法（&lt;init&gt;），将成员变量赋值为预期的值，这样一个对象就创建完成了。 当对象不再被任何引用指向时，对象就会变成垃圾，这就涉及到垃圾回收机制。 JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？ 堆：所有线程共享的内存区域 线程本地分配缓冲区（Thread Local Allocation Buffer, TLAB）：为了减少多线程分配对象时的竞争，JVM为每个线程分配了一个私有的小堆空间每个线程在其自己的TLAB中分配内存，这样在大多数情况下，内存分配是线程私有的。 会，首先有TLAB的存在，大大减少了多线程的竞争，但是如果TLAB中没有足够的空间，比如对象太大，那就得从全局堆里分配。这就涉及到了对全局堆的竞争和同步，比如线程A给对象分配内存按流程指正应该右移一个对象size的距离，但是指针还没来得及修改，另一个线程为B分配内存又引用了这个还没来的及右移的指针，这就发生了抢占。至于JVM设计的方法，就像刚刚说的TLAB 线程本地分配缓冲区，为每个线程分配了一个私有的小堆空间每个线程在其自己的TLAB中分配内存，这样在大多数情况下，内存分配是线程私有的。还有采用CAS 比较并交换（Compare And Swap）他是一直乐观锁实现方式，用来保证更新的原子性，就是类似于版本控制一样的，会把要更新的变量和预期值进行判短，如果符合预期那就更新不符合就不更新。 能说一下对象的内存布局吗？具体的实现细节可能因不同的 JVM 实现（如 HotSpot、OpenJ9 等）而异。我这里以HotSpot为例，对象在堆内存中的存储布局可以划分为三个部分：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。其中对象头 有标记字（Mark Word）、类型指针（Class Pointer）、数组长度（Array Length）。然后标记字里面又包含了对象自身的运行时数据，如哈希码（HashCode）、垃圾回收分代年龄、锁状态标志、线程持有的锁、偏向线程 ID 等信息。在 64 位操作系统下占 8 个字节，32 位操作系统下占 4 个字节。 内存溢出和内存泄漏是什么意思？能举个例子吗内存溢出（Out of Memory，俗称 OOM）和内存泄漏（Memory Leak）是两个不同的概念，但它们都与内存管理有关。内存溢出是程序请求分配内存时，由于没有足够的内存空间满足其需求，而内存泄漏是指程序在使用完内存后，未能释放已分配的内存空间，导致这部分内存无法再被使用。随着时间的推移，内存泄漏会导致可用内存逐渐减少，最终可能导致内存溢出。 内存泄漏可能由哪些原因导致呢？怎么解决 使用静态集合类存储对象，这些对象可整个生命周期内都不会被清除 创建的连接不再使用时，需要调用 close 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。 长生命周期的对象引用了短生命周期的对象，导致导致短生命周期对象无法被回收。 ThreadLocal 的弱引用导致内存泄漏也是个老生常谈的话题了，使用完 ThreadLocal 一定要记得使用 remove 方法来进行清除。 知道了原因要解决就相对简单了，比如尽量避免非静态内部类，写代码的时候及时释放资源等等 说一下对象有哪几种引用？Java 中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。 强引用就是最传统的引用的定义，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象 软引用 ，SoftReference实现，用来描述一些还有用，但非必须的对象，只被软引用关联着的对象，如果将要发生内存 溢出了就会被回收， 弱引用，WeakReference实现，描述那些非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。 虚引用，PhantomReference实现，也称为“幽灵引用”或者“幻影引用”，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。 对象一定分配在堆中吗？有没有了解逃逸分析技术？（待补充）垃圾回收Minor GC&#x2F;Young GC、Major GC&#x2F;Old GC、Mixed GC、Full GC 都是什么意思？Minor GC 也称为 Young GC，是指发生在年轻代（Young Generation）的垃圾收集。Major GC 也称为 Old GC，主要指的是发生在老年代的垃圾收集。Mixed GC 是 G1 垃圾收集器特有的一种 GC 类型，它在一次 GC 中同时清理年轻代和部分老年代。Full GC 是最彻底的垃圾收集，涉及整个 Java 堆和方法区（或元空间）。它是最耗时的 GC，通常在 JVM 压力很大时发生。 为什么JVM要垃圾回收？你知道哪些垃圾回收器垃圾回收GC，有多种垃圾回收器，我知道的有8种，每种回收器可能使用了不同的算法，一步一步来，第一为什么jvm要进行垃圾回收，垃圾就是JVM中没有任何引用指向它的对象，如果不清理就会一直占用内存，然后垃圾对象越来越多就可能出现OOM（Out Of Memory）内存溢出。 名称 执行方式 执行目标 使用算法 Serial GC STW、串行、单线程 新生代 复制算法 Serial Old GC STW、串行、单线程 老年代 标记-整理算法 ParNew GC STW、并行、多线程 新生代 复制算法 CMS GC 低暂停、并行 老年代 标记-清除算法 Parallel GC STW、并行、多线程 新生代 复制算法 Parallel Old GC STW、并行、多线程 老年代 标记-整理算法 G1 GC 低暂停，并行 整堆 标记-复制算法 ZGC 低暂停，并行 整堆 标记-复制算法 STW：暂停工作线程，存在是因为Java的垃圾回收器需要扫描整个堆内存来标记和清除不再使用的对象，如果不停止应用线程的话，会导致垃圾回收器扫描时出现漏标和误删的情况。 堆：是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储对象的。也是垃圾回收器作用的主要区域。他分为新生代和老年代，两个区域比例为1:2： 新生代：包含Edan、s0（Survivor），s1三个部分，比例为8:1:1，一般对象来的时候先放到edan区，edan区里新对象来之后触发垃圾回收，把还在用的对象放全部到S0或者S1，然后更新GC次数，edan区触发垃圾回收时s0和s1会进行角色交换，每次交换GC次数也会增加，而且S0和S1两个不能同时存放对象，就是因为设计了角色交换机制，并且可以避免内存碎片化。当新生代里对象GC次数达到15次以上后，就会把对象移到老年代。这里我之前说了一般对象来的时候先放到edan区，如果来了一个很大的对象，Edan区可以放下但是s0，s1放不下，那么他后续就不会再放到s0或s1而是直接放到老年代，如果来了一个更大的对象，edan区都放不下，那么就会直接放到老年代。在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，那么年龄大于或等于该年龄的对象就可以直接进入老年代。 老年代：对象来到老年代后触发的回收机制就会和新生代不一样。 标记-复制算法：典型的空间换时间的算法，他有两块内存空间，每次只使用一个在垃圾回收时会把可达对象复制到没有用的那块内存，这样不会产生内存碎片也很高效，所以比较适合新生代这种垃圾对象多的 标记-整理算法：先对内存中存货的对象进行标记，然后清除垃圾对象，再把存活对象移到内存一段，这样也不会产生内存碎片，但是速度也慢所以适合老年代。 标记-清除算法：先对内存中存货的对象进行标记，然后清除垃圾对象，会产生内存碎片，速度较快 GC ROOT：是一组特殊的对象集合，它们作为活跃对象的根节点，垃圾收集器能够通过GC ROOT遍历整个对象引用图，从而标记出哪些对象是可达的（活跃的），哪些对象是不可达的（无用的） 初始标记：只标记GC ROOT的第一层，很快 三色标记：它将对象分为三类：白色、灰色和黑色，所有对象开始都是白色的，从 GC Root 开始，将根对象标记为灰色，然后把灰色对象的所有白色对象标记为灰色，再把这个灰色对象标记为黑色，按照这个逻辑进行重复扫描、标记。 白色：未被访问的对象，在标记阶段结束时，所有仍然是白色的对象都是不可达的，将被垃圾收集器回收 灰色：已被访问但其引用的对象还未全部被访问的对象，需要进一步扫描 黑色：黑色对象和它们引用的对象都是可达的，不会被回收 然后说回jvm的垃圾回收器，在jdk8之前，用的是Serial GC和Serial Old GC，他们会进行STW也就是暂停工作线程，他们是单线程的，jdk8之前被引入，分别针对的是Java堆中的新生代和老年代，Serial GC用的是复制算法，典型的空间换时间的算法，他有两块内存空间，每次只使用一个在垃圾回收时会把可达对象复制到没有用的那块内存，这样不会产生内存碎片也很高效，所以比较适合新生代这种垃圾对象多的。然后Serial Old GC，用的标记-整理算法，就是先对内存中存货的对象进行标记，然后清除垃圾对象，再把存活对象移到内存一段，这样也不会产生内存碎片，但是速度也慢所以适合老年代。对应的还有Parallel GC和Parallel Old GC他们对应的是Serial GC和Serial Old GC的多线程版本。 还有ParNew GC和CMS GC，不过对于CMS GC，他有个特点就是低暂停，他会先先通过GC ROOT找到直接可达的对象，我们知道GC ROOT 是特殊的特殊的对象集合，如果是完整的标记则需要通过GC ROOT遍历整个对象引用图，从而标记出哪些对象是可达的，哪些对象是不可达的，但是CMS GC是先进行初始标记，就是只标记GC Roots，这样是很快的，然后是并行标记，他把从GC ROOT遍历整个对象引用图的过程放到和用户线程并行运行，也就是没有暂停用户线程，但是同样的吞吐量会降低，因为单位时间用户线程数变少了，耗时较长，而且因为用户线程在工作，所以会产生新的对象或者之前标记的垃圾对象又变成非垃圾对象了，所以jvm通过三色标记来解决这个问题，三色标记它将对象分为三类：白色、灰色和黑色，白色表示未被访问的对象，在标记阶段结束时，所有仍然是白色的对象都是不可达的，将被垃圾收集器回收，灰色就是已被访问但其引用的对象还未全部被访问的对象，就需要进一步扫描，黑色对象和它们引用的对象都是可达的，不会被回收，一开始所有对象都是白色，然后从GC ROOT开始，把对象标记成灰色，当GC ROOT的引用对象被全部访问就标记为黑色。然后进行STW重新标记，也就是进行一些收尾动作，矫正之前标记产生的误差，是增量更新，所以耗时也不长，然后和用户线程并发清理垃圾对象和并发重置标记。所以CMS GC把标记和清理两个最耗时的操作放到和用户的线程一起并行运行，更高效。 讲讲G1 GC和ZGC最后就是G1 GC和ZGC，G1 在 1.9 版本后成为 JVM 的默认垃圾回收算法，G1 的特点是保持高回收率的同时，减少停顿。取消了堆中年轻代与老年代的物理划分，但它逻辑上仍然属于分代收集器。G1 算法将堆划分为若干个区块，默认是2048个，称作 Region，相当于把新生代代和老年代给拆分成一小块一小块的，一个区块可能是Eden或者Survivor也可能是Old或者大对象。需要注意的是ZGC虽然也采用Region但是Region并不是定长的，可以分为大区块和小区块，G1的垃圾回收过程除开新生代，新生代是直接使用STW进行标记复制算法，后续的回收为混合回收，在回收老年代的时候也会回收新生代，混合回收的过程可以简单概括为，初始标记、并发标记、再标记、清理、复制。其实其过程和CMS GC差不多，最大的不同是在回收阶段，CMS GC是并发清理垃圾对象，然后并发重置垃圾对象，而C1是筛选回收，会筛选出具有性价比的区块进行并发回收，并且可以调整STW的时间。 对于ZGC，首先在说ZGC之前需要说明两个关键技术：着色指针和读屏障技术。着色指针就是将信息存储在指针中，并且仅支持64位系统，当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址，ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。读屏障技术就是JVM向应用代码插入一小段代码，仅当应用线程从“从堆中读取对象引用”才会触发这段代码。这一小段代码可以在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。 然后就是ZGC到底是怎么进行垃圾回收的，首先初始化，整个地址视图会进行Remapped，程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入并发标记阶段。第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。标记结束后就进入并发转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。也就是说，第二次进入并发标记阶段后，地址视图调整为M1，而非M0。在并发转移阶段，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。 ZGC为什么快？CMS GC和G1 GC性能瓶颈在哪了解，首先先说CMS GC和G1 GC性能瓶颈，我们知道CMS GC新生代的Young GC和C1 GC、ZGC都是基于标记复制算法，只是实现有很大不同，我们以G1为例，在混合回收的时候会有4个STW，其中初始标记阶段，初始标记因为只标记GC Roots，耗时较短；再标记因为是增量更新对象数少，耗时也较短；清理阶段，清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制，因为内存分区数量少，耗时也较短；复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。G1的Young GC和CMS的Young GC，其标记-复制全过程STW，就不再阐述。 全并发的ZGC：ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。ZGC只有三个STW阶段，初始标记，再标记，初始转移。其中初始标记和初始转移只需要扫描所有GC Roots处理时间都非常短，最多1ms，超过1ms则再次进入并发标记阶段。ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。 你们线上用的什么垃圾收集器？为什么要用它？我们生产环境中采用了设计比较优秀的 G1 垃圾收集器，因为它不仅能满足低停顿的要求，而且解决了 CMS 的浮动垃圾问题、内存碎片问题。G1 非常适合大内存、多核处理器的环境。 执行引擎知道JIT吗？他有什么用（待补充）JVM调优有做过 JVM 调优吗？怎么做的（待定）在没有全面监控收集到性能数据前都不适合动JVM，JVM 调优是一个非常复杂的过程，最多就是调调栈、堆的大小，比例关系，但是我任然认为在没有完整的性能数据前都不需要动jvm。我在项目里一般都是先优化自己写的代码，但是我学习了一些jvm调优的思路：","tags":["Java","JVM"],"categories":["笔记"]},{"title":"Workflow 专栏介绍","path":"/workflow.html","content":"围绕云服务器进行多端同步的思路展开与工作流构建。包含大致功能如下： 同步与备份：通过搭建Syncthing的中继服务器和发现服务器，把手机、电脑、pad、服务器联系起来，其中云服务器不但可以中转、存储还能通过内网访问挂载到服务器的oss，以增加存储空间实现备份效果 预览与下载：通过Alist挂载服务器目录，配合重定向实现在浏览器上预览的图床功能，当然下载功能也不在话下。 笔记：通过Obsidian写笔记，因为笔记数据按照文件夹的形式进行本地存储，所以可以通过相对链接渲染图片、视频等，如果要放其他格式文档，比如pdf、xmind文档等，则可以从alist上获取下载链接。 博客：使用hexo静态博客，主题为Stellar。本地编译，通过同步可以把实现在Obsidian的笔记目录下写完文章自动同步到博客的目录下，再配合脚本与插件实现一件编写、发布、修改、推送一条路服务，真正把博客和笔记相互交融！ 密码管理：使用Bitwardn 自建后台服务，把密码放在自己的服务上。 科学上网：使用3-xui搭建节点，配合v2rayN实现科学上网。其中整理了部分节点种类，实现链式代理。 服务器安全与运维：目前采用Portainer 管理docker容器，使用反向代理大量减少开放对外端口，配置报警规则，对开放的服务采用严格的密码能使用二级登录就使用二级登录，尽量防止Ddos攻击。目前是收到创建快照备份服务器数据。 具体实现请见该专栏下的其他文章！ xmind文档下载地址","tags":["工作流"],"categories":["工作流"]},{"title":"JVM 相关知识与面试题的结合","path":"/doc/java/JVM/JVM.html","content":"JVM 概述 什么是JVM，说说jvm的组织架构JVM，也就是 Java 虚拟机，在运行Java程序的时候编译器会把Java源文件编译成平台无关的class字节码文件，然后再由虚拟机进行解释，把字节码文件翻译成对应的二进制指令。这也是Java为什么具有跨平台性的核心原因。JVM由类加载器、运行时数据区、执行引擎三大部分组成。首先Java类被编译成class文件之后，会进到类加载子系统，经过验证、准备、解析、初始化之后把类加载成class对象到内存的方法区。在内存中有方法区、堆、本地方法栈、虚拟机栈，被加载到方法区的类对象会执行其二进制指令，其中每个线程方法会被压入虚拟机栈，虚拟机栈有每个方法对应一个栈帧，每个栈帧有局部变量表、操作树栈、动态链接、放回方法地址等，方法会在栈帧中执行，如果创建了对象，则对象会被放在堆中，堆一般被分为新生代和老生代，这还涉及到GC算法。 类加载器：负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。 运行时数据区：JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域主要包括方法区、堆、虚拟机栈、程序计数器和本地方法栈。 执行引擎：是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器，还包括即时编译器（JIT Compiler）和垃圾回收器（Garbage Collector）。 类加载子系统 类加载子系统是如和工作的？将编译好的字节码文件（.class 文件）加载到 Java 虚拟机 (JVM) 中 加载：类加载器读取字节码文件，并将其内容转换为二进制流，再在内存中创建一个 java.lang.Class 对象来表示这个类。 验证：对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。 准备：对类变量（也称为静态变量，static 关键字修饰的变量）分配内存并初始化，初始化为数据类型的默认值，如 0、0L、null、false 等，但是不包括static静态代码块。 解析：是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、成员方法等。 初始化：在准备阶段，类变量已经被赋过默认初始值了，而在初始化阶段，类变量将被赋值为代码期望赋的值。 类加载子系统是将class文件加载成内存中的方法区的class对象，类加载过程主要包含三个阶段：加载、链接、初始化；他会先从文件系统、网络或其他来源加载 Class 文件，读取类的二进制数据到内存中。然后进行验证，确保加载的类符合 JVM 规范，比如说验证文件格式继承结构的正确性、常量池中的常量是否有效。然后进行准备，为类的静态变量分配内存并设置默认初始值。再然后进行解析，把类中的符号引用转换为直接引用，比如类和接口的符号引用、字段和方法的符号引用解析为直接引用。解析完后进行初始化，比如初始化类的静态变量和执行静态代码块。 类加载器有哪些？他们是如何工作的 Bootstrap ClassLoader（启动类加载器）：负责加载 JVM 的核心类库，是c&#x2F;c++写的是最顶层的加载器。 Extension ClassLoader（扩展类加载器）：负责加载JAVA_HOME/jre/lib/ext目录下，或者由系统属性java.ext.dirs指定位置的类库 Application ClassLoader（应用程序类加载器）：负责加载系统类路径CLASSPATH上的类库，通常是我们在开发 Java 应用程序时的主要类加载器。 User-defined ClassLoader（用户自定义类加载器）：我们可以通过继承java.lang.ClassLoader类来创建自己的类加载器。 这四个加载器从用户自定义加载器到启动类加载器，从下到上构成了分层非继承的关系，也就是用户类加载器的上一级是应用程序加载器，每层都是往上如此，当加载请求到来时他们会从下往上依次把请求交给上一级，直到最顶层。如果父类加载器能够加载该类，则直接返回；如果不能那么子类加载器才会尝试加载。这种加载机制构成了双亲委派模型。 双亲委派模型有什么好处？如果用户自定义了一个java.long.String类，通过这种加载机制也会先找到顶层的类加载器加载并返回Class对象，既可以防止核心API被篡改，保证Java体系的稳定，也可以避免类的重复加载，如果没有这种模型，可能会导致同一个类被不同的类加载器重复加载到内存中 为什么要打破双亲委派模型，怎么打破？ 要打破双亲委派模型肯定是有对应的需求 自定义类加载需求：可以通过继承java.lang.ClassLoader类并重写findClass方法来实现自定义的类加载器，比如直接加载类而不是委托给父加载器 插件化需求：比如我们熟悉的JDBC各个厂商都有不同的JDBC实现，但是Java核心包里也有，而各个厂商的实现，是没办法放在核心包里的，只能放在classpath里，也就只能由AppClassLoder 进行加载，如果遵循模型，那么只会优先加载Java核心包里的。那么我们可以通过设置线程上下文类加载器来让某个线程使用不同的类加载器加载类 热更新：比如例如代码热替换（Hot Swap），因为双亲委派模型是使用已经加载的类而不是尝试重新加载，那么我们监控类文件或配置文件的变更来触发热部署，重写findClass()方法，当需要跟新时就把类加载器换掉。 为什么Tomcat需要自定义类加载器？Tomact 是 web 容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。所以，Tomcat 破坏了双亲委派模型，提供隔离的机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。并且Tomcat的热加载也是需要破坏双亲委派模型 JVM内存能简单说一下 JVM 的内存区域吗？ JVM 的内存区域，有时叫 JVM 的内存结构，有时也叫 JVM 运行时数据区，其中包含方法区、堆，Java方法栈、本地方法栈、程序计数器 其中方法区和堆是线程共享的，其他的都是线程私有的，然后我把每个都大致说一下功能 程序计数器：较小内存空间，不存在内存溢出问题，前线程所执行的字节码行号指示器 Java虚拟机栈：线程独有的，生命周期和线程一致，执行一个方法时压入一个栈帧，执行完毕后被移除，栈不存在垃圾回收问题，但是存在内存溢出问题 本地方法栈：其实和虚拟机栈差不多，只是虚拟机栈是由Java写的，而本地方法栈是为 Java 调用本地（native）方法服务的，由 C&#x2F;C++ 编写。 堆：是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储对象的。也是垃圾回收器作用的主要区域。 方法区：方法区并不真实存在，属于 Java 虚拟机规范中的一个逻辑概念，用于存储已被 JVM 加载的类信息、常量、静态变量，在JDK1.8前叫永久代，后面就改名为直接内存中划出一块区域作为元空间，运行时常量池、类常量池都移动到元空间。 为什么PC寄存器为什么会被设定为线程私有的？首先多线程如果共享一个计数器，当一个线程被中断，另一个线程开始执行的时候程序计数器会被错误的更新，这样会破坏前一个线程的状态。如果是线程独享的，那么在进行线程调度的时候他都可以保存当前执行状态，这种隔离性在多线程中至关重要。 Java虚拟机栈如何进行方法计算的？ 局部变量表（Local Variable Array）：当方法被调用时，传入的参数会被存储在局部变量表中。对于实例方法，第一个局部变量总是this引用，指向调用该方法的对象。局部变量表中的变量可以通过索引来访问。 操作数栈（Operand Stack）：用于临时存储中间结果，以及作为方法调用和返回过程中参数传递的工具。 动态链接（Dynamic Linking）：因为多态概念的存在，所以编译器在编译的时候并不知道对象类型，所以只有在运行时才能确定对象，指向常量池里方法的引用。 方法返回地址（Return Address）：当方法执行完成后，返回到调用方法的地址。 当一个线程调用一个方法时，JVM会为这个方法分配一个新的栈帧，并将其压入当前线程的JVM栈中，栈帧里有局部遍历表、操作数栈、动态链接、方法返回地址等等。JVM中的解释器会逐条读取并执行方法中的字节码指令，比如将操作数栈中的值进行算术运算后存储到局部变量表，将局部变量表中的值加载到操作数栈，具体操作会根据字节码指令来，比如在不同数据类型之间进行转换、创建和操作对象、条件判断、循环和方法调用等。 对象创建的过程了解吗？销毁呢当我们使用 new 关键字创建一个对象的时候，JVM 首先会检查 new 指令的参数是否能在常量池中定位到一个类的符号引用，然后检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程。 如果已经加载，JVM 会为新生对象分配内存，内存分配完成之后，JVM 将分配到的内存空间初始化为零值（成员变量，数值类型是 0，布尔类型是 false，对象类型是 null），接下来设置对象头，对象头里包含了对象是哪个类的实例、对象的哈希码、对象的 GC 分代年龄等信息。 最后，JVM 会执行构造方法（&lt;init&gt;），将成员变量赋值为预期的值，这样一个对象就创建完成了。 当对象不再被任何引用指向时，对象就会变成垃圾，这就涉及到垃圾回收机制。 JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？ 堆：所有线程共享的内存区域 线程本地分配缓冲区（Thread Local Allocation Buffer, TLAB）：为了减少多线程分配对象时的竞争，JVM为每个线程分配了一个私有的小堆空间每个线程在其自己的TLAB中分配内存，这样在大多数情况下，内存分配是线程私有的。 会，首先有TLAB的存在，大大减少了多线程的竞争，但是如果TLAB中没有足够的空间，比如对象太大，那就得从全局堆里分配。这就涉及到了对全局堆的竞争和同步，比如线程A给对象分配内存按流程指正应该右移一个对象size的距离，但是指针还没来得及修改，另一个线程为B分配内存又引用了这个还没来的及右移的指针，这就发生了抢占。至于JVM设计的方法，就像刚刚说的TLAB 线程本地分配缓冲区，为每个线程分配了一个私有的小堆空间每个线程在其自己的TLAB中分配内存，这样在大多数情况下，内存分配是线程私有的。还有采用CAS 比较并交换（Compare And Swap）他是一直乐观锁实现方式，用来保证更新的原子性，就是类似于版本控制一样的，会把要更新的变量和预期值进行判短，如果符合预期那就更新不符合就不更新。 能说一下对象的内存布局吗？具体的实现细节可能因不同的 JVM 实现（如 HotSpot、OpenJ9 等）而异。我这里以HotSpot为例，对象在堆内存中的存储布局可以划分为三个部分：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。其中对象头 有标记字（Mark Word）、类型指针（Class Pointer）、数组长度（Array Length）。然后标记字里面又包含了对象自身的运行时数据，如哈希码（HashCode）、垃圾回收分代年龄、锁状态标志、线程持有的锁、偏向线程 ID 等信息。在 64 位操作系统下占 8 个字节，32 位操作系统下占 4 个字节。 内存溢出和内存泄漏是什么意思？能举个例子吗内存溢出（Out of Memory，俗称 OOM）和内存泄漏（Memory Leak）是两个不同的概念，但它们都与内存管理有关。内存溢出是程序请求分配内存时，由于没有足够的内存空间满足其需求，而内存泄漏是指程序在使用完内存后，未能释放已分配的内存空间，导致这部分内存无法再被使用。随着时间的推移，内存泄漏会导致可用内存逐渐减少，最终可能导致内存溢出。 内存泄漏可能由哪些原因导致呢？怎么解决 使用静态集合类存储对象，这些对象可整个生命周期内都不会被清除 创建的连接不再使用时，需要调用 close 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。 长生命周期的对象引用了短生命周期的对象，导致导致短生命周期对象无法被回收。 ThreadLocal 的弱引用导致内存泄漏也是个老生常谈的话题了，使用完 ThreadLocal 一定要记得使用 remove 方法来进行清除。 知道了原因要解决就相对简单了，比如尽量避免非静态内部类，写代码的时候及时释放资源等等 说一下对象有哪几种引用？Java 中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。 强引用就是最传统的引用的定义，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象 软引用 ，SoftReference实现，用来描述一些还有用，但非必须的对象，只被软引用关联着的对象，如果将要发生内存 溢出了就会被回收， 弱引用，WeakReference实现，描述那些非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。 虚引用，PhantomReference实现，也称为“幽灵引用”或者“幻影引用”，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。 对象一定分配在堆中吗？有没有了解逃逸分析技术？（待补充）垃圾回收Minor GC&#x2F;Young GC、Major GC&#x2F;Old GC、Mixed GC、Full GC 都是什么意思？Minor GC 也称为 Young GC，是指发生在年轻代（Young Generation）的垃圾收集。Major GC 也称为 Old GC，主要指的是发生在老年代的垃圾收集。Mixed GC 是 G1 垃圾收集器特有的一种 GC 类型，它在一次 GC 中同时清理年轻代和部分老年代。Full GC 是最彻底的垃圾收集，涉及整个 Java 堆和方法区（或元空间）。它是最耗时的 GC，通常在 JVM 压力很大时发生。 为什么JVM要垃圾回收？你知道哪些垃圾回收器垃圾回收GC，有多种垃圾回收器，我知道的有8种，每种回收器可能使用了不同的算法，一步一步来，第一为什么jvm要进行垃圾回收，垃圾就是JVM中没有任何引用指向它的对象，如果不清理就会一直占用内存，然后垃圾对象越来越多就可能出现OOM（Out Of Memory）内存溢出。 名称 执行方式 执行目标 使用算法 Serial GC STW、串行、单线程 新生代 复制算法 Serial Old GC STW、串行、单线程 老年代 标记-整理算法 ParNew GC STW、并行、多线程 新生代 复制算法 CMS GC 低暂停、并行 老年代 标记-清除算法 Parallel GC STW、并行、多线程 新生代 复制算法 Parallel Old GC STW、并行、多线程 老年代 标记-整理算法 G1 GC 低暂停，并行 整堆 标记-复制算法 ZGC 低暂停，并行 整堆 标记-复制算法 STW：暂停工作线程，存在是因为Java的垃圾回收器需要扫描整个堆内存来标记和清除不再使用的对象，如果不停止应用线程的话，会导致垃圾回收器扫描时出现漏标和误删的情况。 堆：是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储对象的。也是垃圾回收器作用的主要区域。他分为新生代和老年代，两个区域比例为1:2： 新生代：包含Edan、s0（Survivor），s1三个部分，比例为8:1:1，一般对象来的时候先放到edan区，edan区里新对象来之后触发垃圾回收，把还在用的对象放全部到S0或者S1，然后更新GC次数，edan区触发垃圾回收时s0和s1会进行角色交换，每次交换GC次数也会增加，而且S0和S1两个不能同时存放对象，就是因为设计了角色交换机制，并且可以避免内存碎片化。当新生代里对象GC次数达到15次以上后，就会把对象移到老年代。这里我之前说了一般对象来的时候先放到edan区，如果来了一个很大的对象，Edan区可以放下但是s0，s1放不下，那么他后续就不会再放到s0或s1而是直接放到老年代，如果来了一个更大的对象，edan区都放不下，那么就会直接放到老年代。在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，那么年龄大于或等于该年龄的对象就可以直接进入老年代。 老年代：对象来到老年代后触发的回收机制就会和新生代不一样。 标记-复制算法：典型的空间换时间的算法，他有两块内存空间，每次只使用一个在垃圾回收时会把可达对象复制到没有用的那块内存，这样不会产生内存碎片也很高效，所以比较适合新生代这种垃圾对象多的 标记-整理算法：先对内存中存货的对象进行标记，然后清除垃圾对象，再把存活对象移到内存一段，这样也不会产生内存碎片，但是速度也慢所以适合老年代。 标记-清除算法：先对内存中存货的对象进行标记，然后清除垃圾对象，会产生内存碎片，速度较快 GC ROOT：是一组特殊的对象集合，它们作为活跃对象的根节点，垃圾收集器能够通过GC ROOT遍历整个对象引用图，从而标记出哪些对象是可达的（活跃的），哪些对象是不可达的（无用的） 初始标记：只标记GC ROOT的第一层，很快 三色标记：它将对象分为三类：白色、灰色和黑色，所有对象开始都是白色的，从 GC Root 开始，将根对象标记为灰色，然后把灰色对象的所有白色对象标记为灰色，再把这个灰色对象标记为黑色，按照这个逻辑进行重复扫描、标记。 白色：未被访问的对象，在标记阶段结束时，所有仍然是白色的对象都是不可达的，将被垃圾收集器回收 灰色：已被访问但其引用的对象还未全部被访问的对象，需要进一步扫描 黑色：黑色对象和它们引用的对象都是可达的，不会被回收 然后说回jvm的垃圾回收器，在jdk8之前，用的是Serial GC和Serial Old GC，他们会进行STW也就是暂停工作线程，他们是单线程的，jdk8之前被引入，分别针对的是Java堆中的新生代和老年代，Serial GC用的是复制算法，典型的空间换时间的算法，他有两块内存空间，每次只使用一个在垃圾回收时会把可达对象复制到没有用的那块内存，这样不会产生内存碎片也很高效，所以比较适合新生代这种垃圾对象多的。然后Serial Old GC，用的标记-整理算法，就是先对内存中存货的对象进行标记，然后清除垃圾对象，再把存活对象移到内存一段，这样也不会产生内存碎片，但是速度也慢所以适合老年代。对应的还有Parallel GC和Parallel Old GC他们对应的是Serial GC和Serial Old GC的多线程版本。 还有ParNew GC和CMS GC，不过对于CMS GC，他有个特点就是低暂停，他会先先通过GC ROOT找到直接可达的对象，我们知道GC ROOT 是特殊的特殊的对象集合，如果是完整的标记则需要通过GC ROOT遍历整个对象引用图，从而标记出哪些对象是可达的，哪些对象是不可达的，但是CMS GC是先进行初始标记，就是只标记GC Roots，这样是很快的，然后是并行标记，他把从GC ROOT遍历整个对象引用图的过程放到和用户线程并行运行，也就是没有暂停用户线程，但是同样的吞吐量会降低，因为单位时间用户线程数变少了，耗时较长，而且因为用户线程在工作，所以会产生新的对象或者之前标记的垃圾对象又变成非垃圾对象了，所以jvm通过三色标记来解决这个问题，三色标记它将对象分为三类：白色、灰色和黑色，白色表示未被访问的对象，在标记阶段结束时，所有仍然是白色的对象都是不可达的，将被垃圾收集器回收，灰色就是已被访问但其引用的对象还未全部被访问的对象，就需要进一步扫描，黑色对象和它们引用的对象都是可达的，不会被回收，一开始所有对象都是白色，然后从GC ROOT开始，把对象标记成灰色，当GC ROOT的引用对象被全部访问就标记为黑色。然后进行STW重新标记，也就是进行一些收尾动作，矫正之前标记产生的误差，是增量更新，所以耗时也不长，然后和用户线程并发清理垃圾对象和并发重置标记。所以CMS GC把标记和清理两个最耗时的操作放到和用户的线程一起并行运行，更高效。 讲讲G1 GC和ZGC最后就是G1 GC和ZGC，G1 在 1.9 版本后成为 JVM 的默认垃圾回收算法，G1 的特点是保持高回收率的同时，减少停顿。取消了堆中年轻代与老年代的物理划分，但它逻辑上仍然属于分代收集器。G1 算法将堆划分为若干个区块，默认是2048个，称作 Region，相当于把新生代代和老年代给拆分成一小块一小块的，一个区块可能是Eden或者Survivor也可能是Old或者大对象。需要注意的是ZGC虽然也采用Region但是Region并不是定长的，可以分为大区块和小区块，G1的垃圾回收过程除开新生代，新生代是直接使用STW进行标记复制算法，后续的回收为混合回收，在回收老年代的时候也会回收新生代，混合回收的过程可以简单概括为，初始标记、并发标记、再标记、清理、复制。其实其过程和CMS GC差不多，最大的不同是在回收阶段，CMS GC是并发清理垃圾对象，然后并发重置垃圾对象，而C1是筛选回收，会筛选出具有性价比的区块进行并发回收，并且可以调整STW的时间。 对于ZGC，首先在说ZGC之前需要说明两个关键技术：着色指针和读屏障技术。着色指针就是将信息存储在指针中，并且仅支持64位系统，当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址，ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。读屏障技术就是JVM向应用代码插入一小段代码，仅当应用线程从“从堆中读取对象引用”才会触发这段代码。这一小段代码可以在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。 然后就是ZGC到底是怎么进行垃圾回收的，首先初始化，整个地址视图会进行Remapped，程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入并发标记阶段。第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。标记结束后就进入并发转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。也就是说，第二次进入并发标记阶段后，地址视图调整为M1，而非M0。在并发转移阶段，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。 ZGC为什么快？CMS GC和G1 GC性能瓶颈在哪了解，首先先说CMS GC和G1 GC性能瓶颈，我们知道CMS GC新生代的Young GC和C1 GC、ZGC都是基于标记复制算法，只是实现有很大不同，我们以G1为例，在混合回收的时候会有4个STW，其中初始标记阶段，初始标记因为只标记GC Roots，耗时较短；再标记因为是增量更新对象数少，耗时也较短；清理阶段，清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制，因为内存分区数量少，耗时也较短；复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。G1的Young GC和CMS的Young GC，其标记-复制全过程STW，就不再阐述。 全并发的ZGC：ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。ZGC只有三个STW阶段，初始标记，再标记，初始转移。其中初始标记和初始转移只需要扫描所有GC Roots处理时间都非常短，最多1ms，超过1ms则再次进入并发标记阶段。ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。 你们线上用的什么垃圾收集器？为什么要用它？我们生产环境中采用了设计比较优秀的 G1 垃圾收集器，因为它不仅能满足低停顿的要求，而且解决了 CMS 的浮动垃圾问题、内存碎片问题。G1 非常适合大内存、多核处理器的环境。 执行引擎知道JIT吗？他有什么用（待补充）JVM调优有做过 JVM 调优吗？怎么做的（待定）在没有全面监控收集到性能数据前都不适合动JVM，JVM 调优是一个非常复杂的过程，最多就是调调栈、堆的大小，比例关系，但是我任然认为在没有完整的性能数据前都不需要动jvm。我在项目里一般都是先优化自己写的代码，但是我学习了一些jvm调优的思路：","tags":[null,null],"categories":[null]},{"title":"Workflow 专栏介绍","path":"/doc/java/workflow/workflow.html","content":"围绕云服务器进行多端同步的思路展开与工作流构建。包含大致功能如下： 同步与备份：通过搭建Syncthing的中继服务器和发现服务器，把手机、电脑、pad、服务器联系起来，其中云服务器不但可以中转、存储还能通过内网访问挂载到服务器的oss，以增加存储空间实现备份效果 预览与下载：通过Alist挂载服务器目录，配合重定向实现在浏览器上预览的图床功能，当然下载功能也不在话下。 笔记：通过Obsidian写笔记，因为笔记数据按照文件夹的形式进行本地存储，所以可以通过相对链接渲染图片、视频等，如果要放其他格式文档，比如pdf、xmind文档等，则可以从alist上获取下载链接。 博客：使用hexo静态博客，主题为Stellar。本地编译，通过同步可以把实现在Obsidian的笔记目录下写完文章自动同步到博客的目录下，再配合脚本与插件实现一件编写、发布、修改、推送一条路服务，真正把博客和笔记相互交融！ 密码管理：使用Bitwardn 自建后台服务，把密码放在自己的服务上。 科学上网：使用3-xui搭建节点，配合v2rayN实现科学上网。其中整理了部分节点种类，实现链式代理。 服务器安全与运维：目前采用Portainer 管理docker容器，使用反向代理大量减少开放对外端口，配置报警规则，对开放的服务采用严格的密码能使用二级登录就使用二级登录，尽量防止Ddos攻击。目前是收到创建快照备份服务器数据。 具体实现请见该专栏下的其他文章！ xmind文档下载地址","tags":[null],"categories":[null]},{"title":"Workflow 专栏介绍","path":"/doc1/java/workflow/workflow.html","content":"围绕云服务器进行多端同步的思路展开与工作流构建。包含大致功能如下： 同步与备份：通过搭建Syncthing的中继服务器和发现服务器，把手机、电脑、pad、服务器联系起来，其中云服务器不但可以中转、存储还能通过内网访问挂载到服务器的oss，以增加存储空间实现备份效果 预览与下载：通过Alist挂载服务器目录，配合重定向实现在浏览器上预览的图床功能，当然下载功能也不在话下。 笔记：通过Obsidian写笔记，因为笔记数据按照文件夹的形式进行本地存储，所以可以通过相对链接渲染图片、视频等，如果要放其他格式文档，比如pdf、xmind文档等，则可以从alist上获取下载链接。 博客：使用hexo静态博客，主题为Stellar。本地编译，通过同步可以把实现在Obsidian的笔记目录下写完文章自动同步到博客的目录下，再配合脚本与插件实现一件编写、发布、修改、推送一条路服务，真正把博客和笔记相互交融！ 密码管理：使用Bitwardn 自建后台服务，把密码放在自己的服务上。 科学上网：使用3-xui搭建节点，配合v2rayN实现科学上网。其中整理了部分节点种类，实现链式代理。 服务器安全与运维：目前采用Portainer 管理docker容器，使用反向代理大量减少开放对外端口，配置报警规则，对开放的服务采用严格的密码能使用二级登录就使用二级登录，尽量防止Ddos攻击。目前是收到创建快照备份服务器数据。 具体实现请见该专栏下的其他文章！ xmind文档下载地址","tags":[null],"categories":[null]},{"title":"JVM 相关知识与面试题的结合","path":"/doc1/java/JVM/JVM.html","content":"JVM 概述 什么是JVM，说说jvm的组织架构JVM，也就是 Java 虚拟机，在运行Java程序的时候编译器会把Java源文件编译成平台无关的class字节码文件，然后再由虚拟机进行解释，把字节码文件翻译成对应的二进制指令。这也是Java为什么具有跨平台性的核心原因。JVM由类加载器、运行时数据区、执行引擎三大部分组成。首先Java类被编译成class文件之后，会进到类加载子系统，经过验证、准备、解析、初始化之后把类加载成class对象到内存的方法区。在内存中有方法区、堆、本地方法栈、虚拟机栈，被加载到方法区的类对象会执行其二进制指令，其中每个线程方法会被压入虚拟机栈，虚拟机栈有每个方法对应一个栈帧，每个栈帧有局部变量表、操作树栈、动态链接、放回方法地址等，方法会在栈帧中执行，如果创建了对象，则对象会被放在堆中，堆一般被分为新生代和老生代，这还涉及到GC算法。 类加载器：负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。 运行时数据区：JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域主要包括方法区、堆、虚拟机栈、程序计数器和本地方法栈。 执行引擎：是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器，还包括即时编译器（JIT Compiler）和垃圾回收器（Garbage Collector）。 类加载子系统 类加载子系统是如和工作的？将编译好的字节码文件（.class 文件）加载到 Java 虚拟机 (JVM) 中 加载：类加载器读取字节码文件，并将其内容转换为二进制流，再在内存中创建一个 java.lang.Class 对象来表示这个类。 验证：对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。 准备：对类变量（也称为静态变量，static 关键字修饰的变量）分配内存并初始化，初始化为数据类型的默认值，如 0、0L、null、false 等，但是不包括static静态代码块。 解析：是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、成员方法等。 初始化：在准备阶段，类变量已经被赋过默认初始值了，而在初始化阶段，类变量将被赋值为代码期望赋的值。 类加载子系统是将class文件加载成内存中的方法区的class对象，类加载过程主要包含三个阶段：加载、链接、初始化；他会先从文件系统、网络或其他来源加载 Class 文件，读取类的二进制数据到内存中。然后进行验证，确保加载的类符合 JVM 规范，比如说验证文件格式继承结构的正确性、常量池中的常量是否有效。然后进行准备，为类的静态变量分配内存并设置默认初始值。再然后进行解析，把类中的符号引用转换为直接引用，比如类和接口的符号引用、字段和方法的符号引用解析为直接引用。解析完后进行初始化，比如初始化类的静态变量和执行静态代码块。 类加载器有哪些？他们是如何工作的 Bootstrap ClassLoader（启动类加载器）：负责加载 JVM 的核心类库，是c&#x2F;c++写的是最顶层的加载器。 Extension ClassLoader（扩展类加载器）：负责加载JAVA_HOME/jre/lib/ext目录下，或者由系统属性java.ext.dirs指定位置的类库 Application ClassLoader（应用程序类加载器）：负责加载系统类路径CLASSPATH上的类库，通常是我们在开发 Java 应用程序时的主要类加载器。 User-defined ClassLoader（用户自定义类加载器）：我们可以通过继承java.lang.ClassLoader类来创建自己的类加载器。 这四个加载器从用户自定义加载器到启动类加载器，从下到上构成了分层非继承的关系，也就是用户类加载器的上一级是应用程序加载器，每层都是往上如此，当加载请求到来时他们会从下往上依次把请求交给上一级，直到最顶层。如果父类加载器能够加载该类，则直接返回；如果不能那么子类加载器才会尝试加载。这种加载机制构成了双亲委派模型。 双亲委派模型有什么好处？如果用户自定义了一个java.long.String类，通过这种加载机制也会先找到顶层的类加载器加载并返回Class对象，既可以防止核心API被篡改，保证Java体系的稳定，也可以避免类的重复加载，如果没有这种模型，可能会导致同一个类被不同的类加载器重复加载到内存中 为什么要打破双亲委派模型，怎么打破？ 要打破双亲委派模型肯定是有对应的需求 自定义类加载需求：可以通过继承java.lang.ClassLoader类并重写findClass方法来实现自定义的类加载器，比如直接加载类而不是委托给父加载器 插件化需求：比如我们熟悉的JDBC各个厂商都有不同的JDBC实现，但是Java核心包里也有，而各个厂商的实现，是没办法放在核心包里的，只能放在classpath里，也就只能由AppClassLoder 进行加载，如果遵循模型，那么只会优先加载Java核心包里的。那么我们可以通过设置线程上下文类加载器来让某个线程使用不同的类加载器加载类 热更新：比如例如代码热替换（Hot Swap），因为双亲委派模型是使用已经加载的类而不是尝试重新加载，那么我们监控类文件或配置文件的变更来触发热部署，重写findClass()方法，当需要跟新时就把类加载器换掉。 为什么Tomcat需要自定义类加载器？Tomact 是 web 容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。所以，Tomcat 破坏了双亲委派模型，提供隔离的机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。并且Tomcat的热加载也是需要破坏双亲委派模型 JVM内存能简单说一下 JVM 的内存区域吗？ JVM 的内存区域，有时叫 JVM 的内存结构，有时也叫 JVM 运行时数据区，其中包含方法区、堆，Java方法栈、本地方法栈、程序计数器 其中方法区和堆是线程共享的，其他的都是线程私有的，然后我把每个都大致说一下功能 程序计数器：较小内存空间，不存在内存溢出问题，前线程所执行的字节码行号指示器 Java虚拟机栈：线程独有的，生命周期和线程一致，执行一个方法时压入一个栈帧，执行完毕后被移除，栈不存在垃圾回收问题，但是存在内存溢出问题 本地方法栈：其实和虚拟机栈差不多，只是虚拟机栈是由Java写的，而本地方法栈是为 Java 调用本地（native）方法服务的，由 C&#x2F;C++ 编写。 堆：是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储对象的。也是垃圾回收器作用的主要区域。 方法区：方法区并不真实存在，属于 Java 虚拟机规范中的一个逻辑概念，用于存储已被 JVM 加载的类信息、常量、静态变量，在JDK1.8前叫永久代，后面就改名为直接内存中划出一块区域作为元空间，运行时常量池、类常量池都移动到元空间。 为什么PC寄存器为什么会被设定为线程私有的？首先多线程如果共享一个计数器，当一个线程被中断，另一个线程开始执行的时候程序计数器会被错误的更新，这样会破坏前一个线程的状态。如果是线程独享的，那么在进行线程调度的时候他都可以保存当前执行状态，这种隔离性在多线程中至关重要。 Java虚拟机栈如何进行方法计算的？ 局部变量表（Local Variable Array）：当方法被调用时，传入的参数会被存储在局部变量表中。对于实例方法，第一个局部变量总是this引用，指向调用该方法的对象。局部变量表中的变量可以通过索引来访问。 操作数栈（Operand Stack）：用于临时存储中间结果，以及作为方法调用和返回过程中参数传递的工具。 动态链接（Dynamic Linking）：因为多态概念的存在，所以编译器在编译的时候并不知道对象类型，所以只有在运行时才能确定对象，指向常量池里方法的引用。 方法返回地址（Return Address）：当方法执行完成后，返回到调用方法的地址。 当一个线程调用一个方法时，JVM会为这个方法分配一个新的栈帧，并将其压入当前线程的JVM栈中，栈帧里有局部遍历表、操作数栈、动态链接、方法返回地址等等。JVM中的解释器会逐条读取并执行方法中的字节码指令，比如将操作数栈中的值进行算术运算后存储到局部变量表，将局部变量表中的值加载到操作数栈，具体操作会根据字节码指令来，比如在不同数据类型之间进行转换、创建和操作对象、条件判断、循环和方法调用等。 对象创建的过程了解吗？销毁呢当我们使用 new 关键字创建一个对象的时候，JVM 首先会检查 new 指令的参数是否能在常量池中定位到一个类的符号引用，然后检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程。 如果已经加载，JVM 会为新生对象分配内存，内存分配完成之后，JVM 将分配到的内存空间初始化为零值（成员变量，数值类型是 0，布尔类型是 false，对象类型是 null），接下来设置对象头，对象头里包含了对象是哪个类的实例、对象的哈希码、对象的 GC 分代年龄等信息。 最后，JVM 会执行构造方法（&lt;init&gt;），将成员变量赋值为预期的值，这样一个对象就创建完成了。 当对象不再被任何引用指向时，对象就会变成垃圾，这就涉及到垃圾回收机制。 JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？ 堆：所有线程共享的内存区域 线程本地分配缓冲区（Thread Local Allocation Buffer, TLAB）：为了减少多线程分配对象时的竞争，JVM为每个线程分配了一个私有的小堆空间每个线程在其自己的TLAB中分配内存，这样在大多数情况下，内存分配是线程私有的。 会，首先有TLAB的存在，大大减少了多线程的竞争，但是如果TLAB中没有足够的空间，比如对象太大，那就得从全局堆里分配。这就涉及到了对全局堆的竞争和同步，比如线程A给对象分配内存按流程指正应该右移一个对象size的距离，但是指针还没来得及修改，另一个线程为B分配内存又引用了这个还没来的及右移的指针，这就发生了抢占。至于JVM设计的方法，就像刚刚说的TLAB 线程本地分配缓冲区，为每个线程分配了一个私有的小堆空间每个线程在其自己的TLAB中分配内存，这样在大多数情况下，内存分配是线程私有的。还有采用CAS 比较并交换（Compare And Swap）他是一直乐观锁实现方式，用来保证更新的原子性，就是类似于版本控制一样的，会把要更新的变量和预期值进行判短，如果符合预期那就更新不符合就不更新。 能说一下对象的内存布局吗？具体的实现细节可能因不同的 JVM 实现（如 HotSpot、OpenJ9 等）而异。我这里以HotSpot为例，对象在堆内存中的存储布局可以划分为三个部分：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。其中对象头 有标记字（Mark Word）、类型指针（Class Pointer）、数组长度（Array Length）。然后标记字里面又包含了对象自身的运行时数据，如哈希码（HashCode）、垃圾回收分代年龄、锁状态标志、线程持有的锁、偏向线程 ID 等信息。在 64 位操作系统下占 8 个字节，32 位操作系统下占 4 个字节。 内存溢出和内存泄漏是什么意思？能举个例子吗内存溢出（Out of Memory，俗称 OOM）和内存泄漏（Memory Leak）是两个不同的概念，但它们都与内存管理有关。内存溢出是程序请求分配内存时，由于没有足够的内存空间满足其需求，而内存泄漏是指程序在使用完内存后，未能释放已分配的内存空间，导致这部分内存无法再被使用。随着时间的推移，内存泄漏会导致可用内存逐渐减少，最终可能导致内存溢出。 内存泄漏可能由哪些原因导致呢？怎么解决 使用静态集合类存储对象，这些对象可整个生命周期内都不会被清除 创建的连接不再使用时，需要调用 close 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。 长生命周期的对象引用了短生命周期的对象，导致导致短生命周期对象无法被回收。 ThreadLocal 的弱引用导致内存泄漏也是个老生常谈的话题了，使用完 ThreadLocal 一定要记得使用 remove 方法来进行清除。 知道了原因要解决就相对简单了，比如尽量避免非静态内部类，写代码的时候及时释放资源等等 说一下对象有哪几种引用？Java 中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。 强引用就是最传统的引用的定义，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象 软引用 ，SoftReference实现，用来描述一些还有用，但非必须的对象，只被软引用关联着的对象，如果将要发生内存 溢出了就会被回收， 弱引用，WeakReference实现，描述那些非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。 虚引用，PhantomReference实现，也称为“幽灵引用”或者“幻影引用”，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。 对象一定分配在堆中吗？有没有了解逃逸分析技术？（待补充）垃圾回收Minor GC&#x2F;Young GC、Major GC&#x2F;Old GC、Mixed GC、Full GC 都是什么意思？Minor GC 也称为 Young GC，是指发生在年轻代（Young Generation）的垃圾收集。Major GC 也称为 Old GC，主要指的是发生在老年代的垃圾收集。Mixed GC 是 G1 垃圾收集器特有的一种 GC 类型，它在一次 GC 中同时清理年轻代和部分老年代。Full GC 是最彻底的垃圾收集，涉及整个 Java 堆和方法区（或元空间）。它是最耗时的 GC，通常在 JVM 压力很大时发生。 为什么JVM要垃圾回收？你知道哪些垃圾回收器垃圾回收GC，有多种垃圾回收器，我知道的有8种，每种回收器可能使用了不同的算法，一步一步来，第一为什么jvm要进行垃圾回收，垃圾就是JVM中没有任何引用指向它的对象，如果不清理就会一直占用内存，然后垃圾对象越来越多就可能出现OOM（Out Of Memory）内存溢出。 名称 执行方式 执行目标 使用算法 Serial GC STW、串行、单线程 新生代 复制算法 Serial Old GC STW、串行、单线程 老年代 标记-整理算法 ParNew GC STW、并行、多线程 新生代 复制算法 CMS GC 低暂停、并行 老年代 标记-清除算法 Parallel GC STW、并行、多线程 新生代 复制算法 Parallel Old GC STW、并行、多线程 老年代 标记-整理算法 G1 GC 低暂停，并行 整堆 标记-复制算法 ZGC 低暂停，并行 整堆 标记-复制算法 STW：暂停工作线程，存在是因为Java的垃圾回收器需要扫描整个堆内存来标记和清除不再使用的对象，如果不停止应用线程的话，会导致垃圾回收器扫描时出现漏标和误删的情况。 堆：是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储对象的。也是垃圾回收器作用的主要区域。他分为新生代和老年代，两个区域比例为1:2： 新生代：包含Edan、s0（Survivor），s1三个部分，比例为8:1:1，一般对象来的时候先放到edan区，edan区里新对象来之后触发垃圾回收，把还在用的对象放全部到S0或者S1，然后更新GC次数，edan区触发垃圾回收时s0和s1会进行角色交换，每次交换GC次数也会增加，而且S0和S1两个不能同时存放对象，就是因为设计了角色交换机制，并且可以避免内存碎片化。当新生代里对象GC次数达到15次以上后，就会把对象移到老年代。这里我之前说了一般对象来的时候先放到edan区，如果来了一个很大的对象，Edan区可以放下但是s0，s1放不下，那么他后续就不会再放到s0或s1而是直接放到老年代，如果来了一个更大的对象，edan区都放不下，那么就会直接放到老年代。在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，那么年龄大于或等于该年龄的对象就可以直接进入老年代。 老年代：对象来到老年代后触发的回收机制就会和新生代不一样。 标记-复制算法：典型的空间换时间的算法，他有两块内存空间，每次只使用一个在垃圾回收时会把可达对象复制到没有用的那块内存，这样不会产生内存碎片也很高效，所以比较适合新生代这种垃圾对象多的 标记-整理算法：先对内存中存货的对象进行标记，然后清除垃圾对象，再把存活对象移到内存一段，这样也不会产生内存碎片，但是速度也慢所以适合老年代。 标记-清除算法：先对内存中存货的对象进行标记，然后清除垃圾对象，会产生内存碎片，速度较快 GC ROOT：是一组特殊的对象集合，它们作为活跃对象的根节点，垃圾收集器能够通过GC ROOT遍历整个对象引用图，从而标记出哪些对象是可达的（活跃的），哪些对象是不可达的（无用的） 初始标记：只标记GC ROOT的第一层，很快 三色标记：它将对象分为三类：白色、灰色和黑色，所有对象开始都是白色的，从 GC Root 开始，将根对象标记为灰色，然后把灰色对象的所有白色对象标记为灰色，再把这个灰色对象标记为黑色，按照这个逻辑进行重复扫描、标记。 白色：未被访问的对象，在标记阶段结束时，所有仍然是白色的对象都是不可达的，将被垃圾收集器回收 灰色：已被访问但其引用的对象还未全部被访问的对象，需要进一步扫描 黑色：黑色对象和它们引用的对象都是可达的，不会被回收 然后说回jvm的垃圾回收器，在jdk8之前，用的是Serial GC和Serial Old GC，他们会进行STW也就是暂停工作线程，他们是单线程的，jdk8之前被引入，分别针对的是Java堆中的新生代和老年代，Serial GC用的是复制算法，典型的空间换时间的算法，他有两块内存空间，每次只使用一个在垃圾回收时会把可达对象复制到没有用的那块内存，这样不会产生内存碎片也很高效，所以比较适合新生代这种垃圾对象多的。然后Serial Old GC，用的标记-整理算法，就是先对内存中存货的对象进行标记，然后清除垃圾对象，再把存活对象移到内存一段，这样也不会产生内存碎片，但是速度也慢所以适合老年代。对应的还有Parallel GC和Parallel Old GC他们对应的是Serial GC和Serial Old GC的多线程版本。 还有ParNew GC和CMS GC，不过对于CMS GC，他有个特点就是低暂停，他会先先通过GC ROOT找到直接可达的对象，我们知道GC ROOT 是特殊的特殊的对象集合，如果是完整的标记则需要通过GC ROOT遍历整个对象引用图，从而标记出哪些对象是可达的，哪些对象是不可达的，但是CMS GC是先进行初始标记，就是只标记GC Roots，这样是很快的，然后是并行标记，他把从GC ROOT遍历整个对象引用图的过程放到和用户线程并行运行，也就是没有暂停用户线程，但是同样的吞吐量会降低，因为单位时间用户线程数变少了，耗时较长，而且因为用户线程在工作，所以会产生新的对象或者之前标记的垃圾对象又变成非垃圾对象了，所以jvm通过三色标记来解决这个问题，三色标记它将对象分为三类：白色、灰色和黑色，白色表示未被访问的对象，在标记阶段结束时，所有仍然是白色的对象都是不可达的，将被垃圾收集器回收，灰色就是已被访问但其引用的对象还未全部被访问的对象，就需要进一步扫描，黑色对象和它们引用的对象都是可达的，不会被回收，一开始所有对象都是白色，然后从GC ROOT开始，把对象标记成灰色，当GC ROOT的引用对象被全部访问就标记为黑色。然后进行STW重新标记，也就是进行一些收尾动作，矫正之前标记产生的误差，是增量更新，所以耗时也不长，然后和用户线程并发清理垃圾对象和并发重置标记。所以CMS GC把标记和清理两个最耗时的操作放到和用户的线程一起并行运行，更高效。 讲讲G1 GC和ZGC最后就是G1 GC和ZGC，G1 在 1.9 版本后成为 JVM 的默认垃圾回收算法，G1 的特点是保持高回收率的同时，减少停顿。取消了堆中年轻代与老年代的物理划分，但它逻辑上仍然属于分代收集器。G1 算法将堆划分为若干个区块，默认是2048个，称作 Region，相当于把新生代代和老年代给拆分成一小块一小块的，一个区块可能是Eden或者Survivor也可能是Old或者大对象。需要注意的是ZGC虽然也采用Region但是Region并不是定长的，可以分为大区块和小区块，G1的垃圾回收过程除开新生代，新生代是直接使用STW进行标记复制算法，后续的回收为混合回收，在回收老年代的时候也会回收新生代，混合回收的过程可以简单概括为，初始标记、并发标记、再标记、清理、复制。其实其过程和CMS GC差不多，最大的不同是在回收阶段，CMS GC是并发清理垃圾对象，然后并发重置垃圾对象，而C1是筛选回收，会筛选出具有性价比的区块进行并发回收，并且可以调整STW的时间。 对于ZGC，首先在说ZGC之前需要说明两个关键技术：着色指针和读屏障技术。着色指针就是将信息存储在指针中，并且仅支持64位系统，当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址，ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。读屏障技术就是JVM向应用代码插入一小段代码，仅当应用线程从“从堆中读取对象引用”才会触发这段代码。这一小段代码可以在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。 然后就是ZGC到底是怎么进行垃圾回收的，首先初始化，整个地址视图会进行Remapped，程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入并发标记阶段。第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。标记结束后就进入并发转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。也就是说，第二次进入并发标记阶段后，地址视图调整为M1，而非M0。在并发转移阶段，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。 ZGC为什么快？CMS GC和G1 GC性能瓶颈在哪了解，首先先说CMS GC和G1 GC性能瓶颈，我们知道CMS GC新生代的Young GC和C1 GC、ZGC都是基于标记复制算法，只是实现有很大不同，我们以G1为例，在混合回收的时候会有4个STW，其中初始标记阶段，初始标记因为只标记GC Roots，耗时较短；再标记因为是增量更新对象数少，耗时也较短；清理阶段，清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制，因为内存分区数量少，耗时也较短；复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。G1的Young GC和CMS的Young GC，其标记-复制全过程STW，就不再阐述。 全并发的ZGC：ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。ZGC只有三个STW阶段，初始标记，再标记，初始转移。其中初始标记和初始转移只需要扫描所有GC Roots处理时间都非常短，最多1ms，超过1ms则再次进入并发标记阶段。ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。 你们线上用的什么垃圾收集器？为什么要用它？我们生产环境中采用了设计比较优秀的 G1 垃圾收集器，因为它不仅能满足低停顿的要求，而且解决了 CMS 的浮动垃圾问题、内存碎片问题。G1 非常适合大内存、多核处理器的环境。 执行引擎知道JIT吗？他有什么用（待补充）JVM调优有做过 JVM 调优吗？怎么做的（待定）在没有全面监控收集到性能数据前都不适合动JVM，JVM 调优是一个非常复杂的过程，最多就是调调栈、堆的大小，比例关系，但是我任然认为在没有完整的性能数据前都不需要动jvm。我在项目里一般都是先优化自己写的代码，但是我学习了一些jvm调优的思路：","tags":[null,null],"categories":[null]}]
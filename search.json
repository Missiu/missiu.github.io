[{"path":"/云上温室接口.html","content":"基础请求登录云上温室系统（弃用） 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;login 请求参数：无 响应： 1234567891011121314151617&#123; &quot;requestId&quot;: &quot;b15220b8-d13d-44bf-a2e0-4a1a1e81f75b&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;customerId&quot;: 1722487870, &quot;username&quot;: &quot;ybgxqnyyq&quot;, &quot;userId&quot;: 1252, &quot;authorities&quot;: [], &quot;token&quot;: &quot;eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIxMjUyIiwiY3VzdG9tZXJJZCI6IjE3MjI0ODc4NzAiLCJ1c2VybmFtZSI6InliZ3hxbnl5cSIsInJvbGVzIjoiUFJPSkVDVF9BRE1JTiIsImF1dGhvcml0aWVzIjoiIiwiZXhwIjoxNzI0NzQyNjUxfQ.wklW7Ui8f0xzhFLh_f71YmsZ2avUZovL6djfZTIUHzLAvlg6ttYylbQRTb0M47NTkVKaFXgUJ-fH2c4rqRP-Uw&quot;, &quot;tokenType&quot;: &quot;Bearer&quot;, &quot;roles&quot;: &quot;PROJECT_ADMIN&quot;, &quot;expert&quot;: &quot;&quot; &#125;, &quot;timestamp&quot;: 1724137850984, &quot;success&quot;: true, &quot;errorDetail&quot;: &quot;null&quot;&#125; 登录云上温室系统(需要账号)（弃用） 请求类型：POST 请求地址：&#x2F;cloudGreenhouses&#x2F;userLogin 请求参数： &#123;\t&quot;username&quot;:&quot;&quot;,\t&quot;password&quot;:&quot;&quot;&#125; 响应： 1234567891011121314151617&#123; &quot;requestId&quot;: &quot;b15220b8-d13d-44bf-a2e0-4a1a1e81f75b&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;customerId&quot;: 1722487870, &quot;username&quot;: &quot;ybgxqnyyq&quot;, &quot;userId&quot;: 1252, &quot;authorities&quot;: [], &quot;token&quot;: &quot;eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIxMjUyIiwiY3VzdG9tZXJJZCI6IjE3MjI0ODc4NzAiLCJ1c2VybmFtZSI6InliZ3hxbnl5cSIsInJvbGVzIjoiUFJPSkVDVF9BRE1JTiIsImF1dGhvcml0aWVzIjoiIiwiZXhwIjoxNzI0NzQyNjUxfQ.wklW7Ui8f0xzhFLh_f71YmsZ2avUZovL6djfZTIUHzLAvlg6ttYylbQRTb0M47NTkVKaFXgUJ-fH2c4rqRP-Uw&quot;, &quot;tokenType&quot;: &quot;Bearer&quot;, &quot;roles&quot;: &quot;PROJECT_ADMIN&quot;, &quot;expert&quot;: &quot;&quot; &#125;, &quot;timestamp&quot;: 1724137850984, &quot;success&quot;: true, &quot;errorDetail&quot;: &quot;null&quot;&#125; 查询所有大棚信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;station 请求参数：无 响应： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&#123; &quot;requestId&quot;: &quot;e5d3a5f8-152b-429b-9111-bffd88801b7f&quot;, &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;id&quot;: 8865, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;customerId&quot;: 1722487870, &quot;name&quot;: &quot;测试基地&quot;, &quot;parentId&quot;: 0, &quot;images&quot;: [], &quot;description&quot;: &quot;&quot;, &quot;deviceCount&quot;: 0, &quot;displayName&quot;: &quot;&quot;, &quot;sortOrder&quot;: 0, &quot;children&quot;: [ &#123; &quot;id&quot;: 8866, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-01 18:26:08&quot;, &quot;customerId&quot;: 1722487870, &quot;name&quot;: &quot;温室#1&quot;, &quot;parentId&quot;: 8865, &quot;images&quot;: [], &quot;description&quot;: &quot;温室#1 描述信息&quot;, &quot;deviceCount&quot;: 1, &quot;displayName&quot;: &quot;&quot;, &quot;sortOrder&quot;: 1, &quot;children&quot;: [], &quot;area&quot;: &quot;&quot;, &quot;kind&quot;: &quot;&quot;, &quot;growthCycle&quot;: &quot;&quot;, &quot;statistic&quot;: &quot;&quot;, &quot;suffixTitle&quot;: &quot;&quot;, &quot;x&quot;: &quot;&quot;, &quot;y&quot;: &quot;&quot;, &quot;plantQuantity&quot;: &quot;&quot;, &quot;cycleInterval&quot;: 3, &quot;regionPic&quot;: &quot;&quot;, &quot;projectTitle&quot;: &quot;&quot;, &quot;projectDescription&quot;: &quot;&quot;, &quot;showLogo&quot;: 1, &quot;logo&quot;: &quot;&quot;, &quot;fontColor&quot;: &quot;&quot;, &quot;bold&quot;: 0, &quot;italic&quot;: 0, &quot;shadow&quot;: 0, &quot;shadowColor&quot;: &quot;&quot;, &quot;devices&quot;: &quot;[&#123;\\&quot;id\\&quot;:54811,\\&quot;deviceTypeId\\&quot;:54811,\\&quot;name\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;sortOrder\\&quot;:1&#125;,&#123;\\&quot;id\\&quot;:54814,\\&quot;deviceTypeId\\&quot;:54814,\\&quot;name\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:5&#125;,&#123;\\&quot;id\\&quot;:54816,\\&quot;deviceTypeId\\&quot;:54816,\\&quot;name\\&quot;:\\&quot;东侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#补光灯升降\\&quot;,\\&quot;sortOrder\\&quot;:7&#125;,&#123;\\&quot;id\\&quot;:54817,\\&quot;deviceTypeId\\&quot;:54817,\\&quot;name\\&quot;:\\&quot;南侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;2#补光灯升降\\&quot;,\\&quot;sortOrder\\&quot;:8&#125;,&#123;\\&quot;id\\&quot;:54818,\\&quot;deviceTypeId\\&quot;:54818,\\&quot;name\\&quot;:\\&quot;西侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;3#补光灯升降\\&quot;,\\&quot;sortOrder\\&quot;:9&#125;,&#123;\\&quot;id\\&quot;:54820,\\&quot;deviceTypeId\\&quot;:54820,\\&quot;name\\&quot;:\\&quot;北侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;4#补光灯升降\\&quot;,\\&quot;sortOrder\\&quot;:10&#125;,&#123;\\&quot;id\\&quot;:54819,\\&quot;deviceTypeId\\&quot;:54819,\\&quot;name\\&quot;:\\&quot;内遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;内遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:11&#125;,&#123;\\&quot;id\\&quot;:54824,\\&quot;deviceTypeId\\&quot;:54824,\\&quot;name\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;sortOrder\\&quot;:16&#125;,&#123;\\&quot;id\\&quot;:54826,\\&quot;deviceTypeId\\&quot;:54826,\\&quot;name\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;alias\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;sortOrder\\&quot;:18&#125;,&#123;\\&quot;id\\&quot;:54828,\\&quot;deviceTypeId\\&quot;:54828,\\&quot;name\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;alias\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;sortOrder\\&quot;:20&#125;,&#123;\\&quot;id\\&quot;:54829,\\&quot;deviceTypeId\\&quot;:54829,\\&quot;name\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;alias\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;sortOrder\\&quot;:21&#125;,&#123;\\&quot;id\\&quot;:54835,\\&quot;deviceTypeId\\&quot;:54835,\\&quot;name\\&quot;:\\&quot;热风机\\&quot;,\\&quot;alias\\&quot;:\\&quot;热风机\\&quot;,\\&quot;sortOrder\\&quot;:27&#125;,&#123;\\&quot;id\\&quot;:54841,\\&quot;deviceTypeId\\&quot;:54841,\\&quot;name\\&quot;:\\&quot;1#灌溉计划\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#灌溉计划\\&quot;,\\&quot;sortOrder\\&quot;:34&#125;]&quot;, &quot;setValue&quot;: &quot;96237,96243,96236,96247,96248,96246,96250,96249,96253,96255,96265,96282,96259,96257,96267&quot;, &quot;stationType&quot;: &quot;1&quot;, &quot;leadTitle&quot;: &quot;&quot;, &quot;showLead&quot;: 1, &quot;leadTitle1&quot;: &quot;&quot; &#125;, ... &#123; &quot;id&quot;: 8868, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-12 18:22:45&quot;, &quot;customerId&quot;: 1722487870, &quot;name&quot;: &quot;温室#3&quot;, &quot;parentId&quot;: 8865, &quot;images&quot;: [], &quot;description&quot;: &quot;温室#3 描述信息&quot;, &quot;deviceCount&quot;: 1, &quot;displayName&quot;: &quot;&quot;, &quot;sortOrder&quot;: 3, &quot;children&quot;: [], &quot;area&quot;: &quot;&quot;, &quot;kind&quot;: &quot;&quot;, &quot;growthCycle&quot;: &quot;&quot;, &quot;statistic&quot;: &quot;&quot;, &quot;suffixTitle&quot;: &quot;&quot;, &quot;x&quot;: &quot;&quot;, &quot;y&quot;: &quot;&quot;, &quot;plantQuantity&quot;: &quot;&quot;, &quot;cycleInterval&quot;: 3, &quot;regionPic&quot;: &quot;&quot;, &quot;projectTitle&quot;: &quot;&quot;, &quot;projectDescription&quot;: &quot;&quot;, &quot;showLogo&quot;: 1, &quot;logo&quot;: &quot;&quot;, &quot;fontColor&quot;: &quot;&quot;, &quot;bold&quot;: 0, &quot;italic&quot;: 0, &quot;shadow&quot;: 0, &quot;shadowColor&quot;: &quot;&quot;, &quot;devices&quot;: &quot;[&#123;\\&quot;id\\&quot;:54935,\\&quot;deviceTypeId\\&quot;:54935,\\&quot;name\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;sortOrder\\&quot;:1&#125;,&#123;\\&quot;id\\&quot;:54939,\\&quot;deviceTypeId\\&quot;:54939,\\&quot;name\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:5&#125;,&#123;\\&quot;id\\&quot;:54940,\\&quot;deviceTypeId\\&quot;:54940,\\&quot;name\\&quot;:\\&quot;东侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;C区内遮阳\\&quot;,\\&quot;sortOrder\\&quot;:7&#125;,&#123;\\&quot;id\\&quot;:54941,\\&quot;deviceTypeId\\&quot;:54941,\\&quot;name\\&quot;:\\&quot;南侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;E区内遮阳\\&quot;,\\&quot;sortOrder\\&quot;:8&#125;,&#123;\\&quot;id\\&quot;:54944,\\&quot;deviceTypeId\\&quot;:54944,\\&quot;name\\&quot;:\\&quot;内遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;D区内遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:11&#125;,&#123;\\&quot;id\\&quot;:54948,\\&quot;deviceTypeId\\&quot;:54948,\\&quot;name\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;sortOrder\\&quot;:16&#125;,&#123;\\&quot;id\\&quot;:54950,\\&quot;deviceTypeId\\&quot;:54950,\\&quot;name\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;alias\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;sortOrder\\&quot;:18&#125;,&#123;\\&quot;id\\&quot;:54952,\\&quot;deviceTypeId\\&quot;:54952,\\&quot;name\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;alias\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;sortOrder\\&quot;:20&#125;,&#123;\\&quot;id\\&quot;:54953,\\&quot;deviceTypeId\\&quot;:54953,\\&quot;name\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;alias\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;sortOrder\\&quot;:21&#125;,&#123;\\&quot;id\\&quot;:54955,\\&quot;deviceTypeId\\&quot;:54955,\\&quot;name\\&quot;:\\&quot;高压雾降温\\&quot;,\\&quot;alias\\&quot;:\\&quot;高压雾降温\\&quot;,\\&quot;sortOrder\\&quot;:23&#125;,&#123;\\&quot;id\\&quot;:54959,\\&quot;deviceTypeId\\&quot;:54959,\\&quot;name\\&quot;:\\&quot;热风机\\&quot;,\\&quot;alias\\&quot;:\\&quot;热风机\\&quot;,\\&quot;sortOrder\\&quot;:27&#125;,&#123;\\&quot;id\\&quot;:54964,\\&quot;deviceTypeId\\&quot;:54964,\\&quot;name\\&quot;:\\&quot;1#空调\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#空调\\&quot;,\\&quot;sortOrder\\&quot;:32&#125;]&quot;, &quot;setValue&quot;: &quot;96342,96344,96359,96347,96364,96357,96362,96370,96391,96352,96354,96371&quot;, &quot;stationType&quot;: &quot;1&quot;, &quot;leadTitle&quot;: &quot;&quot;, &quot;showLead&quot;: 1, &quot;leadTitle1&quot;: &quot;&quot; &#125; ], &quot;area&quot;: &quot;&quot;, &quot;kind&quot;: &quot;&quot;, &quot;growthCycle&quot;: &quot;&quot;, &quot;statistic&quot;: &quot;&quot;, &quot;suffixTitle&quot;: &quot;&quot;, &quot;x&quot;: &quot;&quot;, &quot;y&quot;: &quot;&quot;, &quot;plantQuantity&quot;: &quot;&quot;, &quot;cycleInterval&quot;: 3, &quot;regionPic&quot;: &quot;&quot;, &quot;projectTitle&quot;: &quot;&quot;, &quot;projectDescription&quot;: &quot;&quot;, &quot;showLogo&quot;: 1, &quot;logo&quot;: &quot;&quot;, &quot;fontColor&quot;: &quot;&quot;, &quot;bold&quot;: 0, &quot;italic&quot;: 0, &quot;shadow&quot;: 0, &quot;shadowColor&quot;: &quot;&quot;, &quot;devices&quot;: &quot;&quot;, &quot;setValue&quot;: &quot;&quot;, &quot;stationType&quot;: &quot;&quot;, &quot;leadTitle&quot;: &quot;&quot;, &quot;showLead&quot;: 1, &quot;leadTitle1&quot;: &quot;&quot; &#125; ], &quot;timestamp&quot;: 1724138025034, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 通过站点id查询大棚信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getStationById?id&#x3D;8868 请求参数：String id 响应： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;requestId&quot;: &quot;8c46356e-de11-4960-92b9-c2a41288e1b5&quot;, &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;id&quot;: 8868, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-12 18:22:45&quot;, &quot;customerId&quot;: 1722487870, &quot;name&quot;: &quot;温室#3&quot;, &quot;parentId&quot;: 8865, &quot;images&quot;: [], &quot;description&quot;: &quot;温室#3 描述信息&quot;, &quot;deviceCount&quot;: 1, &quot;displayName&quot;: &quot;&quot;, &quot;sortOrder&quot;: 3, &quot;children&quot;: [], &quot;area&quot;: &quot;&quot;, &quot;kind&quot;: &quot;&quot;, &quot;growthCycle&quot;: &quot;&quot;, &quot;statistic&quot;: &quot;&quot;, &quot;suffixTitle&quot;: &quot;&quot;, &quot;x&quot;: &quot;&quot;, &quot;y&quot;: &quot;&quot;, &quot;plantQuantity&quot;: &quot;&quot;, &quot;cycleInterval&quot;: 3, &quot;regionPic&quot;: &quot;&quot;, &quot;projectTitle&quot;: &quot;&quot;, &quot;projectDescription&quot;: &quot;&quot;, &quot;showLogo&quot;: 1, &quot;logo&quot;: &quot;&quot;, &quot;fontColor&quot;: &quot;&quot;, &quot;bold&quot;: 0, &quot;italic&quot;: 0, &quot;shadow&quot;: 0, &quot;shadowColor&quot;: &quot;&quot;, &quot;devices&quot;: &quot;[&#123;\\&quot;id\\&quot;:54935,\\&quot;deviceTypeId\\&quot;:54935,\\&quot;name\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;sortOrder\\&quot;:1&#125;,&#123;\\&quot;id\\&quot;:54939,\\&quot;deviceTypeId\\&quot;:54939,\\&quot;name\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:5&#125;,&#123;\\&quot;id\\&quot;:54940,\\&quot;deviceTypeId\\&quot;:54940,\\&quot;name\\&quot;:\\&quot;东侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;C区内遮阳\\&quot;,\\&quot;sortOrder\\&quot;:7&#125;,&#123;\\&quot;id\\&quot;:54941,\\&quot;deviceTypeId\\&quot;:54941,\\&quot;name\\&quot;:\\&quot;南侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;E区内遮阳\\&quot;,\\&quot;sortOrder\\&quot;:8&#125;,&#123;\\&quot;id\\&quot;:54944,\\&quot;deviceTypeId\\&quot;:54944,\\&quot;name\\&quot;:\\&quot;内遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;D区内遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:11&#125;,&#123;\\&quot;id\\&quot;:54948,\\&quot;deviceTypeId\\&quot;:54948,\\&quot;name\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;sortOrder\\&quot;:16&#125;,&#123;\\&quot;id\\&quot;:54950,\\&quot;deviceTypeId\\&quot;:54950,\\&quot;name\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;alias\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;sortOrder\\&quot;:18&#125;,&#123;\\&quot;id\\&quot;:54952,\\&quot;deviceTypeId\\&quot;:54952,\\&quot;name\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;alias\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;sortOrder\\&quot;:20&#125;,&#123;\\&quot;id\\&quot;:54953,\\&quot;deviceTypeId\\&quot;:54953,\\&quot;name\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;alias\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;sortOrder\\&quot;:21&#125;,&#123;\\&quot;id\\&quot;:54955,\\&quot;deviceTypeId\\&quot;:54955,\\&quot;name\\&quot;:\\&quot;高压雾降温\\&quot;,\\&quot;alias\\&quot;:\\&quot;高压雾降温\\&quot;,\\&quot;sortOrder\\&quot;:23&#125;,&#123;\\&quot;id\\&quot;:54959,\\&quot;deviceTypeId\\&quot;:54959,\\&quot;name\\&quot;:\\&quot;热风机\\&quot;,\\&quot;alias\\&quot;:\\&quot;热风机\\&quot;,\\&quot;sortOrder\\&quot;:27&#125;,&#123;\\&quot;id\\&quot;:54964,\\&quot;deviceTypeId\\&quot;:54964,\\&quot;name\\&quot;:\\&quot;1#空调\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#空调\\&quot;,\\&quot;sortOrder\\&quot;:32&#125;]&quot;, &quot;setValue&quot;: &quot;96342,96344,96359,96347,96364,96357,96362,96370,96391,96352,96354,96371&quot;, &quot;stationType&quot;: &quot;1&quot;, &quot;leadTitle&quot;: &quot;&quot;, &quot;showLead&quot;: 1, &quot;leadTitle1&quot;: &quot;&quot; &#125; ], &quot;timestamp&quot;: 1724138067686, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 通过站点id设备类型和查询设备信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getDeviceByStationIdAndDataType?stationId&#x3D;8870&amp;dataType&#x3D;STREAM 请求参数： String stationId String dataType：是设备类型而且是字典值，其中STREAM表示摄像机，CTL或者TEXT表示控制器 响应： 1234567891011121314151617181920212223242526&#123; &quot;requestId&quot;: &quot;cda4a403-6bc2-4981-ad75-77a50ce30946&quot;, &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;id&quot;: 15332, &quot;customerId&quot;: 1722487870, &quot;sortOrder&quot;: 3, &quot;code&quot;: &quot;2024010215280076&quot;, &quot;name&quot;: &quot;控制器#3&quot;, &quot;deviceTypeId&quot;: &quot;C001&quot;, &quot;deviceTypeName&quot;: &quot;日光温室控制器&quot;, &quot;stationId&quot;: 8868, &quot;stationName&quot;: &quot;温室#3&quot;, &quot;deviceBrand&quot;: &quot;&quot;, &quot;hls&quot;: &quot;&quot;, &quot;tag&quot;: &quot;0010202407270005&quot;, &quot;number&quot;: 0, &quot;channel&quot;: 1, &quot;prefix&quot;: &quot;&quot; &#125; ], &quot;timestamp&quot;: 1724225228081, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 仅通过站点id查询设备信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getDeviceByStationIdAndDataType?stationId&#x3D;8870 请求参数： String stationId 响应： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;requestId&quot;: &quot;51bfdfa3-af3b-4d46-a033-fc167e877349&quot;, &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;id&quot;: 15335, &quot;customerId&quot;: 1722487870, &quot;sortOrder&quot;: 5, &quot;code&quot;: &quot;camera-ybgxqnyyq-5&quot;, &quot;name&quot;: &quot;摄像机#5&quot;, &quot;deviceTypeId&quot;: &quot;V001&quot;, &quot;deviceTypeName&quot;: &quot;网络摄像机(海康)&quot;, &quot;stationId&quot;: 8870, &quot;stationName&quot;: &quot;温室#5&quot;, &quot;deviceBrand&quot;: &quot;&quot;, &quot;hls&quot;: &quot;&quot;, &quot;tag&quot;: &quot;&quot;, &quot;number&quot;: 0, &quot;channel&quot;: 1, &quot;prefix&quot;: &quot;&quot; &#125;, &#123; &quot;id&quot;: 15336, &quot;customerId&quot;: 1722487870, &quot;sortOrder&quot;: 5, &quot;code&quot;: &quot;0010202407270005&quot;, &quot;name&quot;: &quot;气象站&quot;, &quot;deviceTypeId&quot;: &quot;W001&quot;, &quot;deviceTypeName&quot;: &quot;数据采集器&quot;, &quot;stationId&quot;: 8870, &quot;stationName&quot;: &quot;气象站&quot;, &quot;deviceBrand&quot;: &quot;&quot;, &quot;hls&quot;: &quot;&quot;, &quot;tag&quot;: &quot;2024010215280090,2024010215280091&quot;, &quot;number&quot;: 0, &quot;channel&quot;: 1, &quot;prefix&quot;: &quot;&quot; &#125; ], &quot;timestamp&quot;: 1724225835463, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 监控相关请求根据站点id和设备id监控视频列表 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getVideoList?stationId&#x3D;8868&amp;deviceId&#x3D;15331 请求参数： String stationId String deviceId：在查询的设备信息中可以找到，主要包含该设备记录的监控视频列表 响应： 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;requestId&quot;: &quot;de7642e2-2b98-4980-9e3d-a3645ee33b82&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;data&quot;: [ [ &#123; &quot;id&quot;: 6930, &quot;customerId&quot;: 1722487870, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-01 19:00:25&quot;, &quot;deviceId&quot;: 15331, &quot;deviceCode&quot;: &quot;9L0D98FPHA16795&quot;, &quot;deviceName&quot;: &quot;摄像机#3&quot;, &quot;deviceTypeId&quot;: &quot;V006&quot;, &quot;deviceTypeName&quot;: &quot;网络摄像机(海康)&quot;, &quot;stationId&quot;: 8868, &quot;stationName&quot;: &quot;温室#3&quot;, &quot;sortOrder&quot;: 1, &quot;name&quot;: &quot;&quot;, &quot;channel&quot;: 0, &quot;rtmpUrl&quot;: &quot;&quot;, &quot;hlsUrl&quot;: &quot;http://cmgw-vpc.lechange.com:8888/LCO/9L0D98FPHA16795/0/1/20240801T071757/72b4abc424b4cfa599170b8ffa88c01d.m3u8&quot;, &quot;hasPtz&quot;: true, &quot;poster&quot;: &quot;http://iot-pictures.oss-cn-beijing.aliyuncs.com/202408/9L0D98FPHA16795/e8f5c840b0f9cafcfcc818d3cb1afdc0.jpg?Expires=1724207025&amp;OSSAccessKeyId=LTAI4G6tKEtDrgfKK3hrvFoe&amp;Signature=79wm5zvDTYTAbEe7Pxj912tt4nU%3D&quot;, &quot;description&quot;: &quot;&quot;, &quot;primary&quot;: true, &quot;online&quot;: true &#125; ] ], &quot;pageNumber&quot;: 1, &quot;pageSize&quot;: 20, &quot;totalCount&quot;: 1 &#125;, &quot;timestamp&quot;: 1724138667432, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 仅通过站点id查监控视频列表 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getMonitorByStationId?stationId&#x3D;8865 请求参数： String stationId 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;requestId&quot;: &quot;47318cee-b940-4f75-8c4e-d28a1e9a0115&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;data&quot;: [ [ &#123; &quot;id&quot;: 6930, &quot;customerId&quot;: 1722487870, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-01 19:00:25&quot;, &quot;deviceId&quot;: 15331, &quot;deviceCode&quot;: &quot;9L0D98FPHA16795&quot;, &quot;deviceName&quot;: &quot;摄像机#3&quot;, &quot;deviceTypeId&quot;: &quot;V006&quot;, &quot;deviceTypeName&quot;: &quot;网络摄像机(海康)&quot;, &quot;stationId&quot;: 8868, &quot;stationName&quot;: &quot;温室#3&quot;, &quot;sortOrder&quot;: 1, &quot;name&quot;: &quot;&quot;, &quot;channel&quot;: 0, &quot;rtmpUrl&quot;: &quot;&quot;, &quot;hlsUrl&quot;: &quot;http://cmgw-vpc.lechange.com:8888/LCO/9L0D98FPHA16795/0/1/20240801T071757/72b4abc424b4cfa599170b8ffa88c01d.m3u8&quot;, &quot;hasPtz&quot;: true, &quot;poster&quot;: &quot;http://iot-pictures.oss-cn-beijing.aliyuncs.com/202408/9L0D98FPHA16795/e8f5c840b0f9cafcfcc818d3cb1afdc0.jpg?Expires=1724297190&amp;OSSAccessKeyId=LTAI4G6tKEtDrgfKK3hrvFoe&amp;Signature=q4sf09V%2BNQoj6gkHFlsUIr%2FB3rM%3D&quot;, &quot;description&quot;: &quot;&quot;, &quot;primary&quot;: true, &quot;online&quot;: true &#125; ] ], &quot;pageNumber&quot;: 1, &quot;pageSize&quot;: 20, &quot;totalCount&quot;: 1 &#125;, &quot;timestamp&quot;: 1724226228816, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 获取kit_token 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getKitToke?deviceCode&#x3D;9L0D98FPHA16795&amp;channelId&#x3D;0&amp;kitType&#x3D;0 请求参数： String deviceCode：在查询出的监控视频列表里有 String channelId：&#x2F;&#x2F; todo 暂未发现 String kitType：&#x2F;&#x2F; todo 暂未发现 响应： 12345678&#123; &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;kit_token&quot;: &quot;Kt_hzb416177422044de980f9f8357b619f&quot;, &quot;token&quot;: &quot;At_0000hz288c970032294eb6b0f979e53e&quot; &#125;, &quot;message&quot;: &quot;SuccessCode&quot;&#125; 获取监控视频流地址这个请求可以不带请求头！带了也没关系 请求类型：POST 请求地址：&#x2F;cloudGreenhouses&#x2F;getEncryptKitStreamUrl 请求参数： String id ：&#x2F;&#x2F; todo 暂未发现 ParamsDTO params String kitToken；在kit_token里 String deviceId; 在查询出的监控视频列表里有 String channelId; &#x2F;&#x2F; todo 暂未发现，但是应该和kit_token的channelId对应 String beginTime; String endTime; String businessType; &#x2F;&#x2F; todo 暂未发现 String streamId; &#x2F;&#x2F; todo 暂未发现 请求体： 123456789101112&#123;\t&quot;id&quot;:&quot;SJLS0N8JER2EDX7HR6AJZE7A9HED0TNP&quot;,\t&quot;params&quot;:&#123; &quot;beginTime&quot;:&quot;2024-08-20 00:00:00&quot;, &quot;businessType&quot;:&quot;real&quot;, &quot;channelId&quot;:&quot;0&quot;, &quot;deviceId&quot;:&quot;9L0D98FPHA16795&quot;, &quot;endTime&quot;:&quot;2024-08-20 23:59:59&quot;, &quot;kitToken&quot;:&quot;Kt_hzb416177422044de980f9f8357b619f&quot;, &quot;streamId&quot;:&quot;0&quot;\t&#125;&#125; 响应： &#123;&quot;result&quot;:&#123;&quot;msg&quot;:&quot;设备离线。&quot;,&quot;code&quot;:&quot;DV1007&quot;&#125;,&quot;id&quot;:&quot;SJLS0N8JER2EDX7HR6AJZE7A9HED0TNP&quot;&#125; 天气数据相关请求获取气象站传感器当前数据 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getSensorData?deviceCode&#x3D;2024010215280076 请求参数：String deviceCode; 对应通过站点id查询设备信息里的tag中的数据 响应： 1234567891011121314151617181920212223242526272829303132333435&#123; &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;name&quot;: &quot;空气温度&quot;, &quot;order&quot;: 0, &quot;isBreakdown&quot;: &quot;0&quot;, &quot;isTarget&quot;: &quot;0&quot;, &quot;isValid&quot;: &quot;1&quot;, &quot;isWeatherStation&quot;: &quot;1&quot;, &quot;originValue&quot;: 773, &quot;value&quot;: 37.3, &quot;unit&quot;: &quot;℃&quot;, &quot;factor&quot;: &quot;atc&quot;, &quot;dateTime&quot;: &quot;2024-08-20 17:01:42&quot;, &quot;sensorType&quot;: &quot;1&quot; &#125;,\t... &#123; &quot;name&quot;: &quot;土壤湿度&quot;, &quot;order&quot;: 0, &quot;isBreakdown&quot;: &quot;0&quot;, &quot;isTarget&quot;: &quot;0&quot;, &quot;isValid&quot;: &quot;1&quot;, &quot;isWeatherStation&quot;: &quot;0&quot;, &quot;originValue&quot;: 0, &quot;value&quot;: 0, &quot;unit&quot;: &quot;%&quot;, &quot;factor&quot;: &quot;swc&quot;, &quot;dateTime&quot;: &quot;2024-08-20 17:01:42&quot;, &quot;sensorType&quot;: &quot;7&quot; &#125; ], &quot;message&quot;: &quot;SuccessCode&quot;&#125; 字段名 类型 描述 name String 传感器类型名称 order String 传感器类型序号 isBreakdown String 是否故障 isTarget String 是否是⽬标值 isValid String 是否有效 isWeatherStation String 是否是⽓象站 originValue String 原始值 value String 转换后数值 unit String 单位 factor String 传感器类型英⽂缩写 dateTime String 时间 获取气象站传感器时间段的数据 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getSensorDataAvg?deviceId&#x3D;15332&amp;groupType&#x3D;HOUR&amp;startTimestamp&#x3D;1724083200000&amp;endTimestamp&#x3D;1724169599000&amp;fields&#x3D;atc,ahc,light,co2,stc,swc 请求参数： String deviceId, 对应站点id查询设备信息里的id String groupType, 分组类型，HOUR&#x2F;DAY&#x2F;MONTH String startTimestamp, 开始时间戳(默认当天0点 String endTimestamp, 结束时间戳(默认当前时间戳 String fields; 数据类型(从getSensorData接⼝中获取)atc,ahc,light,co2,stc,swc 响应： 12345678910111213141516171819202122232425262728&#123; &quot;requestId&quot;: &quot;c548298e-f723-4d72-add0-0dc65dbda77b&quot;, &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;airTemperature&quot;: 28.6, &quot;soilTemperature&quot;: 28, &quot;brightness&quot;: 0, &quot;carbonDioxide&quot;: 457.5, &quot;airHumidity&quot;: 72.7, &quot;soilHumidity&quot;: 0, &quot;createDate&quot;: &quot;00&quot; &#125;,\t... &#123; &quot;airTemperature&quot;: 37.9, &quot;soilTemperature&quot;: 37.5, &quot;brightness&quot;: 1, &quot;carbonDioxide&quot;: 428.4, &quot;airHumidity&quot;: 41.9, &quot;soilHumidity&quot;: 0, &quot;createDate&quot;: &quot;17&quot; &#125; ], &quot;timestamp&quot;: 1724146892409, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 获取气象站传感器历史数据 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getSensorHistoryData?deviceId&#x3D;15332&amp;stationId&#x3D;8868&amp;startTimestamp&#x3D;1724083200000&amp;endTimestamp&#x3D;1724169599000 请求参数： String deviceId, 对应站点id查询设备信息里的id String stationId, String startTimestamp, 开始时间戳(默认当天0点 String endTimestamp, 结束时间戳(默认当前时间戳 响应： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&#123; &quot;requestId&quot;: &quot;1c29e09c-7bed-4a6d-9ecf-662ee0a05ec7&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;data&quot;: [ &#123; &quot;data&quot;: [ &#123; &quot;name&quot;: &quot;stc&quot;, &quot;value&quot;: 32.6, &quot;displayName&quot;: &quot;土壤温度&quot;, &quot;unit&quot;: &quot;℃&quot;, &quot;icon&quot;: &quot;stc&quot;, &quot;alarm&quot;: false, &quot;number&quot;: &quot;0&quot; &#125;, ... &#123; &quot;name&quot;: &quot;swc&quot;, &quot;value&quot;: 9.8, &quot;displayName&quot;: &quot;土壤湿度&quot;, &quot;unit&quot;: &quot;%&quot;, &quot;icon&quot;: &quot;swc&quot;, &quot;alarm&quot;: false, &quot;number&quot;: &quot;0&quot; &#125; ], &quot;deviceTypeId&quot;: &quot;C001&quot;, &quot;deviceTypeName&quot;: &quot;日光温室控制器&quot;, &quot;deviceCode&quot;: &quot;2024010215280091&quot;, &quot;deviceId&quot;: &quot;15330&quot;, &quot;deviceName&quot;: &quot;B&quot;, &quot;customerId&quot;: &quot;1722487870&quot;, &quot;stationName&quot;: &quot;B&quot;, &quot;stationId&quot;: &quot;8867&quot;, &quot;createDate&quot;: &quot;2024-09-02 09:25:20&quot; &#125;, ... &#123; &quot;data&quot;: [ &#123; &quot;name&quot;: &quot;stc&quot;, &quot;value&quot;: 32.4, &quot;displayName&quot;: &quot;土壤温度&quot;, &quot;unit&quot;: &quot;℃&quot;, &quot;icon&quot;: &quot;stc&quot;, &quot;alarm&quot;: false, &quot;number&quot;: &quot;0&quot; &#125;, ... &#123; &quot;name&quot;: &quot;swc&quot;, &quot;value&quot;: 9.9, &quot;displayName&quot;: &quot;土壤湿度&quot;, &quot;unit&quot;: &quot;%&quot;, &quot;icon&quot;: &quot;swc&quot;, &quot;alarm&quot;: false, &quot;number&quot;: &quot;0&quot; &#125; ], &quot;deviceTypeId&quot;: &quot;C001&quot;, &quot;deviceTypeName&quot;: &quot;日光温室控制器&quot;, &quot;deviceCode&quot;: &quot;2024010215280091&quot;, &quot;deviceId&quot;: &quot;15330&quot;, &quot;deviceName&quot;: &quot;B&quot;, &quot;customerId&quot;: &quot;1722487870&quot;, &quot;stationName&quot;: &quot;B&quot;, &quot;stationId&quot;: &quot;8867&quot;, &quot;createDate&quot;: &quot;2024-09-02 06:51:59&quot; &#125; ], &quot;pageNumber&quot;: 1, &quot;pageSize&quot;: 30, &quot;totalCount&quot;: 107 &#125;, &quot;timestamp&quot;: 1725240381499, &quot;success&quot;: true&#125; 获取气象站平均数据 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getSensorDataTimeAvg?deviceId&#x3D;15332&amp;groupType&#x3D;HOUR&amp;startTimestamp&#x3D;1724083200000&amp;endTimestamp&#x3D;1724169599000&amp;fields&#x3D;atc,ahc,light,co2,stc,swc 请求参数： String deviceId, 对应站点id查询设备信息里的id String groupType, 分组类型，HOUR&#x2F;DAY&#x2F;MONTH String startTimestamp, 开始时间戳(默认当天0点 String endTimestamp, 结束时间戳(默认当前时间戳 String fields; 数据类型(从getSensorData接⼝中获取)atc,ahc,light,co2,stc,swc 相应： 12345678910111213141516&#123; &quot;requestId&quot;: &quot;3d412250-1d07-4409-acb4-ac13262ca09b&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;airTemperature&quot;: 32.1, &quot;soilTemperature&quot;: 31.7, &quot;brightness&quot;: 1.2, &quot;carbonDioxide&quot;: 444.5, &quot;airHumidity&quot;: 61.7, &quot;soilHumidity&quot;: 0, &quot;createDate&quot;: null &#125;, &quot;timestamp&quot;: 1724812023647, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 设备信息相关请求获取设备状态信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getDeviceStatus?deviceCode&#x3D;2022070314150044 请求参数： String deviceCode, 在查询出的设备信息里有 响应： 1234567891011121314151617181920212223242526272829&#123; &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;name&quot;: &quot;左向天窗&quot;, &quot;status&quot;: &quot;00000010&quot;, &quot;order&quot;: 0, &quot;position&quot;: &quot;0&quot;, &quot;deviceTypeNumber&quot;: 1, &quot;isBit&quot;: 1, &quot;suffix&quot;: &quot;&quot;, &quot;deviceType&quot;: &quot;自动&quot;, &quot;deviceStatus&quot;: &quot;关&quot; &#125;,\t... &#123; &quot;name&quot;: &quot;输出通道&quot;, &quot;status&quot;: &quot;00000001&quot;, &quot;order&quot;: 4, &quot;position&quot;: &quot;&quot;, &quot;deviceTypeNumber&quot;: 55, &quot;isBit&quot;: 1, &quot;suffix&quot;: &quot;&quot;, &quot;deviceType&quot;: &quot;自动&quot;, &quot;deviceStatus&quot;: &quot;开&quot; &#125; ], &quot;message&quot;: &quot;SuccessCode&quot;&#125; 原理讲解： 1bit有8位：00000000 bit0 ~ bit7：表示从高位到低位，也就是从右到左 为 bit0、bit2 … bit7 设备类型：开-关-停 三个状态、 开-关 二个状态 开-关-停：bit0 &#x3D; 1: 开、bit1 &#x3D; 1: 关（在 bit0 不为 1 的情况下）、bit0 和 bit1 均不为 1: 停 开-关： bit0 &#x3D; 1: 开、bit0 &#x3D; 0: 关 自动&#x2F;手动状态：bit2 &#x3D; 0 且 bit3 &#x3D; 0: 自动、其他情况: 手动 举例子： 00000100：bit0&#x3D;、bit1&#x3D;0，无论他是开关停类型还是开关类型都是停止或者关闭的；bit3&#x3D;1说明他是手动的 00000000：状态关、自动 00000001：状态开、自动 字段名 类型 描述 status String 如果status &#x3D; 00000100，如果设备为 ‘开关停’ 设备：先从bit0开始解析，如果 bit0 &#x3D; 1即为开，bit0 如果不等于0，那就看bit1，bit1 &#x3D; 1 即为关，如果bit1 不等于 1，状态即为 ‘停’；如果设备是 ‘开关型’ 设备，那么只关注bit0，bit0&#x3D;1为开，bit0&#x3D;0 为关; ⾃动⼿动判断： bit2 &#x3D;0 bit3&#x3D;0 即为⾃动状态，其他情况为⼿动状态 positon String ‘开关停’ 型的设备当前开合的位置 Order Int 序号 数据映射： 名称 字节类型 描述 左向天窗 位 00000110 ⼿动关闭 00000101 ⼿动打开 00000100 ⼿动静⽌ 00000000 ⾃动静⽌ 00000001 ⾃动开 00000010 ⾃动关 右向天窗 位 0000110 ⼿动关闭 00000101 ⼿动打开 00000100 ⼿动静⽌ 00000000 ⾃动静⽌ 00000001 ⾃动开 00000010 ⾃动关 补光灯 位 00000101⼿动开 00000100⼿动关 00000000 关 “开关停设备” 状态列表： 状态码 (二进制) bit0 bit1 bit2 bit3 设备状态 操作模式 0000 0 0 0 0 停 自动 0001 1 0 0 0 开 自动 0010 0 1 0 0 关 自动 0011 1 1 0 0 开 自动 0100 0 0 1 0 停 手动 0101 1 0 1 0 开 手动 0110 0 1 1 0 关 手动 0111 1 1 1 0 开 手动 1000 0 0 0 1 停 手动 1001 1 0 0 1 开 手动 1010 0 1 0 1 关 手动 1011 1 1 0 1 开 手动 1100 0 0 1 1 停 手动 1101 1 0 1 1 开 手动 1110 0 1 1 1 关 手动 1111 1 1 1 1 开 手动 “开关型设备” 状态列表： 状态码 (二进制) bit0 bit1 bit2 bit3 设备状态 操作模式 0000 0 0 0 0 关 自动 0001 1 0 0 0 开 自动 0010 0 1 0 0 关 自动 0011 1 1 0 0 开 自动 0100 0 0 1 0 关 手动 0101 1 0 1 0 开 手动 0110 0 1 1 0 关 手动 0111 1 1 1 0 开 手动 1000 0 0 0 1 关 手动 1001 1 0 0 1 开 手动 1010 0 1 0 1 关 手动 1011 1 1 0 1 开 手动 1100 0 0 1 1 关 手动 1101 1 0 1 1 开 手动 1110 0 1 1 1 关 手动 1111 1 1 1 1 开 手动 获取设备映射列表信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getDeviceMapInfo?customerId&#x3D;1722487870&amp;deviceId&#x3D;15332&amp;deviceType&#x3D;C001 请求参数： String customerId, 在用户登陆的时候有这个值 String deviceType, &#x2F;&#x2F; todo 设备类型，我没有在他的接口文档里找到对应的映射 String deviceId, 在查询的设备信息中可以找到 响应： 12345678910111213141516171819202122232425&#123; &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;id&quot;: 54935, &quot;name&quot;: &quot;左向天窗&quot;, &quot;alias&quot;: &quot;左向天窗&quot;, &quot;order&quot;: 1, &quot;deviceType&quot;: &quot;C001&quot;, &quot;deviceId&quot;: 15332, &quot;customerId&quot;: 1722487870\t&#125;,\t... &#123; &quot;id&quot;: 54979, &quot;name&quot;: &quot;全自动紫外线消毒机&quot;, &quot;alias&quot;: &quot;全自动紫外线消毒机&quot;, &quot;order&quot;: 47, &quot;deviceType&quot;: &quot;C001&quot;, &quot;deviceId&quot;: 15332, &quot;customerId&quot;: 1722487870 &#125; ], &quot;message&quot;: &quot;SuccessCode&quot;&#125; 获取施肥机运行状态 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getFertilizerStatus?deviceCode&#x3D;2024041011580004 请求参数： String deviceCode, 在查询出的设备信息里有 响应： 123456789101112131415161718192021222324252627&#123; &quot;requestId&quot;: &quot;2262ee08-671e-4033-a92b-4dd2b8831435&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;deviceName&quot;: &quot;施肥机&quot;, &quot;deviceCode&quot;: &quot;2024041011580004&quot;, &quot;online&quot;: false, &quot;statuses&quot;: [ &#123; &quot;name&quot;: &quot;手机强制手动&quot;, &quot;status&quot;: false, &quot;type&quot;: &quot;switch&quot;, &quot;channel&quot;: 1 &#125;, ... &#123; &quot;name&quot;: &quot;北侧遮阳收拢&quot;, &quot;status&quot;: false, &quot;type&quot;: &quot;switch&quot;, &quot;channel&quot;: 48 &#125; ] &#125;, &quot;timestamp&quot;: 1724225191317, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 过程整理 点击大棚请求数据（这个渲染哪些大棚）-&gt;确定大棚得到大棚id值查询 大棚基础数据 设备信息 监控视频列表 监控部分：获取kit_token-&gt;获取监控视频流地址（缺少参数 &#x2F;&#x2F; todo） 天气数据：获取时间段数据–平均数据–当前数据（参数问题 ） 设备信息：整个设备部分存在问题 对应： 大棚列表： 视频实时监控 监控视频 气象站当前数据 气象站平均数据 气象站时间段数据 气象站历史数据 设备信息"},{"title":"(九). 登堂入室 - JDK8","path":"/javaSE-JDK8.html","content":"JDK8新特性方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。 方法引用使用一对冒号 :: 。 下面，我们在 Car 类中定义了 4 个方法作为例子来区分 Java 中 4 种不同方法的引用。 1234567891011121314151617public static class Car &#123; public static Car create( final Supplier&lt; Car &gt; supplier ) &#123; return supplier.get(); &#125; public static void collide( final Car car ) &#123; System.out.println( &quot;Collided &quot; + car.toString() ); &#125; public void follow( final Car another ) &#123; System.out.println( &quot;Following the &quot; + another.toString() ); &#125; public void repair() &#123; System.out.println( &quot;Repaired &quot; + this.toString() ); &#125;&#125; 第一种方法引用的类型是构造器引用，语法是Class::new，或者更一般的形式： Class&lt;T&gt;::new 。注意：这个构造器没有参数。 final Car car = Car.create( Car::new );final List&lt; Car &gt; cars = Arrays.asList( car ); 第二种方法引用的类型是静态方法引用，语法是Class::static_method。注意：这个方法接受一个Car类型的参数。 cars.forEach( Car::collide ); 第三种方法引用的类型是某个类的成员方法的引用，语法是Class::method，注意，这个方法没有定义入参： cars.forEach( Car::repair ); 第四种方法引用的类型是某个实例对象的成员方法的引用，语法是instance::method。注意：这个方法接受一个Car类型的参数： final Car police = Car.create( Car::new );cars.forEach( police::follow ); Lambda表达式函数式编程思想概述在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。 做什么，而不是怎么做 我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而不得不创建一个对象。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。 传递一段代码——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。 Lambda的优化当需要启动一个线程去完成任务时，通常会通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。 传统写法,代码如下： 12345678910public class Demo01ThreadNameless &#123;\tpublic static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;多线程任务执行！&quot;); &#125; &#125;).start();\t&#125;&#125; 本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个Runnable接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。 代码分析: 对于Runnable的匿名内部类用法，可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要Runnable接口的实现类； 为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 Lambda表达式写法,代码如下： 借助Java 8的全新语法，上述Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效： public class Demo02LambdaRunnable &#123;\tpublic static void main(String[] args) &#123; new Thread(() -&gt; System.out.println(&quot;多线程任务执行！&quot;)).start(); // 启动线程\t&#125;&#125; 这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。 不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！ Lambda的格式标准格式:Lambda省去面向对象的条条框框，格式由3个部分组成： 一些参数 一个箭头 一段代码 Lambda表达式的标准格式为： (参数类型 参数名称) -&gt; &#123; 代码语句 &#125; 格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt;是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 匿名内部类与lambda对比: 123456new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;多线程任务执行！&quot;); &#125;&#125;).start(); 仔细分析该代码中，Runnable接口只有一个run方法的定义： public abstract void run(); 即制定了一种做事情的方案（其实就是一个方法）： 无参数：不需要任何条件即可执行该方案。 无返回值：该方案不产生任何结果。 代码块（方法体）：该方案的具体执行步骤。 同样的语义体现在Lambda语法中，要更加简单： () -&gt; System.out.println(&quot;多线程任务执行！&quot;) 前面的一对小括号即run方法的参数（无），代表不需要任何条件； 中间的一个箭头代表将前面的参数传递给后面的代码； 后面的输出语句即业务逻辑代码。 参数和返回值下面举例演示java.util.Comparator&lt;T&gt;接口的使用场景代码，其中的抽象方法定义为： public abstract int compare(T o1, T o2); 当需要对一个对象数组进行排序时，Arrays.sort方法需要一个Comparator接口实例来指定排序的规则。假设有一个Person类，含有String name和int age两个成员变量： 123456public class Person &#123; private String name; private int age; // 省略构造器、toString方法与Getter Setter &#125; 传统写法 如果使用传统的代码对Person[]数组进行排序，写法如下： 12345678910111213141516171819public class Demo06Comparator &#123; public static void main(String[] args) &#123; // 本来年龄乱序的对象数组 Person[] array = &#123; new Person(&quot;古力娜扎&quot;, 19), new Person(&quot;迪丽热巴&quot;, 18), new Person(&quot;马尔扎哈&quot;, 20) &#125;; // 匿名内部类 Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; return o1.getAge() - o2.getAge(); &#125; &#125;; Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例 for (Person person : array) &#123; System.out.println(person); &#125; &#125;&#125; 这种做法在面向对象的思想中，似乎也是“理所当然”的。其中Comparator接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。 代码分析 下面我们来搞清楚上述代码真正要做什么事情。 为了排序，Arrays.sort方法需要排序规则，即Comparator接口的实例，抽象方法compare是关键； 为了指定compare的方法体，不得不需要Comparator接口的实现类； 为了省去定义一个ComparatorImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象compare方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 实际上，只有参数和方法体才是关键。 Lambda写法 12345678910111213141516public class Demo07ComparatorLambda &#123; public static void main(String[] args) &#123; Person[] array = &#123; new Person(&quot;古力娜扎&quot;, 19), new Person(&quot;迪丽热巴&quot;, 18), new Person(&quot;马尔扎哈&quot;, 20) &#125;; Arrays.sort(array, (Person a, Person b) -&gt; &#123; return a.getAge() - b.getAge(); &#125;); for (Person person : array) &#123; System.out.println(person); &#125; &#125;&#125; 省略格式在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。 可推导即可省略 Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法： Runnable接口简化:1. () -&gt; System.out.println(&quot;多线程任务执行！&quot;)Comparator接口简化:2. Arrays.sort(array, (a, b) -&gt; a.getAge() - b.getAge()); Lambda的前提条件Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。 Stream在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。 传统集合的多步遍历代码 几乎所有的集合（如Collection接口或Map接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。 循环遍历的弊端 Java 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行了对比说明。现在，我们仔细体会一下上例代码，可以发现： for循环的语法就是“怎么做” for循环的循环体才是“做什么” 为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从第一个到最后一个顺次处理的循环。前者是目的，后者是方式。 试想一下，如果希望对集合中的元素进行筛选过滤： 将集合A根据条件一过滤为子集B； 然后再根据条件二过滤为子集C。 每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。 那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？ Stream的更优写法 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤、逐一打印。代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。 流式思想概述注意：请暂时忘记对传统IO流的固有印象！ 整体来看，流式思想类似于工厂车间的“生产流水线”。 当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤方案，然后再按照方案去执行它。 “Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。 获取流方式java.util.stream.Stream&lt;T&gt;是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。） 获取一个流非常简单，有以下几种常用的方式： 所有的Collection集合都可以通过stream默认方法获取流； Stream接口的静态方法of可以获取数组对应的流。 方式1 : 根据Collection获取流 首先，java.util.Collection接口中加入了default方法stream用来获取流，所以其所有实现类均可获取流。 123456789101112131415161718import java.util.*;import java.util.stream.Stream;public class Demo04GetStream &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); // ... Stream&lt;String&gt; stream1 = list.stream(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); // ... Stream&lt;String&gt; stream2 = set.stream(); Vector&lt;String&gt; vector = new Vector&lt;&gt;(); // ... Stream&lt;String&gt; stream3 = vector.stream(); &#125;&#125; 方式2 : 根据Map获取流 java.util.Map接口不是Collection的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况： 12345678910111213import java.util.HashMap;import java.util.Map;import java.util.stream.Stream;public class Demo05GetStream &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // ... Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;String&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream(); &#125;&#125; 方式3 : 根据数组获取流 如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以Stream接口中提供了静态方法of，使用很简单： 12345678import java.util.stream.Stream;public class Demo06GetStream &#123; public static void main(String[] args) &#123; String[] array = &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;; Stream&lt;String&gt; stream = Stream.of(array); &#125;&#125; 备注：of方法的参数其实是一个可变参数，所以支持数组。 常用方法流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种： 终结方法：返回值类型不再是Stream接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调用。本小节中，终结方法包括count和forEach方法。 非终结方法：返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为非终结方法。） 函数拼接与终结方法在上述介绍的各种方法中，凡是返回值仍然为Stream接口的为函数拼接方法，它们支持链式调用；而返回值不再为Stream接口的为终结方法，不再支持链式调用。如下表所示： 方法名 方法作用 方法种类 是否支持链式调用 count 统计个数 终结 否 forEach 逐一处理 终结 否 filter 过滤 函数拼接 是 limit 取用前几个 函数拼接 是 skip 跳过前几个 函数拼接 是 map 映射 函数拼接 是 concat 组合 函数拼接 是 备注：本小节之外的更多方法，请自行参考API文档。 forEach : 逐一处理虽然方法名字叫forEach，但是与for循环中的“for-each”昵称不同，该方法并不保证元素的逐一消费动作在流中是被有序执行的。 void forEach(Consumer&lt;? super T&gt; action); 该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理。例如： 12345678import java.util.stream.Stream;public class Demo12StreamForEach &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); stream.forEach(s-&gt;System.out.println(s)); &#125;&#125; count：统计个数正如旧集合Collection当中的size方法一样，流提供count方法来数一数其中的元素个数： long count(); 该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用： 1234567public class Demo09StreamCount &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.filter(s -&gt; s.startsWith(&quot;张&quot;)); System.out.println(result.count()); // 2 &#125;&#125; filter：过滤可以通过filter方法将一个流转换成另一个子集流。方法声明： Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 该接口接收一个Predicate函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。 基本使用 Stream流中的filter方法基本使用的代码如： 123456public class Demo07StreamFilter &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.filter(s -&gt; s.startsWith(&quot;张&quot;)); &#125;&#125; 在这里通过Lambda表达式来指定了筛选的条件：必须姓张。 limit：取用前几个limit方法可以对流进行截取，只取用前n个。方法签名： Stream&lt;T&gt; limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用： 123456789import java.util.stream.Stream;public class Demo10StreamLimit &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.limit(2); System.out.println(result.count()); // 2 &#125;&#125; skip：跳过前几个如果希望跳过前几个元素，可以使用skip方法获取一个截取之后的新流： Stream&lt;T&gt; skip(long n); 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用： 12345678910import java.util.stream.Stream;public class Demo11StreamSkip &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.skip(2); System.out.println(result.count()); // 1 &#125;&#125; map：映射如果需要将流中的元素映射到另一个流中，可以使用map方法。方法签名： &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 基本使用 Stream流中的map方法基本使用的代码如： 12345678import java.util.stream.Stream;public class Demo08StreamMap &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;10&quot;, &quot;12&quot;, &quot;18&quot;); Stream&lt;Integer&gt; result = original.map(s-&gt;Integer.parseInt(s)); &#125;&#125; 这段代码中，map方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为Integer类对象）。 concat：组合如果有两个流，希望合并成为一个流，那么可以使用Stream接口的静态方法concat： static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 备注：这是一个静态方法，与java.lang.String当中的concat方法是不同的。 该方法的基本使用代码如： 123456789import java.util.stream.Stream;public class Demo12StreamConcat &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; streamA = Stream.of(&quot;张无忌&quot;); Stream&lt;String&gt; streamB = Stream.of(&quot;张翠山&quot;); Stream&lt;String&gt; result = Stream.concat(streamA, streamB); &#125;&#125; 收集Stream结果对流操作完成之后，如果需要将其结果进行收集，例如获取对应的集合、数组等，如何操作？ 收集到集合中Stream流提供collect方法，其参数需要一个java.util.stream.Collector&lt;T,A, R&gt;接口对象来指定收集到哪种集合中。幸运的是，java.util.stream.Collectors类提供一些方法，可以作为Collector接口的实例： public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()：转换为List集合。 public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()：转换为Set集合。 下面是这两个方法的基本使用代码： 123456789101112import java.util.List;import java.util.Set;import java.util.stream.Collectors;import java.util.stream.Stream;public class Demo15StreamCollect &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(&quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;, &quot;50&quot;); List&lt;String&gt; list = stream.collect(Collectors.toList()); Set&lt;String&gt; set = stream.collect(Collectors.toSet()); &#125;&#125; 收集到数组中Stream提供toArray方法来将结果放到一个数组中，由于泛型擦除的原因，返回值类型是Object[]的： Object[] toArray(); 其使用场景如： 12345678import java.util.stream.Stream;public class Demo16StreamArray &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(&quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;, &quot;50&quot;); Object[] objArray = stream.toArray(); &#125;&#125;","tags":["Java","JDK8"],"categories":["JavaSE"]},{"title":"(八). 登堂入室 - I/O流","path":"/javaSE-IO.html","content":"File类java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 构造举例，代码如下： 1234567891011121314151617// 文件路径名String pathname = &quot;D:\\\\aaa.txt&quot;;File file1 = new File(pathname); // 文件路径名String pathname2 = &quot;D:\\\\aaa\\\\bbb.txt&quot;;File file2 = new File(pathname2); // 通过父路径和子路径字符串 String parent = &quot;d:\\\\aaa&quot;; String child = &quot;bbb.txt&quot;; File file3 = new File(parent, child);// 通过父级File对象和子路径字符串File parentDir = new File(&quot;d:\\\\aaa&quot;);String child = &quot;bbb.txt&quot;;File file4 = new File(parentDir, child); 小贴士： 一个File对象代表硬盘中实际存在的一个文件或者目录。 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 常用方法获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。 方法演示，代码如下： 12345678910111213141516171819202122232425public class FileGet &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/aaa/bbb.java&quot;); System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath()); System.out.println(&quot;文件构造路径:&quot;+f.getPath()); System.out.println(&quot;文件名称:&quot;+f.getName()); System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;); File f2 = new File(&quot;d:/aaa&quot;); System.out.println(&quot;目录绝对路径:&quot;+f2.getAbsolutePath()); System.out.println(&quot;目录构造路径:&quot;+f2.getPath()); System.out.println(&quot;目录名称:&quot;+f2.getName()); System.out.println(&quot;目录长度:&quot;+f2.length()); &#125;&#125;输出结果：文件绝对路径:d:\\aaa\\bbb.java文件构造路径:d:\\aaa\\bbb.java文件名称:bbb.java文件长度:636字节目录绝对路径:d:\\aaa目录构造路径:d:\\aaa目录名称:aaa目录长度:4096 API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。 绝对路径和相对路径 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 1234567891011121314public class FilePath &#123; public static void main(String[] args) &#123; // D盘下的bbb.java文件 File f = new File(&quot;D:\\\\bbb.java&quot;); System.out.println(f.getAbsolutePath()); // 项目下的bbb.java文件 File f2 = new File(&quot;bbb.java&quot;); System.out.println(f2.getAbsolutePath()); &#125;&#125;输出结果：D:\\bbb.javaD:\\idea_project_test4\\bbb.java 判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 方法演示，代码如下： 1234567891011121314151617public class FileIs &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:\\\\aaa\\\\bbb.java&quot;); File f2 = new File(&quot;d:\\\\aaa&quot;); // 判断是否存在 System.out.println(&quot;d:\\\\aaa\\\\bbb.java 是否存在:&quot;+f.exists()); System.out.println(&quot;d:\\\\aaa 是否存在:&quot;+f2.exists()); // 判断是文件还是目录 System.out.println(&quot;d:\\\\aaa 文件?:&quot;+f2.isFile()); System.out.println(&quot;d:\\\\aaa 目录?:&quot;+f2.isDirectory()); &#125;&#125;输出结果：d:\\aaa\\bbb.java 是否存在:trued:\\aaa 是否存在:trued:\\aaa 文件?:falsed:\\aaa 目录?:true 创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir() ：创建由此File表示的目录。 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 方法演示，代码如下： 12345678910111213141516171819202122232425262728public class FileCreateDelete &#123; public static void main(String[] args) throws IOException &#123; // 文件的创建 File f = new File(&quot;aaa.txt&quot;); System.out.println(&quot;是否存在:&quot;+f.exists()); // false System.out.println(&quot;是否创建:&quot;+f.createNewFile()); // true System.out.println(&quot;是否存在:&quot;+f.exists()); // true // 目录的创建 File f2= new File(&quot;newDir&quot;); System.out.println(&quot;是否存在:&quot;+f2.exists());// false System.out.println(&quot;是否创建:&quot;+f2.mkdir());\t// true System.out.println(&quot;是否存在:&quot;+f2.exists());// true // 创建多级目录 File f3= new File(&quot;newDira\\ ewDirb&quot;); System.out.println(f3.mkdir());// false File f4= new File(&quot;newDira\\ ewDirb&quot;); System.out.println(f4.mkdirs());// true // 文件的删除 System.out.println(f.delete());// true // 目录的删除 System.out.println(f2.delete());// true System.out.println(f4.delete());// false &#125;&#125; API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 12345678910111213141516public class FileFor &#123; public static void main(String[] args) &#123; File dir = new File(&quot;d:\\\\java_code&quot;); //获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name : names)&#123; System.out.println(name); &#125; //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息 File[] files = dir.listFiles(); for (File file : files) &#123; System.out.println(file); &#125; &#125;&#125; 小贴士： 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 IO概述什么是IO生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了ctrl+s ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。 我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。 Java中I&#x2F;O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。 IO的分类根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 字节流一切皆为字节一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 字节输出流OutputStreamjava.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileOutputStream类OutputStream有很多子类，我们从最简单的一个子类开始。java.io.FileOutputStream 类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 构造举例，代码如下： 12345678910public class FileOutputStreamConstructor throws IOException &#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(&quot;a.txt&quot;); FileOutputStream fos = new FileOutputStream(file); // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;b.txt&quot;); &#125;&#125; 写出字节数据 写出字节：write(int b) 方法，每次可以写出一个字节数据，代码使用演示： 123456789101112131415public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); // 写出数据 fos.write(97); // 写出第1个字节 fos.write(98); // 写出第2个字节 fos.write(99); // 写出第3个字节 // 关闭资源 fos.close(); &#125;&#125;输出结果：abc 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); // 字符串转换为字节数组 byte[] b = &quot;一个程序员&quot;.getBytes(); // 写出字节数组数据 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;输出结果：一个程序员 写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); // 字符串转换为字节数组 byte[] b = &quot;abcde&quot;.getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b,2,2); // 关闭资源 fos.close(); &#125;&#125;输出结果：cd 数据追加续写经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？ public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;，true); // 字符串转换为字节数组 byte[] b = &quot;abcde&quot;.getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;文件操作前：cd文件操作后：cdabcde 写出换行Windows系统里，换行符号是\\r 。把 以指定是否追加续写了，代码使用演示： 123456789101112131415161718192021222324public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); // 定义字节数组 byte[] words = &#123;97,98,99,100,101&#125;; // 遍历数组 for (int i = 0; i &lt; words.length; i++) &#123; // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write(&quot;\\r &quot;.getBytes()); &#125; // 关闭资源 fos.close(); &#125;&#125;输出结果：abcde 回车符\\r和换行符 ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\\r ； Unix系统里，每行结尾只有 换行 ，即 ； Mac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。 字节输入流InputStreamjava.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileInputStream类java.io.FileInputStream 类是文件输入流，从文件中读取字节。 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 构造举例，代码如下： 12345678910public class FileInputStreamConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(&quot;a.txt&quot;); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream(&quot;b.txt&quot;); &#125;&#125; 读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码使用演示： 1234567891011121314151617181920212223242526272829public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 读取数据，返回一个字节 int read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); // 读取到末尾,返回-1 read = fis.read(); System.out.println( read); // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde-1 循环改进读取方式，代码使用演示： 1234567891011121314151617181920public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示： 12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组变成字符串打印 System.out.println(new String(b)); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcded 错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换，所以要通过len ，获取有效的字节，代码使用演示： 12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b，0，len));// len 每次读取的有效字节个数 &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 字符输入流Readerjava.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 FileReader类java.io.FileReader 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 构造举例，代码如下： 12345678910public class FileReaderConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(&quot;a.txt&quot;); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader(&quot;b.txt&quot;); &#125;&#125; 读取字符数据 读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示： 1234567891011121314public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(&quot;read.txt&quot;); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fr.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fr.close(); &#125;&#125; 小贴士：虽然读取了一个字符，但是会自动提升为int类型。 使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示： 12345678910111213141516public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(&quot;read.txt&quot;); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf)); &#125; // 关闭资源 fr.close(); &#125;&#125; 获取有效的字符改进，代码使用演示： 12345678910111213141516public class FISRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(&quot;read.txt&quot;); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf,0,len)); &#125; // 关闭资源 fr.close(); &#125;&#125; 字符输出流Writerjava.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public abstract void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public abstract void flush() ：刷新此输出流并强制任何缓冲的输出字符被写出。 public void write(int c) ：写出一个字符。 public void write(char[] cbuf)：将 b.length字符从指定的字符数组写出此输出流。 public abstract void write(char[] b, int off, int len) ：从指定的字符数组写出 len字符，从偏移量 off开始输出到此输出流。 public void write(String str) ：写出一个字符串。 FileWriter类java.io.FileWriter 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。 构造举例，代码如下： 12345678910public class FileWriterConstructor &#123; public static void main(String[] args) throws IOException &#123; // 使用File对象创建流对象 File file = new File(&quot;a.txt&quot;); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;b.txt&quot;); &#125;&#125; 基本写出数据写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示： 12345678910111213141516171819public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;fw.txt&quot;); // 写出数据 fw.write(97); // 写出第1个字符 fw.write(&#x27;b&#x27;); // 写出第2个字符 fw.write(&#x27;C&#x27;); // 写出第3个字符 fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。 /* 【注意】关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。 */ // fw.close(); &#125;&#125;输出结果：abC田 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。 close ：关闭流，释放系统资源。关闭前会刷新缓冲区。 代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;fw.txt&quot;); // 写出数据，通过flush fw.write(&#x27;刷&#x27;); // 写出第1个字符 fw.flush(); fw.write(&#x27;新&#x27;); // 继续写出第2个字符，写出成功 fw.flush(); // 写出数据，通过close fw.write(&#x27;关&#x27;); // 写出第1个字符 fw.close(); fw.write(&#x27;闭&#x27;); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed fw.close(); &#125;&#125; 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。 写出其他数据 写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;fw.txt&quot;); // 字符串转换为字节数组 char[] chars = &quot;一个程序员&quot;.toCharArray(); // 写出字符数组 fw.write(chars); // 一个程序员 // 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。 fw.write(b,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;fw.txt&quot;); // 字符串 String msg = &quot;一个程序员&quot;; // 写出字符数组 fw.write(msg); //一个程序员 // 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。 fw.write(msg,2,2);\t// 程序 // 关闭资源 fos.close(); &#125;&#125; 续写和换行：操作类似于FileOutputStream。 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象，可以续写数据 FileWriter fw = new FileWriter(&quot;fw.txt&quot;，true); // 写出字符串 fw.write(&quot;一个&quot;); // 写出换行 fw.write(&quot;\\r &quot;); // 写出字符串 fw.write(&quot;程序员&quot;); // 关闭资源 fw.close(); &#125;&#125;输出结果:一个程序员 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流 IO资源的处理JDK7前处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用try...catch...finally 代码块，处理异常部分，代码使用演示： 12345678910111213141516171819202122public class HandleException1 &#123; public static void main(String[] args) &#123; // 声明变量 FileWriter fw = null; try &#123; //创建流对象 fw = new FileWriter(&quot;fw.txt&quot;); // 写出数据 fw.write(&quot;一个程序员&quot;); //一个程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fw != null) &#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDK7的处理还可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。 格式： try (创建流对象语句，如果多个,使用&#x27;;&#x27;隔开) &#123;\t// 读写数据&#125; catch (IOException e) &#123;\te.printStackTrace();&#125; 代码使用演示： 1234567891011public class HandleException2 &#123; public static void main(String[] args) &#123; // 创建流对象 try ( FileWriter fw = new FileWriter(&quot;fw.txt&quot;); ) &#123; // 写出数据 fw.write(&quot;一个程序员&quot;); //一个程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 属性集概述java.util.Properties 继承于 Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 Properties类构造方法 public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 12345678910111213141516171819202122232425262728293031public class ProDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties properties = new Properties(); // 添加键值对元素 properties.setProperty(&quot;filename&quot;, &quot;a.txt&quot;); properties.setProperty(&quot;length&quot;, &quot;209385038&quot;); properties.setProperty(&quot;location&quot;, &quot;D:\\\\a.txt&quot;); // 打印属性集对象 System.out.println(properties); // 通过键,获取属性值 System.out.println(properties.getProperty(&quot;filename&quot;)); System.out.println(properties.getProperty(&quot;length&quot;)); System.out.println(properties.getProperty(&quot;location&quot;)); // 遍历属性集,获取所有键的集合 Set&lt;String&gt; strings = properties.stringPropertyNames(); // 打印键值对 for (String key : strings ) &#123; System.out.println(key+&quot; -- &quot;+properties.getProperty(key)); &#125; &#125;&#125;输出结果：&#123;filename=a.txt, length=209385038, location=D:\\a.txt&#125;a.txt209385038D:\\a.txtfilename -- a.txtlength -- 209385038location -- D:\\a.txt 与流相关的方法 public void load(InputStream inStream)： 从字节输入流中读取键值对。 参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式: filename=a.txtlength=209385038location=D:\\a.txt 加载代码演示： 1234567891011121314151617public class ProDemo2 &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties pro = new Properties(); // 加载文本中信息到属性集 pro.load(new FileInputStream(&quot;read.txt&quot;)); // 遍历集合并打印 Set&lt;String&gt; strings = pro.stringPropertyNames(); for (String key : strings ) &#123; System.out.println(key+&quot; -- &quot;+pro.getProperty(key)); &#125; &#125;&#125;输出结果：filename -- a.txtlength -- 209385038location -- D:\\a.txt 小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。 缓冲流昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。 概述缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 字节缓冲流构造方法 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 构造举例，代码如下： // 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;)); 效率测试查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。 基本流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( FileInputStream fis = new FileInputStream(&quot;jdk8.exe&quot;); FileOutputStream fos = new FileOutputStream(&quot;copy.exe&quot;) )&#123; // 读写数据 int b; while ((b = fis.read()) != -1) &#123; fos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;十几分钟过去了... 缓冲流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk8.exe&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;)); )&#123; // 读写数据 int b; while ((b = bis.read()) != -1) &#123; bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;缓冲流复制时间:8016 毫秒 如何更快呢？ 使用数组的方式，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk8.exe&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;)); )&#123; // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;缓冲流使用数组复制时间:666 毫秒 字符缓冲流构造方法 public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 构造举例，代码如下： // 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(&quot;br.txt&quot;));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;)); 特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 readLine方法演示，代码如下： 123456789101112131415public class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;)); // 定义字符串,保存读取的一行文字 String line = null; // 循环读取,读取到最后返回null while ((line = br.readLine())!=null) &#123; System.out.print(line); System.out.println(&quot;------&quot;); &#125; // 释放资源 br.close(); &#125;&#125; newLine方法演示，代码如下： 1234567891011121314151617181920public class BufferedWriterDemo throws IOException &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;)); // 写出数据 bw.write(&quot;一个&quot;); // 写出换行 bw.newLine(); bw.write(&quot;程序&quot;); bw.newLine(); bw.write(&quot;员&quot;); bw.newLine(); // 释放资源 bw.close(); &#125;&#125;输出效果:一个程序员 转换流字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本f符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 字符集 **字符集 Charset**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-5559-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 123456789101112public class ReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fileReader = new FileReader(&quot;E:\\\\File_GBK.txt&quot;); int read; while ((read = fileReader.read()) != -1) &#123; System.out.print((char)read); &#125; fileReader.close(); &#125;&#125;输出结果：��� 那么如何读取GBK编码的文件呢？ InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;); 指定编码读取12345678910111213141516171819202122232425public class ReaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String FileName = &quot;E:\\\\file_gbk.txt&quot;; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , &quot;GBK&quot;); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); &#125;&#125; OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;) , &quot;GBK&quot;); 指定编码写出12345678910111213141516171819public class OutputDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = &quot;E:\\\\out.txt&quot;; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write(&quot;你好&quot;); // 保存为6个字节 osw.close(); // 定义文件路径 String FileName2 = &quot;E:\\\\out2.txt&quot;; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;); // 写出数据 osw2.write(&quot;你好&quot;);// 保存为4个字节 osw2.close(); &#125;&#125; 序列化概述​ Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 ​ 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out) ： 创建一个指定OutputStream的ObjectOutputStream。 构造举例，代码如下： FileOutputStream fileOut = new FileOutputStream(&quot;employee.txt&quot;);ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 12345678public class Employee implements java.io.Serializable &#123; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() &#123; System.out.println(&quot;Address check : &quot; + name + &quot; -- &quot; + address); &#125;&#125; 2.写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 12345678910111213141516171819202122public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = &quot;zhangsan&quot;; e.address = &quot;beiqinglu&quot;; e.age = 20; try &#123; // 创建序列化流对象 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;)); // 写出对象 out.writeObject(e); // 释放资源 out.close(); fileOut.close(); System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。 &#125; catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125;输出结果：Serialized data is saved ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 12345678910111213141516171819202122232425262728public class DeserializeDemo &#123; public static void main(String [] args) &#123; Employee e = null; try &#123; // 创建反序列化流 FileInputStream fileIn = new FileInputStream(&quot;employee.txt&quot;); ObjectInputStream in = new ObjectInputStream(fileIn); // 读取一个对象 e = (Employee) in.readObject(); // 释放资源 in.close(); fileIn.close(); &#125;catch(IOException i) &#123; // 捕获其他异常 i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; // 捕获类找不到异常 System.out.println(&quot;Employee class not found&quot;); c.printStackTrace(); return; &#125; // 无异常,直接打印输出 System.out.println(&quot;Name: &quot; + e.name);\t// zhangsan System.out.println(&quot;Address: &quot; + e.address); // beiqinglu System.out.println(&quot;age: &quot; + e.age); // 0 &#125;&#125; 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 反序列化操作2另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。 发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 123456789101112public class Employee implements java.io.Serializable &#123; // 加入序列版本号 private static final long serialVersionUID = 1L; public String name; public String address; // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值. public int eid; public void addressCheck() &#123; System.out.println(&quot;Address check : &quot; + name + &quot; -- &quot; + address); &#125;&#125; 打印流概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 PrintStream类 public PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。 构造举例，代码如下： PrintStream ps = new PrintStream(&quot;ps.txt&quot;)； System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，将数据输出到指定文本文件中。 1234567891011121314public class PrintDemo &#123; public static void main(String[] args) throws IOException &#123; // 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream(&quot;ps.txt&quot;); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); &#125;&#125;","tags":["Java","I/O流"],"categories":["JavaSE"]},{"title":"(七). 登堂入室- 多线程","path":"/javaSE-Multithreading.html","content":"多线程并发与并行 并行：指两个或多个事件在同一时刻发生（同时执行）。 并发：指两个或多个事件在同一个时间段内发生(交替执行)。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 进程与线程的区别 进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。 线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。 因为一个进程中的多个线程是并发运行的，那么从微观角度看也是有先后顺序的，哪个线程执行完全取决于 CPU 的调度，程序员是干涉不了的。而这也就造成的多线程的随机性。 Java 程序的进程里面至少包含两个线程，主进程也就是 main()方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，每一个 JVM 实际上就是在操作系统中启动了一个线程，java 本身具备了垃圾的收集机制，所以在 Java 运行时至少会启动两个线程。 由于创建一个线程的开销比创建一个进程的开销小的多，那么我们在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。 线程调度: 分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 Thread类线程开启我们需要用到了java.lang.Thread类，API中该类中定义了有关线程的一些方法，具体如下： 构造方法： public Thread():分配一个新的线程对象。 public Thread(String name):分配一个指定名字的新的线程对象。 public Thread(Runnable target):分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName():获取当前线程名称。 public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run():此线程要执行的任务在此处定义代码。 public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread() :返回对当前正在执行的线程对象的引用。 翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式 继承方式Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 测试类： 123456789101112public class Demo01 &#123;\tpublic static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread(&quot;新的线程！&quot;); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 200; i++) &#123; System.out.println(&quot;main线程！&quot;+i); &#125;\t&#125;&#125; 自定义线程类： 12345678910111213141516171819public class MyThread extends Thread &#123;\t//定义指定线程名称的构造方法\tpublic MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name);\t&#125; public MyThread() &#123; //不指定线程的名字,线程有默认的名字Thread-0\t&#125;\t/** * 重写run方法，完成该线程执行的逻辑 */\t@Override\tpublic void run() &#123; for (int i = 0; i &lt; 200; i++) &#123; System.out.println(getName()+&quot;：正在执行！&quot;+i); &#125;\t&#125;&#125; 实现方式采用java.lang.Runnable也是非常常见的一种，我们只需要重写run方法即可。 步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动线程。 代码如下： 12345678public class MyRunnable implements Runnable&#123;\t@Override\tpublic void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125;\t&#125;&#125; 123456789101112public class Demo &#123; public static void main(String[] args) &#123; //创建自定义类对象 线程任务对象 MyRunnable mr = new MyRunnable(); //创建线程对象 Thread t = new Thread(mr, &quot;小强&quot;); t.start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;旺财 &quot; + i); &#125; &#125;&#125; 通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程。 匿名内部类方式使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。 使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法： 1234567891011121314151617181920212223public class NoNameInnerClassThread &#123; public static void main(String[] args) &#123; // new Runnable()&#123;// public void run()&#123;// for (int i = 0; i &lt; 20; i++) &#123;// System.out.println(&quot;张宇:&quot;+i);// &#125;// &#125; // &#125;; //---这个整体 相当于new MyRunnable() Runnable r = new Runnable()&#123; public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;张宇:&quot;+i); &#125; &#125; &#125;; new Thread(r).start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;费玉清:&quot;+i); &#125; &#125;&#125; 线程安全线程安全如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 我们通过一个案例，演示线程的安全问题： 电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个(本场电影只能卖100张票)。 我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票) 需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟。 模拟票： 1234567891011121314151617181920212223242526public class Ticket implements Runnable &#123; private int ticket = 100; /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while (true) &#123; if (ticket &gt; 0) &#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name + &quot;正在卖:&quot; + ticket--); &#125; &#125; &#125;&#125; 测试类： 123456789101112131415public class Demo &#123;\tpublic static void main(String[] args) &#123; //创建线程任务对象 Ticket ticket = new Ticket(); //创建三个窗口对象 Thread t1 = new Thread(ticket, &quot;窗口1&quot;); Thread t2 = new Thread(ticket, &quot;窗口2&quot;); Thread t3 = new Thread(ticket, &quot;窗口3&quot;); //同时卖票 t1.start(); t2.start(); t3.start();\t&#125;&#125; 发现程序出现了两个问题： 相同的票数,比如5这张票被卖了两回。 不存在的票，比如0票与-1票，是不存在的。 这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步线程同步是为了解决线程安全问题。当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。 根据案例简述：窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。 为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。 同步代码块。 同步方法。 锁机制。 同步代码块 同步代码块：synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式: synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步锁: 对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 锁对象 可以是任意类型。 多个线程对象 要使用同一把锁。 注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。 使用同步代码块解决代码： 123456789101112131415161718192021222324252627282930public class Ticket implements Runnable&#123;\tprivate int ticket = 100; Object lock = new Object();\t/* * 执行卖票操作 */\t@Override\tpublic void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; synchronized (lock) &#123; if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+&quot;正在卖:&quot;+ticket--); &#125; &#125; &#125;\t&#125;&#125; 当使用了同步代码块后，上述的线程的安全问题，解决了。 同步方法 同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。 格式： public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; 同步锁是谁?​ 对于非static方法,同步锁就是this。​ 对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 使用同步方法代码如下： 1234567891011121314151617181920212223242526272829303132333435public class Ticket implements Runnable&#123;\tprivate int ticket = 100;\t/* * 执行卖票操作 */\t@Override\tpublic void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; sellTicket(); &#125;\t&#125; /* * 锁对象 是 谁调用这个方法 就是谁 * 隐含 锁对象 就是 this * */\tpublic synchronized void sellTicket()&#123; if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+&quot;正在卖:&quot;+ticket--); &#125;\t&#125;&#125; Lock锁java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块&#x2F;同步方法具有的功能Lock都有,除此之外更强大 Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock() :加同步锁。 public void unlock():释放同步锁。 使用如下： 123456789101112131415161718192021222324252627282930public class Ticket implements Runnable&#123;\tprivate int ticket = 100; Lock lock = new ReentrantLock();\t/* * 执行卖票操作 */\t@Override\tpublic void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; lock.lock(); if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+&quot;正在卖:&quot;+ticket--); &#125; lock.unlock(); &#125;\t&#125;&#125; 线程状态线程状态概述当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中java.lang.Thread.State这个枚举中给出了六种线程状态： 这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。MyThread t &#x3D; new MyThread只有线程对象，没有线程特征。 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。调用了t.start()方法 ：就绪（经典教法） Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 ​\t我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题。 睡眠sleep方法我们看到状态中有一个状态叫做计时等待，可以通过Thread类的方法来进行演示.public static void sleep(long time) 让当前线程进入到睡眠状态，到毫秒后自动醒来继续执行 12345678public class Test&#123; public static void main(String[] args)&#123; for(int i = 1;i&lt;=5;i++)&#123; Thread.sleep(1000); System.out.println(i) &#125; &#125;&#125; 这时我们发现主线程执行到sleep方法会休眠1秒后再继续执行。 等待和唤醒Object类的方法 public void wait() : 让当前线程进入到等待状态 此方法必须锁对象调用. 123456789101112131415public class Demo1_wait &#123; public static void main(String[] args) throws InterruptedException &#123; // 步骤1 : 子线程开启,进入无限等待状态, 没有被唤醒,无法继续运行. new Thread(() -&gt; &#123; try &#123; System.out.println(&quot;begin wait ....&quot;); synchronized (&quot;&quot;) &#123; &quot;&quot;.wait(); &#125; System.out.println(&quot;over&quot;); &#125; catch (Exception e) &#123; &#125; &#125;).start(); &#125; public void notify() : 唤醒当前锁对象上等待状态的线程 此方法必须锁对象调用. 12345678910111213141516171819202122232425262728public class Demo2_notify &#123; public static void main(String[] args) throws InterruptedException &#123; // 步骤1 : 子线程开启,进入无限等待状态, 没有被唤醒,无法继续运行. new Thread(() -&gt; &#123; try &#123; System.out.println(&quot;begin wait ....&quot;); synchronized (&quot;&quot;) &#123; &quot;&quot;.wait(); &#125; System.out.println(&quot;over&quot;); &#125; catch (Exception e) &#123; &#125; &#125;).start(); //步骤2: 加入如下代码后, 3秒后,会执行notify方法, 唤醒wait中线程. Thread.sleep(3000); new Thread(() -&gt; &#123; try &#123; synchronized (&quot;&quot;) &#123; System.out.println(&quot;唤醒&quot;); &quot;&quot;.notify(); &#125; &#125; catch (Exception e) &#123; &#125; &#125;).start(); &#125;&#125; volatile关键字看程序说结果1234567891011121314151617181920212223242526272829303132333435363738public class VolatileThread extends Thread &#123; // 定义成员变量 private boolean flag = false ; public boolean isFlag() &#123; return flag;&#125; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 将flag的值更改为true this.flag = true ; System.out.println(&quot;flag=&quot; + flag); &#125;&#125;public class VolatileThreadDemo &#123;// 测试类 public static void main(String[] args) &#123; // 创建VolatileThread线程对象 VolatileThread volatileThread = new VolatileThread() ; volatileThread.start(); // main方法 while(true) &#123; if(volatileThread.isFlag()) &#123; System.out.println(&quot;执行了======&quot;); &#125; &#125; &#125;&#125; VolatileThread线程中已经将flag设置为true，但main()方法中始终没有读到，从而没有打印。 JMM概述：JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。 Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。 所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。每一个线程还存在自己的工作内存，线程 的工作内存，保留了被线程使用的变量的工作副本。线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问 对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。 问题分析 VolatileThread线程从主内存读取到数据放入其对应的工作内存 将flag的值更改为true，但是这个时候flag的值还没有写会主内存 此时main方法读取到了flag的值为false 当VolatileThread线程将flag的值写回去后，但是main函数里面的while(true)调用的是系统比较底层的代码，速度快，快到没有时间再去读取主存中的值， 所以while(true)读取到的值一直是false。(如果有一个时刻main线程从主内存中读取到了主内存中flag的最新值，那么if语句就可以执行，main线程何时从主内存中读取最新的值，我们无法控制) 问题处理加锁12345678// main方法while(true) &#123; synchronized (volatileThread) &#123; if(volatileThread.isFlag()) &#123; System.out.println(&quot;执行了======&quot;); &#125; &#125;&#125; 某一个线程进入synchronized代码块前后，执行过程入如下： 线程获得锁 清空工作内存 从主内存拷贝共享变量最新的值到工作内存成为副本 执行代码 将修改后的副本的值刷新回主内存中 线程释放锁 volatile关键字使用volatile关键字： private volatile boolean flag ; VolatileThread线程从主内存读取到数据放入其对应的工作内存 将flag的值更改为true，但是这个时候flag的值还没有写会主内存 此时main方法main方法读取到了flag的值为false 当VolatileThread线程将flag的值写回去后，失效其他线程对此变量副本 再次对flag进行操作的时候线程会从主内存读取最新的值，放入到工作内存中 总结： volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。但是volatile不保证原子性。 volatile与synchronized volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。 volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他（互斥）的机制， 原子性概述：所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。 看程序说结果12345678910111213141516171819202122232425262728293031public class VolatileAtomicThread implements Runnable &#123; // 定义一个int类型的遍历 private int count = 0 ; @Override public void run() &#123; // 对该变量进行++操作，100次 for(int x = 0 ; x &lt; 100 ; x++) &#123; count++ ; System.out.println(&quot;count =========&gt;&gt;&gt;&gt; &quot; + count); &#125; &#125;&#125;public class VolatileAtomicThreadDemo &#123; public static void main(String[] args) &#123; // 创建VolatileAtomicThread对象 VolatileAtomicThread volatileAtomicThread = new VolatileAtomicThread() ; // 开启100个线程对count进行++操作 for(int x = 0 ; x &lt; 100 ; x++) &#123; new Thread(volatileAtomicThread).start(); &#125; &#125;&#125; 执行结果：不保证一定是10000 问题原理说明以上问题主要是发生在count++操作上： 从主内存中读取数据到工作内存 对工作内存中的数据进行++操作 将工作内存中的数据写回到主内存 count++操作不是一个原子性操作，也就是说在某一个时刻对某一个操作的执行，有可能被其他的线程打断。 假设此时x的值是100，线程A需要对改变量进行自增1的操作，首先它需要从主内存中读取变量x的值。由于CPU的切换关系，此时CPU的执行权被切换到了B线程。A线程就处于就绪状态，B线程处于运行状态 线程B也需要从主内存中读取x变量的值,由于线程A没有对x值做任何修改因此此时B读取到的数据还是100 线程B工作内存中x执行了+1操作，但是未刷新之主内存中 此时CPU的执行权切换到了A线程上，由于此时线程B没有将工作内存中的数据刷新到主内存，因此A线程工作内存中的变量值还是100，没有失效。A线程对工作内存中的数据进行了+1操作 线程B将101写入到主内存 线程A将101写入到主内存，虽然计算了2次，但是只对A进行了1次修改。 volatile原子性测试代码测试// 定义一个int类型的变量private volatile int count = 0 ; 小结：在多线程环境下，volatile关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性（在多线程环境下volatile修饰的变量也是线程不安全的）。 在多线程环境下，要保证数据的安全性，我们还需要使用锁机制。 volatile的使用场景 开关控制：利用可见性特点，控制某一段代码执行或者关闭(比如今天课程的第一个案例)。 多个线程操作共享变量，但是是有一个线程对其进行写操作，其他的线程都是读 问题解决使用锁机制我们可以给count++操作添加锁，那么count++操作就是临界区的代码，临界区只能有一个线程去执行，所以count++就变成了原子操作。 123456789101112131415161718public class VolatileAtomicThread implements Runnable &#123; // 定义一个int类型的变量 private volatile int count = 0 ; private static final Object obj = new Object(); @Override public void run() &#123; // 对该变量进行++操作，100次 for(int x = 0 ; x &lt; 100 ; x++) &#123; synchronized (obj) &#123; count++ ; System.out.println(&quot;count =========&gt;&gt;&gt;&gt; &quot; + count); &#125; &#125; &#125;&#125; 原子类概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。 原子型Integer，可以实现原子更新操作 12345678public AtomicInteger()： 初始化一个默认值为0的原子型Integerpublic AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integerint get(): 获取值int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。int addAndGet(int data): 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 原子类CAS机制实现线程安全。CAS的全成是： Compare And Swap(比较再交换); 是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。CAS可以将read-modify-check-write 转换为原子操作，这个原子操作直接由处理器保证。 CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。 CAS与Synchronized：乐观锁，悲观锁。CAS和Synchronized都可以保证多线程环境下共享数据的安全性。那么他们两者有什么区别？ Synchronized是从悲观的角度出发（悲观锁） 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁 （共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。因此Synchronized我们也将其称之为悲观锁。jdk中的ReentrantLock也是一种悲观锁。性能较差！！ CAS是从乐观的角度出发: 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。 CAS这种机制我们也可以将其称之为乐观锁。综合性能较好！ 并发包在JDK的并发包里提供了几个非常有用的并发容器和并发工具类。供我们在多线程开发中进行使用。 ConcurrentHashMap为什么要使用ConcurrentHashMap： HashMap线程不安全，会导致数据错乱 使用线程安全的Hashtable效率低下 基于以上两个原因，便有了ConcurrentHashMap的登场机会。 HashMap线程不安全演示。 公有、静态的集合： public class Const &#123;\tpublic static HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();&#125; 线程，向map中写入数据： 123456public void run() &#123; for (int i = 0; i &lt; 500000; i++) &#123; Const.map.put(this.getName() + (i + 1), this.getName() + i + 1); &#125; System.out.println(this.getName() + &quot; 结束！&quot;);\t&#125; 测试类： 123456789101112131415public class Demo &#123;\tpublic static void main(String[] args) throws InterruptedException &#123; Thread1A a1 = new Thread1A(); Thread1A a2 = new Thread1A(); a1.setName(&quot;线程1-&quot;); a2.setName(&quot;线程2-&quot;); a1.start(); a2.start(); //休息10秒，确保两个线程执行完毕 Thread.sleep(1000 * 5); //打印集合大小 System.out.println(&quot;Map大小：&quot; + Const.map.size());\t&#125;&#125; 说明：两个线程分别向同一个map中写入50000个键值对，最后map的size应为：100000，但多运行几次会发现有以下几种错误： 假死 异常 错误 为了保证线程安全，可以使用Hashtable。注意：线程中加入了计时 公有、静态的集合： public class Const &#123;\tpublic static Hashtable&lt;String,String&gt; map = new Hashtable&lt;&gt;();&#125; 线程，向map中写入数据： 12345678public void run() &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 500000; i++) &#123; Const.map.put(this.getName() + (i + 1), this.getName() + i + 1); &#125; long end = System.currentTimeMillis(); System.out.println(this.getName() + &quot; 结束！用时：&quot; + (end - start) + &quot; 毫秒&quot;);\t&#125; 测试类： 123456789101112131415public class Demo &#123;\tpublic static void main(String[] args) throws InterruptedException &#123; Thread1A a1 = new Thread1A(); Thread1A a2 = new Thread1A(); a1.setName(&quot;线程1-&quot;); a2.setName(&quot;线程2-&quot;); a1.start(); a2.start(); //休息10秒，确保两个线程执行完毕 Thread.sleep(1000 * 5); //打印集合大小 System.out.println(&quot;Map大小：&quot; + Const.map.size());\t&#125;&#125; Hashtable保证的线程安全，时间是2秒多。 再看ConcurrentHashMap 公有、静态的集合： public class Const &#123;\tpublic static ConcurrentHashMap&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();&#125; 线程，向map中写入数据： 12345678public void run() &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 500000; i++) &#123; Const.map.put(this.getName() + (i + 1), this.getName() + i + 1); &#125; long end = System.currentTimeMillis(); System.out.println(this.getName() + &quot; 结束！用时：&quot; + (end - start) + &quot; 毫秒&quot;);\t&#125; 测试类： 123456789101112131415public class Demo &#123;\tpublic static void main(String[] args) throws InterruptedException &#123; Thread1A a1 = new Thread1A(); Thread1A a2 = new Thread1A(); a1.setName(&quot;线程1-&quot;); a2.setName(&quot;线程2-&quot;); a1.start(); a2.start(); //休息10秒，确保两个线程执行完毕 Thread.sleep(1000 * 5); //打印集合大小 System.out.println(&quot;Map大小：&quot; + Const.map.size());\t&#125;&#125; ConcurrentHashMap仍能保证结果正确，而且提高了效率。 HashTable效率低下原因： public synchronized V put(K key, V value) public synchronized V get(Object key) HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。 ConcurrentHashMap高效的原因：CAS + 局部(synchronized)锁定分段式锁 CountDownLatchCountDownLatch允许一个或多个线程等待其他线程完成操作，再执行自己。 例如：线程1要执行打印：A和C，线程2要执行打印：B，但线程1在打印A后，要线程2打印B之后才能打印C，所以：线程1在打印A后，必须等待线程2打印完B之后才能继续执行。 CountDownLatch构造方法: public CountDownLatch(int count)// 初始化一个指定计数器的CountDownLatch对象 CountDownLatch重要方法: public void await() throws InterruptedException// 让当前线程等待public void countDown()\t// 计数器进行减1 CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为倒数的门栓，似乎有一点“三二一，芝麻开门”的感觉。 CountDownLatch是通过一个计数器来实现的，每当一个线程完成了自己的任务后，可以调用countDown()方法让计数器-1，当计数器到达0时，调用CountDownLatch。 await()方法的线程阻塞状态解除，继续执行。 CyclicBarrierCyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 例如：公司召集5名员工开会，等5名员工都到了，会议开始。 我们创建5个员工线程，1个开会线程，几乎同时启动，使用CyclicBarrier保证5名员工线程全部执行后，再执行开会线程。 CyclicBarrier构造方法： public CyclicBarrier(int parties, Runnable barrierAction)// 用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景 CyclicBarrier重要方法： public int await()// 每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞 使用场景：CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。 需求：使用两个线程读取2个文件中的数据，当两个文件中的数据都读取完毕以后，进行数据的汇总操作。 SemaphoreSemaphore（发信号）的主要作用是控制线程的并发数量。synchronized可以起到”锁”的作用，但某个时间段内，只能有一个线程允许执行。Semaphore可以设置同时允许几个线程执行。Semaphore字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目。Semaphore构造方法： public Semaphore(int permits) permits 表示许可线程的数量public Semaphore(int permits, boolean fair) fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线程 Semaphore重要方法： public void acquire() throws InterruptedException\t表示获取许可public void release() release() 表示释放许可 Exchanger概述Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。 这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。 Exchanger构造方法： public Exchanger() Exchanger重要方法： public V exchange(V x) 使用场景：可以做数据校对工作 需求：比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水。为了避免错误，采用AB岗两人进行录入，录入到两个文件中，系统需要加载这两个文件， 并对两个文件数据进行校对，看看是否录入一致， 线程池线程池的思想我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题： 如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间，线程也属于宝贵的系统资源。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。 线程池概念 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理： 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 线程池的使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。 Executors类中有个创建线程池的方法如下： public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量) 获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。 使用线程池中线程对象的步骤： 创建线程池对象。 创建Runnable接口子类对象。(task) 提交Runnable接口子类对象。(take task) 关闭线程池(一般不做)。 Runnable实现类代码： 12345678910111213public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;我要一个教练&quot;); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;教练来了： &quot; + Thread.currentThread().getName()); System.out.println(&quot;教我游泳,交完后，教练回到了游泳池&quot;); &#125;&#125; 线程池测试类： 12345678910111213141516171819202122public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 // 创建Runnable实例对象 MyRunnable r = new MyRunnable(); //自己创建线程对象的方式 // Thread t = new Thread(r); // t.start(); ---&gt; 调用MyRunnable中的run() // 从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(r); // 再获取个线程对象，调用MyRunnable中的run() service.submit(r); service.submit(r); // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。 // 将使用完的线程又归还到了线程池中 // 关闭线程池 //service.shutdown(); &#125;&#125; Callable测试代码: &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) : 获取线程池中的某一个线程对象，并执行.Future : 表示计算的结果. V get() : 获取计算完成的结果。 12345678910111213141516171819202122232425public class ThreadPoolDemo2 &#123; public static void main(String[] args) throws Exception &#123; // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 // 创建Runnable实例对象 Callable&lt;Double&gt; c = new Callable&lt;Double&gt;() &#123; @Override public Double call() throws Exception &#123; return Math.random(); &#125; &#125;; // 从线程池中获取线程对象,然后调用Callable中的call() Future&lt;Double&gt; f1 = service.submit(c); // Futur 调用get() 获取运算结果 System.out.println(f1.get()); Future&lt;Double&gt; f2 = service.submit(c); System.out.println(f2.get()); Future&lt;Double&gt; f3 = service.submit(c); System.out.println(f3.get()); &#125;&#125; 死锁在多线程程序中,使用了多把锁,造成线程之间相互等待.程序不往下走了。 死锁的条件1.有多把锁2.有多个线程3.有同步代码块嵌套 死锁代码123456789101112131415161718192021222324252627282930313233343536public class Demo05 &#123; public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); new Thread(mr).start(); new Thread(mr).start(); &#125;&#125;class MyRunnable implements Runnable &#123; Object objA = new Object(); Object objB = new Object(); /* 嵌套1 objA 嵌套1 objB 嵌套2 objB 嵌套1 objA */ @Override public void run() &#123; synchronized (objA) &#123; System.out.println(&quot;嵌套1 objA&quot;); synchronized (objB) &#123;// t2, objA, 拿不到B锁,等待 System.out.println(&quot;嵌套1 objB&quot;); &#125; &#125; synchronized (objB) &#123; System.out.println(&quot;嵌套2 objB&quot;); synchronized (objA) &#123;// t1 , objB, 拿不到A锁,等待 System.out.println(&quot;嵌套2 objA&quot;); &#125; &#125; &#125;&#125; 注意:我们应该尽量避免死锁","tags":["Java","多线程"],"categories":["JavaSE"]},{"title":"(六). 登堂入室 - 异常处理","path":"/javaSE-Exception.html","content":"异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 throw new 异常类名(参数); 例如： throw new NullPointerException(&quot;要访问的arr数组不存在&quot;);throw new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;); 演示throw的使用。 123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(&quot;over&quot;); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(&quot;哥们，角标越界了```&quot;); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 Objects非空判断Objects由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，将对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。查看源码发现这里对为null的进行了抛出异常操作： public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read(&quot;a.txt&quot;); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(&quot;b.txt&quot;); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println(&quot;over&quot;); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 在开发中呢也可以在catch将编译期异常转换成运行期异常处理。 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件&#x2F;网络连接&#x2F;数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(&quot;a.txt&quot;); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(&quot;不管程序怎样，这里都将会被执行。&quot;); &#125; System.out.println(&quot;over&quot;); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 异常注意事项 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 当多异常处理时，捕获处理，前边的类不能是后边类的父类 在try&#x2F;catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。 自定义异常为什么需要自定义异常类: Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类.自定义一个业务逻辑异常: LoginException。一个登陆异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。","tags":["Java","异常处理"],"categories":["JavaSE"]},{"title":"(五). 渐入佳境 - 常用集合","path":"/javaSE-Collections.html","content":"Collection集合概述集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有什么区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储任意类型数据。集合存储的都是引用数据类型。如果想存储基本类型数据需要存储对应的包装类型。 继承体系Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.LinkedHashSet。 常用APICollection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(Object obj): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中 Iterator迭代器 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(&quot;串串星人&quot;); coll.add(&quot;吐槽星人&quot;); coll.add(&quot;汪星人&quot;); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips: 在进行集合元素获取时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会抛出java.util.NoSuchElementException没有集合元素异常。 在进行集合元素获取时，如果添加或移除集合中的元素 , 将无法继续迭代 , 将会抛出ConcurrentModificationException并发修改异常. 实现原理我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 List接口java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。 LinkedList集合java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。 public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class Demo04LinkedList &#123;\tpublic static void main(String[] args) &#123; method4();\t&#125;\t/* * void push(E e)： 压入。把元素添加到集合的第一个位置。 * E pop()： 弹出。把第一个元素删除，然后返回这个元素。 */\tpublic static void method4() &#123; //创建LinkedList对象 LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加元素 list.add(&quot;达尔文&quot;); list.add(&quot;达芬奇&quot;); list.add(&quot;达尔优&quot;); System.out.println(&quot;list:&quot; + list); //调用push在集合的第一个位置添加元素 //list.push(&quot;爱迪生&quot;); //System.out.println(&quot;list:&quot; + list);//[爱迪生, 达尔文, 达芬奇, 达尔优] //E pop()： 弹出。把第一个元素删除，然后返回这个元素。 String value = list.pop(); System.out.println(&quot;value:&quot; + value);//达尔文 System.out.println(&quot;list:&quot; + list);//[达芬奇，达尔优]\t&#125; /* * E removeFirst()：删除第一个元素 * E removeLast()：删除最后一个元素。 */\tpublic static void method3() &#123; //创建LinkedList对象 LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加元素 list.add(&quot;达尔文&quot;); list.add(&quot;达芬奇&quot;); list.add(&quot;达尔优&quot;); //删除集合的第一个元素// String value = list.removeFirst();// System.out.println(&quot;value:&quot; + value);//达尔文// System.out.println(&quot;list:&quot; + list);//[达芬奇，达尔优] //删除最后一个元素 String value = list.removeLast(); System.out.println(&quot;value:&quot; + value);//达尔优 System.out.println(&quot;list:&quot; + list);//[达尔文， 达芬奇]\t&#125; /* * E getFirst()： 获取集合中的第一个元素 * E getLast()： 获取集合中的最后一个元素 */\tpublic static void method2() &#123; //创建LinkedList对象 LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加元素 list.add(&quot;达尔文&quot;); list.add(&quot;达芬奇&quot;); list.add(&quot;达尔优&quot;); System.out.println(&quot;list:&quot; + list); //获取集合中的第一个元素 System.out.println(&quot;第一个元素是：&quot; + list.getFirst()); //获取集合中的最后一个元素怒 System.out.println(&quot;最后一个元素是：&quot; + list.getLast());\t&#125; /* * void addFirst(E e)： 在集合的开头位置添加元素。 * void addLast(E e)： 在集合的尾部添加元素。 */\tpublic static void method1() &#123; //创建LinkedList对象 LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加元素 list.add(&quot;达尔文&quot;); list.add(&quot;达芬奇&quot;); list.add(&quot;达尔优&quot;); //打印这个集合 System.out.println(&quot;list:&quot; + list);//[达尔文, 达芬奇, 达尔优] //调用addFirst添加元素 list.addFirst(&quot;曹操&quot;); System.out.println(&quot;list:&quot; + list);//[曹操, 达尔文, 达芬奇, 达尔优] //调用addLast方法添加元素 list.addLast(&quot;大乔&quot;); System.out.println(&quot;list:&quot; + list);//[曹操, 达尔文, 达芬奇, 达尔优, 大乔] &#125;&#125; Set接口java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。与List接口不同的是，Set接口都会以某种规则保证存入的元素不出现重复。 Set集合有多个子类，这里我们介绍其中的java.util.HashSet、java.util.LinkedHashSet、java.util.TreeSet这两个集合。 HashSet概述java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不能保证不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持，由于我们暂时还未学习，先做了解。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存储和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 我们先来使用一下Set集合存储，看下现象，再进行原理的讲解: 12345678910111213141516171819202122public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建 Set集合 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(new String(&quot;cba&quot;)); set.add(&quot;abc&quot;); set.add(&quot;bac&quot;); set.add(&quot;cba&quot;); //遍历 for (String name : set) &#123; /* 说明集合中不能存储重复元素 cba abc bac */ System.out.println(name); &#125; &#125;&#125; 哈希表什么是哈希表呢？ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用数组处理冲突，同一hash值的链表都存储在一个数组里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的 JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一. 创建自定义Student类: 123456789101112131415161718192021public class Student &#123; private String name; private int age;\t//get/set @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 创建测试类: 123456789101112131415161718192021public class HashSetDemo2 &#123; public static void main(String[] args) &#123; //创建集合对象 该集合中存储 Student类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); //存储 Student stu = new Student(&quot;于谦&quot;, 43); stuSet.add(stu); stuSet.add(new Student(&quot;郭德纲&quot;, 44)); stuSet.add(new Student(&quot;于谦&quot;, 43)); stuSet.add(new Student(&quot;郭麒麟&quot;, 23)); stuSet.add(stu); for (Student stu2 : stuSet) &#123; System.out.println(stu2); &#125; &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23] LinkedHashSet我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？ 在HashSet下面有一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo &#123;\tpublic static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(&quot;bbb&quot;); set.add(&quot;aaa&quot;); set.add(&quot;abc&quot;); set.add(&quot;bbc&quot;); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125;\t&#125;&#125;结果： bbb aaa abc bbc TreeSet集合特点TreeSet集合是Set接口的一个实现类,底层依赖于TreeMap,是一种基于红黑树的实现,其特点为： 元素唯一 元素没有索引 使用元素的自然顺序对元素进行排序，或者根据创建 TreeSet 时提供的 Comparator 比较器进行排序，具体取决于使用的构造方法： public TreeSet()： 根据其元素的自然排序进行排序public TreeSet(Comparator&lt;E&gt; comparator): 根据指定的比较器进行排序 演示演示自然排序(20,18,23,22,17,24,19): 123456789101112131415public static void main(String[] args) &#123;\t//无参构造,默认使用元素的自然顺序进行排序\tTreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;();\tset.add(20);\tset.add(18); set.add(23); set.add(22); set.add(17); set.add(24); set.add(19); System.out.println(set);&#125;控制台的输出结果为:[17, 18, 19, 20, 22, 23, 24] 演示比较器排序(20,18,23,22,17,24,19): 12345678910111213141516171819202122public static void main(String[] args) &#123; //有参构造,传入比较器,使用比较器对元素进行排序 TreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; //元素前 - 元素后 : 升序 //元素后 - 元素前 : 降序 return o2 - o1; &#125; &#125;); set.add(20); set.add(18); set.add(23); set.add(22); set.add(17); set.add(24); set.add(19); System.out.println(set);&#125;控制台的输出结果为:[24, 23, 22, 20, 19, 18, 17] Collections类常用功能 java.utils.Collections是集合工具类，用来对集合进行操作。 常用方法如下： public static void shuffle(List&lt;?&gt; list) :打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 代码演示： 123456789101112131415public class CollectionsDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(100); list.add(300); list.add(200); list.add(50); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125;结果：[50,100, 200, 300] 我们的集合按照默认的自然顺序进行了排列，如果想要指定顺序那该怎么办呢？ 比较器123456789101112131415161718192021222324public class Demo &#123; public static void main(String[] args) &#123; // 创建四个学生对象 存储到集合中 ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); list.add(new Student(&quot;rose&quot;,18)); list.add(new Student(&quot;jack&quot;,16)); list.add(new Student(&quot;abc&quot;,20)); Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getAge()-o2.getAge();//以学生的年龄升序 &#125; &#125;); for (Student student : list) &#123; System.out.println(student); &#125; &#125;&#125;Student&#123;name=&#x27;jack&#x27;, age=16&#125;Student&#123;name=&#x27;rose&#x27;, age=18&#125;Student&#123;name=&#x27;abc&#x27;, age=20&#125; 可变参数在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化. 格式： 修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 代码演示: 1234567891011121314 public class ChangeArgs &#123; public static void main(String[] args) &#123; int sum = getSum(6, 7, 2, 12, 2121); System.out.println(sum); &#125; public static int getSum(int... arr) &#123; int sum = 0; for (int a : arr) &#123; sum += a; &#125; return sum; &#125;&#125; 注意：​ 一个方法只能有一个可变参数 如果方法中有多个参数，可变参数要放到最后。 Map集合概述现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即java.util.Map接口。 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 常用子类通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 **HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 **LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 TreeMap&lt;K,V&gt;：TreeMap集合和Map相比没有特有的功能，底层的数据结构是红黑树；可以对元素的键进行排序，排序方式有两种:自然排序和比较器排序** tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 public boolean containKey(Object key):判断该集合中是否有此键。 Map接口的方法演示 1234567891011121314151617181920public class MapDemo &#123; public static void main(String[] args) &#123; //创建 map对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素到集合 map.put(&quot;黄晓明&quot;, &quot;杨颖&quot;); map.put(&quot;文章&quot;, &quot;马伊琍&quot;); map.put(&quot;邓超&quot;, &quot;孙俪&quot;); System.out.println(map); //String remove(String key) System.out.println(map.remove(&quot;邓超&quot;)); System.out.println(map); // 想要查看 黄晓明的媳妇 是谁 System.out.println(map.get(&quot;黄晓明&quot;)); System.out.println(map.get(&quot;邓超&quot;)); &#125;&#125; tips: 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 遍历键找值通过元素中的键，获取键所对应的值 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 键值对即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 Entry键值对对象: 我们已经知道，Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 获取了Entry对象 , 表示获取了一对键和值，那么同样Entry中 , 分别提供了获取键和获取值的方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。 自定义类型每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。 注意，学生姓名相同并且年龄相同视为同一名学生。 编写学生类： 123456789101112131415161718192021public class Student &#123; private String name; private int age; //构造方法 //get/set @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 编写测试类： 1234567891011121314151617public class HashMapTest &#123; public static void main(String[] args) &#123; //1,创建Hashmap集合对象。 Map&lt;Student,String&gt; map = new HashMap&lt;Student,String&gt;(); //2,添加元素。 map.put(new Student(&quot;lisi&quot;,28), &quot;上海&quot;); map.put(new Student(&quot;wangwu&quot;,22), &quot;北京&quot;); map.put(new Student(&quot;wangwu&quot;,22), &quot;南京&quot;); //3,取出元素。键找值方式 Set&lt;Student&gt; keySet = map.keySet(); for(Student key: keySet)&#123; String value = map.get(key); System.out.println(key.toString()+&quot;.....&quot;+value); &#125; &#125;&#125; 当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。 如果要保证map中存放的key和取出的顺序一致，可以使用java.util.LinkedHashMap集合来存放。 LinkedHashMap我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。 123456789101112public class LinkedHashMapDemo &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;(); map.put(&quot;邓超&quot;, &quot;孙俪&quot;); map.put(&quot;李晨&quot;, &quot;范冰冰&quot;); map.put(&quot;刘德华&quot;, &quot;朱丽倩&quot;); Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;String, String&gt; entry : entrySet) &#123; System.out.println(entry.getKey() + &quot; &quot; + entry.getValue()); &#125; &#125;&#125; 结果: 邓超 孙俪李晨 范冰冰刘德华 朱丽倩 TreeMapTreeMap集合和Map相比没有特有的功能，底层的数据结构是红黑树；可以对元素的键进行排序，排序方式有两种:自然排序和比较器排序；到时使用的是哪种排序，取决于我们在创建对象的时候所使用的构造方法； public TreeMap() 使用自然排序public TreeMap(Comparator&lt;? super K&gt; comparator) 比较器排","tags":["Java","集合"],"categories":["JavaSE"]},{"title":"(四). 渐入佳境 - 常用API","path":"/javaSE-APIs.html","content":"Object类概述java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类，\t那么默认则继承自Object类。例如： public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 toString方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。如下图所示： 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name;\tprivate int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： Objects类Objects类是对象工具类，它里面的的方法都是用来操作对象的。 equals方法在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 我们可以查看一下源码，学习一下： public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); isNullstatic boolean isNull(Object obj) 判断对象是否为null，如果为null返回true。 123456Student s1 = null;Student s2 = new Student(&quot;蔡徐坤&quot;, 22);// static boolean isNull(Object obj) 判断对象是否为null,如果为null返回trueSystem.out.println(Objects.isNull(s1)); // trueSystem.out.println(Objects.isNull(s2)); // false Date类Date概述java.util.Date&#96;类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，我们重点看以下两个构造函数 public Date()：从运行程序的此时此刻到时间原点经历的毫秒值,转换成Date对象，分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：将指定参数的毫秒值date,转换成Date对象，分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于中国处于东八区（GMT+08:00）是比世界协调时间&#x2F;格林尼治时间（GMT）快8小时的时区，当格林尼治标准时间为0:00时，东八区的标准时间为08:00。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2020 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 Date常用方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 public void setTime(long time) 把方法参数给定的毫秒值设置给日期对象 示例代码 1234567891011121314151617public class DateDemo02 &#123; public static void main(String[] args) &#123; //创建日期对象 Date d = new Date(); //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 //System.out.println(d.getTime()); //System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + &quot;年&quot;); //public void setTime(long time):设置时间，给的是毫秒值 //long time = 1000*60*60; long time = System.currentTimeMillis(); d.setTime(time); System.out.println(d); &#125;&#125; 小结：Date表示特定的时间瞬间，我们可以使用Date对象对时间进行操作。 DateFormat类java.text.DateFormat 是日期&#x2F;时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，把Date对象转换为String对象。 解析：按照指定的格式，把String对象转换为Date对象。 构造方法由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 1234567891011121314151617public class SimpleDateFormatDemo &#123; public static void main(String[] args) throws ParseException &#123; //格式化：从 Date 到 String Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String s = sdf.format(d); System.out.println(s); System.out.println(&quot;--------&quot;); //从 String 到 Date String ss = &quot;2048-08-09 11:11:11&quot;; //ParseException SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date dd = sdf2.parse(ss); System.out.println(dd); &#125;&#125; 小结：DateFormat可以将Date对象和字符串相互转换。 Calendar类概述 java.util.Calendar类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：java.util.GregorianCalendar类。 有两种方式可以获取GregorianCalendar对象： 直接创建GregorianCalendar对象； 通过Calendar的静态方法getInstance()方法获取GregorianCalendar对象 常用方法 方法名 说明 public static Calendar getInstance() 获取一个它的子类GregorianCalendar对象。 public int get(int field) 获取某个字段的值。field参数表示获取哪个字段的值，可以使用Calender中定义的常量来表示：Calendar.YEAR : 年Calendar.MONTH ：月Calendar.DAY_OF_MONTH：月中的日期Calendar.HOUR：小时Calendar.MINUTE：分钟Calendar.SECOND：秒Calendar.DAY_OF_WEEK：星期 public void set(int field,int value) 设置某个字段的值 public void add(int field,int amount) 为某个字段增加&#x2F;减少指定的值 get方法12345678910111213141516171819202122232425262728293031323334public class Demo &#123; public static void main(String[] args) &#123; //1.获取一个GregorianCalendar对象 Calendar instance = Calendar.getInstance();//获取子类对象 //2.打印子类对象 System.out.println(instance); //3.获取属性 int year = instance.get(Calendar.YEAR); int month = instance.get(Calendar.MONTH) + 1;//Calendar的月份值是0-11 int day = instance.get(Calendar.DAY_OF_MONTH); int hour = instance.get(Calendar.HOUR); int minute = instance.get(Calendar.MINUTE); int second = instance.get(Calendar.SECOND); int week = instance.get(Calendar.DAY_OF_WEEK);//返回值范围：1--7，分别表示：&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,...,&quot;星期六&quot; System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + second); System.out.println(getWeek(week)); &#125; //查表法，查询星期几 public static String getWeek(int w) &#123;//w = 1 --- 7 //做一个表(数组) String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;; // 索引 [0] [1] [2] [3] [4] [5] [6] //查表 return weekArray[w - 1]; &#125;&#125; set方法123456789101112131415161718192021222324public class Demo &#123; public static void main(String[] args) &#123; //设置属性——set(int field,int value): Calendar c1 = Calendar.getInstance();//获取当前日期 //计算班长出生那天是星期几(假如班长出生日期为：1998年3月18日) c1.set(Calendar.YEAR, 1998); c1.set(Calendar.MONTH, 3 - 1);//转换为Calendar内部的月份值 c1.set(Calendar.DAY_OF_MONTH, 18); int w = c1.get(Calendar.DAY_OF_WEEK); System.out.println(&quot;班长出生那天是：&quot; + getWeek(w)); &#125; //查表法，查询星期几 public static String getWeek(int w) &#123;//w = 1 --- 7 //做一个表(数组) String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;; // 索引 [0] [1] [2] [3] [4] [5] [6] //查表 return weekArray[w - 1]; &#125;&#125; add方法1234567891011121314151617181920212223public class Demo &#123; public static void main(String[] args) &#123; //计算200天以后是哪年哪月哪日，星期几？ Calendar c2 = Calendar.getInstance();//获取当前日期 c2.add(Calendar.DAY_OF_MONTH, 200);//日期加200 int y = c2.get(Calendar.YEAR); int m = c2.get(Calendar.MONTH) + 1;//转换为实际的月份 int d = c2.get(Calendar.DAY_OF_MONTH); int wk = c2.get(Calendar.DAY_OF_WEEK); System.out.println(&quot;200天后是：&quot; + y + &quot;年&quot; + m + &quot;月&quot; + d + &quot;日&quot; + getWeek(wk)); &#125; //查表法，查询星期几 public static String getWeek(int w) &#123;//w = 1 --- 7 //做一个表(数组) String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;; // 索引 [0] [1] [2] [3] [4] [5] [6] //查表 return weekArray[w - 1]; &#125;&#125; Math类概述 java.lang.Math(类): Math包含执行基本数字运算的方法。 它不能创建对象，它的构造方法被“私有”了。因为他内部都是“静态方法”，通过“类名”直接调用即可。 常用方法 方法名 说明 public static int abs(int a) 获取参数a的绝对值： public static double ceil(double a) 向上取整 public static double floor(double a) 向下取整 public static double pow(double a, double b) 获取a的b次幂 public static long round(double a) 四舍五入取整 示例1234567891011public class Demo &#123; public static void main(String[] args) &#123; System.out.println(&quot;-5的绝对值：&quot; + Math.abs(-5));//5 System.out.println(&quot;3.4向上取整：&quot; + Math.ceil(3.4));//4.0 System.out.println(&quot;3.4向下取整：&quot; + Math.floor(3.4));//3.0 System.out.println(&quot;2的8次幂：&quot; + Math.pow(2, 8));//256.0 System.out.println(&quot;3.2四舍五入：&quot; + Math.round(3.2));//3 System.out.println(&quot;3.5四舍五入：&quot; + Math.round(3.5));//4 &#125;&#125; System概述java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作。 常用方法 方法名 说明 public static void exit(int status) 终止当前运行的 Java 虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前时间(以毫秒为单位) 示例123456789101112131415import java.util.Date;//验证for循环打印数字1-9999所需要使用的时间（毫秒）public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); //计算程序运行时间 long start = System.currentTimeMillis(); for (int i = 1; i &lt;= 10000; i++) &#123; System.out.println(i); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;共耗时毫秒：&quot; + (end - start)); &#125; &#125; BigDecimal类引入浮点数做运算精度问题； 看程序说结果： 123456public static void main(String[] args) &#123; System.out.println(0.09 + 0.01); System.out.println(1.0 - 0.32); System.out.println(1.015 * 100); System.out.println(1.301 / 100);&#125; 概述 相关内容 具体描述 包 java.math 使用时需要导包 类声明 public class BigDecimal extends Number implements Comparable 描述 BigDecimal类提供了算术，缩放操作，舍入，比较，散列和格式转换的操作。提供了更加精准的数据计算方式 构造方法名 描述 BigDecimal(double val) 将double类型的数据封装为BigDecimal对象 BigDecimal(String val) 将 BigDecimal 的字符串表示形式转换为 BigDecimal 注意：推荐使用第二种方式，第一种存在精度问题； 常用方法BigDecimal类中使用最多的还是提供的进行四则运算的方法，如下： 方法声明 描述 public BigDecimal add(BigDecimal value) 加法运算 public BigDecimal subtract(BigDecimal value) 减法运算 public BigDecimal multiply(BigDecimal value) 乘法运算 public BigDecimal divide(BigDecimal value) 触发运算 注意：对于divide方法来说，如果除不尽的话，就会出现java.lang.ArithmeticException异常。此时可以使用divide方法的另一个重载方法； BigDecimal divide(BigDecimal divisor, int scale, int roundingMode): divisor：除数对应的BigDecimal对象；scale:精确的位数；roundingMode取舍模式 小结：Java中小数运算有可能会有精度问题，如果要解决这种精度问题，可以使用BigDecimal 正则表达式概念及演示 在Java中，我们经常需要验证一些字符串，例如：年龄必须是2位的数字、用户名必须是8位长度而且只能包含大小写字母、数字等。正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则。 先看一个不使用正则表达式验证的例子：下面的程序让用户输入一个QQ号码，我们要验证： QQ号码必须是5–15位长度 而且必须全部是数字 而且首位不能为0 12345678910111213141516171819202122232425262728293031public class Demo &#123;\tpublic static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你的QQ号码：&quot;); String qq = sc.next(); System.out.println(checkQQ(qq));\t&#125;\t//我们自己编写代码，验证QQ号码\tprivate static boolean checkQQ(String qq) &#123; //1.验证5--15位 if(qq.length() &lt; 5 || qq.length() &gt; 15)&#123; return false; &#125; //2.必须都是数字； for(int i = 0;i &lt; qq.length() ; i++)&#123; char c = qq.charAt(i); if(c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;)&#123; return false; &#125; &#125; //3.首位不能是0； char c = qq.charAt(0); if(c == &#x27;0&#x27;)&#123; return false; &#125; return true;//验证通过\t&#125;\t&#125; 使用正则表达式验证： 123456789101112131415public class Demo &#123;\tpublic static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你的QQ号码：&quot;); String qq = sc.next(); System.out.println(checkQQ2(qq));\t&#125;\t//使用正则表达式验证\tprivate static boolean checkQQ2(String qq)&#123; String regex = &quot;[1-9]\\\\d&#123;4,14&#125;&quot;;//正则表达式 return qq.matches(regex);\t&#125;&#125; 上面程序checkQQ2()方法中String类型的变量regex就存储了一个”正则表达式 “，而这个正则表达式就描述了我们需要的三个规则。matches()方法是String类的一个方法，用于接收一个正则表达式，并将”本对象”与参数”正则表达式”进行匹配，如果本对象符合正则表达式的规则，则返回true，否则返回false。 字符类 语法示例： [abc]：代表a或者b，或者c字符中的一个。 [^abc]：代表除a,b,c以外的任何字符。 [a-z]：代表a-z的所有小写字符中的一个。 [A-Z]：代表A-Z的所有大写字符中的一个。 [0-9]：代表0-9之间的某一个数字字符。 [a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。 [a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。 代码示例： 12345678910111213141516171819202122public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;ead&quot;; //1.验证str是否以h开头，以d结尾，中间是a,e,i,o,u中某个字符 String regex = &quot;h[aeiou]d&quot;; System.out.println(&quot;1.&quot; + str.matches(regex)); //2.验证str是否以h开头，以d结尾，中间不是a,e,i,o,u中的某个字符 regex = &quot;h[^aeiou]d&quot;; System.out.println(&quot;2.&quot; + str.matches(regex)); //3.验证str是否a-z的任何一个小写字符开头，后跟ad regex = &quot;[a-z]ad&quot;; System.out.println(&quot;3.&quot; + str.matches(regex)); //4.验证str是否以a-d或者m-p之间某个字符开头，后跟ad regex = &quot;[[a-d][m-p]]ad&quot;; System.out.println(&quot;4.&quot; + str.matches(regex));\t&#125;&#125; 逻辑运算符 语法示例： &amp;&amp;：并且 | ：或者 代码示例： 12345678910111213public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;had&quot;; //1.要求字符串是小写辅音字符开头，后跟ad String regex = &quot;[a-z&amp;&amp;[^aeiou]]ad&quot;; System.out.println(&quot;1.&quot; + str.matches(regex)); //2.要求字符串是aeiou中的某个字符开头，后跟ad regex = &quot;[a|e|i|o|u]ad&quot;;//这种写法相当于：regex = &quot;[aeiou]ad&quot;; System.out.println(&quot;2.&quot; + str.matches(regex));\t&#125;&#125; 预定义字符 语法示例： “.” ： 匹配任何字符。 “\\d”：任何数字[0-9]的简写； “\\D”：任何非数字[^0-9]的简写； “\\s”： 空白字符：[ \\t \\x0B\\f\\r] 的简写 “\\S”： 非空白字符：[^\\s] 的简写 “\\w”：单词字符：[a-zA-Z_0-9]的简写 “\\W”：非单词字符：[^\\w] 代码示例： 12345678910111213141516171819202122232425public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;258&quot;; //1.验证str是否3位数字 String regex = &quot;\\\\d\\\\d\\\\d&quot;; System.out.println(&quot;1.&quot; + str.matches(regex)); //2.验证手机号：1开头，第二位：3/5/8，剩下9位都是0-9的数字 str = &quot;13513153355&quot;;//要验证的字符串 regex = &quot;1[358]\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d&quot;;//正则表达式 System.out.println(&quot;2.&quot; + str.matches(regex)); //3.验证字符串是否以h开头，以d结尾，中间是任何字符 str = &quot;had&quot;;//要验证的字符串 regex = &quot;h.d&quot;;//正则表达式 System.out.println(&quot;3.&quot; + str.matches(regex)); //4.验证str是否是：had. str = &quot;had.&quot;;//要验证的字符串 regex = &quot;had\\\\.&quot;;//\\\\.代表&#x27;.&#x27;符号，因为.在正则中被预定义为&quot;任意字符&quot;，不能直接使用 System.out.println(&quot;4.&quot; + str.matches(regex)); &#125;&#125; 数量词 语法示例： X? : 0次或1次 X* : 0次到多次 X+ : 1次或多次 X{n} : 恰好n次 X{n,} : 至少n次 X{n,m}: n到m次(n和m都是包含的) 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;&quot;; //1.验证str是否是三位数字 str = &quot;012&quot;; String regex = &quot;\\\\d&#123;3&#125;&quot;; System.out.println(&quot;1.&quot; + str.matches(regex)); //2.验证str是否是多位数字 str = &quot;88932054782342&quot;; regex = &quot;\\\\d+&quot;; System.out.println(&quot;2.&quot; + str.matches(regex)); //3.验证str是否是手机号： str = &quot;13813183388&quot;; regex = &quot;1[358]\\\\d&#123;9&#125;&quot;; System.out.println(&quot;3.&quot; + str.matches(regex)); //4.验证小数:必须出现小数点，但是只能出现1次 String s2 = &quot;3.1&quot;; regex = &quot;\\\\d*\\\\.&#123;1&#125;\\\\d+&quot;; System.out.println(&quot;4.&quot; + s2.matches(regex)); //5.验证小数：小数点可以不出现，也可以出现1次 regex = &quot;\\\\d+\\\\.?\\\\d+&quot;; System.out.println(&quot;5.&quot; + s2.matches(regex)); //6.验证小数：要求匹配：3、3.、3.14、+3.14、-3. s2 = &quot;-3.&quot;; regex = &quot;[+-]\\\\d+\\\\.?\\\\d*&quot;; System.out.println(&quot;6.&quot; + s2.matches(regex)); //7.验证qq号码：1).5--15位；2).全部是数字;3).第一位不是0 s2 = &quot;1695827736&quot;; regex = &quot;[1-9]\\\\d&#123;4,14&#125;&quot;; System.out.println(&quot;7.&quot; + s2.matches(regex));\t&#125;&#125; 分组括号( )123456789public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;DG8FV-B9TKY-FRT9J-99899-XPQ4G&quot;; //验证这个序列号：分为5组，每组之间使用-隔开，每组由5位A-Z或者0-9的字符组成 String regex = &quot;([A-Z0-9]&#123;5&#125;-)&#123;4&#125;[A-Z0-9]&#123;5&#125;&quot;; System.out.println(str.matches(regex));\t&#125;&#125; String的split方法 String类的split()方法原型： public String[] split(String regex)//参数regex就是一个正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为&quot;分隔符&quot;来切割字符串。 代码示例： 12345678910public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;18 4 567 99 56&quot;; String[] strArray = str.split(&quot; +&quot;); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.println(strArray[i]); &#125;\t&#125;&#125; String类的replaceAll String类的replaceAll()方法原型： public String replaceAll(String regex,String newStr)//参数regex就是一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。 代码示例： 1234567public class Demo &#123; public static void main(String[] args) &#123; //将下面字符串中的&quot;数字&quot;替换为&quot;*&quot; String str = &quot;jfdk432jfdk2jk24354j47jk5l31324&quot;; System.out.println(str.replaceAll(&quot;\\\\d+&quot;, &quot;*&quot;)); &#125;&#125; 包装类概述Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean Integer类 Integer类概述 包装一个对象中的原始类型 int 的值 Integer类构造方法及静态方法 方法名 说明 public Integer(int value) 根据 int 值创建 Integer 对象(过时) public Integer(String s) 根据 String 值创建 Integer 对象(过时) public static Integer valueOf(int i) 返回表示指定的 int 值的 Integer 实例 public static Integer valueOf(String s) 返回保存指定String值的 Integer 对象 示例代码 123456789101112131415161718192021public class IntegerDemo &#123; public static void main(String[] args) &#123; //public Integer(int value)：根据 int 值创建 Integer 对象(过时) Integer i1 = new Integer(100); System.out.println(i1); //public Integer(String s)：根据 String 值创建 Integer 对象(过时) Integer i2 = new Integer(&quot;100&quot;); //Integer i2 = new Integer(&quot;abc&quot;); //NumberFormatException System.out.println(i2); System.out.println(&quot;--------&quot;); //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例 Integer i3 = Integer.valueOf(100); System.out.println(i3); //public static Integer valueOf(String s)：返回保存指定String值的Integer对象 Integer i4 = Integer.valueOf(&quot;100&quot;); System.out.println(i4); &#125;&#125; 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—-&gt;包装对象 Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 int num = i.intValue(); 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 基本类型与字符串之间的转换基本类型转换为String 转换方式 方式一：直接在数字后加一个空字符串 方式二：通过String类静态方法valueOf() 示例代码 1234567891011121314public class IntegerDemo &#123; public static void main(String[] args) &#123; //int --- String int number = 100; //方式1 String s1 = number + &quot;&quot;; System.out.println(s1); //方式2 //public static String valueOf(int i) String s2 = String.valueOf(number); System.out.println(s2); System.out.println(&quot;--------&quot;); &#125;&#125; String转换成基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 转换方式 方式一：先将字符串数字转成Integer，再调用valueOf()方法 方式二：通过Integer静态方法parseInt()进行转换 示例代码 123456789101112131415public class IntegerDemo &#123; public static void main(String[] args) &#123; //String --- int String s = &quot;100&quot;; //方式1：String --- Integer --- int Integer i = Integer.valueOf(s); //public int intValue() int x = i.intValue(); System.out.println(x); //方式2 //public static int parseInt(String s) int y = Integer.parseInt(s); System.out.println(y); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。 泛型泛型概述在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换 1234567891011121314public class GenericDemo &#123;\tpublic static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add(&quot;abc&quot;); coll.add(&quot;itcast&quot;); coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = coll.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length()); &#125;\t&#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。为什么会发生类型转换异常呢？ 我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。怎么来解决这个问题呢？ Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 好处上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？ 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 通过我们如下代码体验一下： 123456789101112131415public class GenericDemo2 &#123;\tpublic static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;abc&quot;); list.add(&quot;itcast&quot;); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125;\t&#125;&#125; tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 定义与使用我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类定义格式： 修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 泛型在定义的时候不具体，使用的时候才变得具体。在使用的时候确定泛型的具体数据类型。 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125; 含有泛型的方法定义格式： 修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125; 调用方法时，确定泛型的类型 12345678910public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(&quot;aaa&quot;); mm.show(123); mm.show(12.45); &#125;&#125; 含有泛型的接口定义格式： 修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， public interface MyGenericInterface&lt;E&gt;&#123;\tpublic abstract void add(E e); public abstract E getE(); &#125; 使用格式： 1、定义类时确定泛型的类型 例如 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123;\t@Override public void add(String e) &#123; // 省略... &#125;\t@Override\tpublic String getE() &#123; return null;\t&#125;&#125; 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123;\t@Override\tpublic void add(E e) &#123; // 省略...\t&#125;\t@Override\tpublic E getE() &#123; return null;\t&#125;&#125; 确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(&quot;aa&quot;); &#125;&#125; 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 123456789public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;// ？代表可以接收任意类型泛型不存在继承关系 Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种是错误的 通配符高级使用之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;","tags":["Java"],"categories":["JavaSE"]},{"title":"(三). 渐入佳境 - 重学多态","path":"/javaSE-Polymorphism.html","content":"多态形式多态是继封装、继承之后，面向对象的第三大特性。多态是出现在继承或者实现关系中的。 多态体现的格式： 父类类型 变量名 = new 子类/实现类构造器;变量名.方法名(); 多态的前提：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。 示例当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。如果子类没有重写该方法，就会调用父类的该方法。 总结起来就是：编译看左边，运行看右边。 代码如下： 定义父类： public class Animal &#123; public void eat()｛ System.out.println(&quot;动物吃东西！&quot;) ｝&#125; 定义子类： 1234567891011class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; &#125; 定义测试类： 12345678910111213public class Test &#123; public static void main(String[] args) &#123; // 多态形式，创建对象 Animal a1 = new Cat(); // 调用的是 Cat 的 eat a1.eat(); // 多态形式，创建对象 Animal a2 = new Dog(); // 调用的是 Dog 的 eat a2.eat(); &#125; &#125; 定义多态： 是指同一行为，具有多个不同表现形式。 从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。 前提【重点】 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 优缺点好处实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下： 定义父类： public abstract class Animal &#123; public abstract void eat(); &#125; 定义子类： 1234567891011class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; &#125; 定义测试类： 12345678910111213141516171819202122232425262728293031public class Test &#123; public static void main(String[] args) &#123; // 多态形式，创建对象 Cat c = new Cat(); Dog d = new Dog(); // 调用showCatEat showCatEat(c); // 调用showDogEat showDogEat(d); /* 以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代 而执行效果一致 */ showAnimalEat(c); showAnimalEat(d); &#125; public static void showCatEat (Cat c)&#123; c.eat(); &#125; public static void showDogEat (Dog d)&#123; d.eat(); &#125; public static void showAnimalEat (Animal a)&#123; a.eat(); &#125;&#125; 由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。 当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。 不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。从而实现了实现类的自动切换。 所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。 弊端我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时多态的写法就无法访问子类独有功能了。 12345678910111213141516171819202122232425262728class Animal&#123; public void eat()｛ System.out.println(&quot;动物吃东西！&quot;) ｝&#125;class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse() &#123; System.out.println(&quot;抓老鼠&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; &#125;class Test&#123; public static void main(String[] args)&#123; Animal a = new Cat(); a.eat(); a.catchMouse();//编译报错，编译看左边，Animal没有这个方法 &#125;&#125; 引用类型转换为什么要转型多态的写法就无法访问子类独有功能了。 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 回顾基本数据类型转换 自动转换: 范围小的赋值给范围大的.自动完成:double d &#x3D; 5; 强制转换: 范围大的赋值给范围小的,强制转换:int i &#x3D; (int)3.14 ​ 多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。 向上转型（自动转换） 向上转型：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型。使用格式： 父类类型 变量名 = new 子类类型();如：Animal a = new Cat(); 原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。所以子类范围小可以直接自动转型给父类类型的变量。 向下转型（强制转换） 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 使用格式： 子类类型 变量名 = (子类类型) 父类变量名;如:Aniaml a = new Cat(); Cat c =(Cat) a; 转型的异常转型的过程中，一不小心就会遇到这样的问题，请看如下代码： 1234567891011public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse 【运行报错】 &#125; &#125; 这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。 instanceof关键字为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下： 变量名 instanceof 数据类型 如果变量属于该数据类型或者其子类类型，返回true。如果变量不属于该数据类型或者其子类类型，返回false。 所以，转换前，我们最好先做一个判断，代码如下： 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 if (a instanceof Cat)&#123; Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125; else if (a instanceof Dog)&#123; Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse &#125; &#125; &#125; 内部类概述什么是内部类将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。可以把内部类理解成寄生，外部类理解成宿主。 内部类是Java类的五大成份之一，也是我们最后一个需要学习的成份。 一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用 人里面有一颗心脏。 汽车内部有一个发动机。 为了实现更好的封装性。 分类按定义的位置来分 静态内部类，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类) 实例内部内，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类) 局部内部类，类定义在方法内 匿名内部类。一般定义在方法中，或者可执行代码中 静态内部类静态内部类特点： 有static修饰的内部类，属于外部类本身的。 总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。 拓展:静态内部类可以直接访问外部类的静态成员。 内部类的使用格式： 外部类.内部类。 静态内部类对象的创建格式： 外部类.内部类 变量 = new 外部类.内部类构造器; 实例内部类实例内部类特点： 无static修饰的内部类，属于外部类对象的。 宿主：外部类对象。 内部类的使用格式： 外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类 实例内部类创建对象格式： 外部类.内部类 变量 = new 外部类构造器.new 内部类构造器; 拓展1：实例内部类不能定义静态成员。 拓展2：实例内部类可以直接访问外部类的私有和静态成员。 局部内部类 局部内部类 ：定义在方法中的类。 定义格式: 1234567891011class 外部类名 &#123;\t数据类型 变量名; 修饰符 返回值类型 方法名(参数列表) &#123; // … class 内部类 &#123; // 成员变量 // 成员方法 &#125;\t&#125;&#125; 局部内部类编译后仍然是一个独立的类，编译后有$还有一个数字。Chinese$1Chopsticks.class 匿名内部类匿名内部类 ：是内部类的简化写法。它的本质是一个带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。 实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用 是为了简化代码。 之前我們使用接口时，似乎得做如下几步操作： 定义子类 重写接口中的方法 创建子类对象 调用重写后的方法 123456789101112131415161718192021interface Swim &#123; public abstract void swimming();&#125;// 1. 定义接口的实现类class Student implements Swim &#123; // 2. 重写抽象方法 @Override public void swimming() &#123; System.out.println(&quot;狗刨式...&quot;); &#125;&#125;public class Demo07 &#123; public static void main(String[] args) &#123; // 3. 创建实现类对象 Student s = new Student(); // 4. 调用方法 s.swimming(); &#125;&#125; 我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。 匿名内部类必须继承一个父类或者实现一个父接口。 匿名内部类格式 1234567new 父类名或者接口名()&#123; // 方法重写 @Override public void method() &#123; // 执行语句 &#125;&#125;; 定义一个没有名字的内部类 这个类实现了父类，或者父类接口 匿名内部类会创建这个没有名字的类的对象 包和权限修饰符包包我们每天建的项目就是在一个目录下，我们每次都会建立一个包，这个包在磁盘下其实就是一个目录。包是用来分门别类的管理技术，不同的技术类放在不同的包下，方便管理和维护。 包名的命名规范： 路径名.路径名.xxx.xxx// 例如：com.huzhiha.oa 包名一般是公司域名的倒写。 包名必须用”.“连接。 包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。 权限修饰符在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和缺省（default默认）修饰符的作用。 public：公共的，所有地方都可以访问。 protected：当前类 ，当前包，当前类的子类可以访问。 缺省（没有修饰符）：当前类 ，当前包可以访问。 private：私有的，当前类可以访问。public &gt; protected &gt; 缺省 &gt; private public protected 缺省（空的） private 同一类中 √ √ √ √ 同一包中的类 √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 可见，public具有最大权限。private则是最小权限。 编写代码时，如果没有特殊的考虑，建议这样使用权限： 成员变量使用private ，隐藏细节。 构造方法使用 public ，方便创建对象。 成员方法使用public ，方便调用方法。 小贴士：不加权限修饰符，就是default权限","tags":["Java","OOP"],"categories":["JavaSE"]},{"title":"(二). 基础入门 - Java面向对象","path":"/javaSE-OOP.html","content":"面向对象编程顾名思义，面向对象，你得首先有个对象，有了对象后，就可以和对象进行互动，所以面向对象编程是通过对象的方式，把现实世界映射到计算机模型的一种编程方法；与面向对象编程相反的是面向过程编程，是把模型分解成一步一步的过程 面向对象基础现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance） 先仔细看看这简单的段代码吧~ 相信在此框架下，后面学起来更轻松~ 123456789101112131415161718192021222324252627282930313233// 定义了一个人类public class person&#123; //成员变量 String name; //名字 int age; // 年龄 //无参构造方法 public person()&#123;&#125; //含参数构造方法 public person(String name,int age)&#123; this.name = name; this.age = age; &#125; //成员方法 public void eat()&#123; System.out.println(this.name+&quot;在&quot;+this.age+&quot;岁就已经学会干饭了&quot;); &#125; public static void main(String[] args)&#123; //无参实例化 person p1 = new person(); p1.name = &quot;小红&quot;; p1.age = 18; //调用eat方法 p1.eat(); // 含参实例化 person p2 = new person(&quot;小明&quot;,80); //调用eat方法 p2.eat(); &#125; &#125; 1、 类class 是一种对象模版，它定义了如何创建实例，因此，class 本身就是一种数据类型 定义 class在 Java 中，创建一个类，例如，给这个类命名为Person，就是定义一个class： class Person &#123; public String name; public int age;&#125; 一个class可以包含多个字段（field），字段用来描述一个类的特征，通过 class 把一组数据汇集到一个对象上，实现了数据封装 2、 实例instance 是根据 class 创建的实例，可以创建多个 instance，每个 instance 类型相同，但各自属性可能不相同 创建实例new 操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例，所以是引用变量ming指向实例new Person(),可以通过这个变量来操作实例 Person ming = new Person(); 不同的实例在内存中对应位置不一样哦~ 3、this 关键字在调用方法的时候，java 会自动的把对象传递给方法， 在方法中由this来接收对象，就和开始所示代码一样；变量的查找顺序: 先找自己方法内。如果自己没有，就去this里面找 this:当前类的对象 this 可以在方法内部获取到对象中的属性信息 this 还可以区分局部变量和成员变量 4、方法访问权限 public 公共的.所有人都可访问 default 包访问权限.在自己包内可以随意访问. private 私有的. get set方法引入开始已经说了字段field可以用来用来描述一个类的特征，但是直接把field用public暴露给外部可能会破坏封装性。比如： 12345678910//定义person类class Person &#123; public String name; public int age;&#125;//实例化Person ming = new Person();ming.name = &quot;Xiao Ming&quot;;ming.age = -99; // age可以设置为负数 怎么办？使用private（私有） 字段 class Person &#123; private String name; private int age;&#125; private修饰field，就避免外部代码直接去访问field，那我们要怎么使用这些dield呢？ 我们需要方法（method） 来从外部代码间接修改field的值，比如我们使用使用外部方法getName来间接获取private字段的值，再使用setName来检查传入的参数对不对，从而达到筛选的效果 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; //实例化调用 Person ming = new Person(); ming.setName(&quot;Xiao Ming&quot;); // 设置name ming.setAge(12); // 设置age System.out.println(ming.getName() + &quot;, &quot; + ming.getAge()); &#125;&#125;//定义类class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125;// 在这里我们就筛选出了不能传入name为空的字符串， public void setName(String name) &#123; if (name==null) &#123; //抛出非法或者不合适的这个异常 throw new IllegalArgumentException(&quot;invalid name&quot;); &#125; //返回方法值 this.name = name; &#125; 同理 age 也可以如此操作，需要注意的是，这个方法相当于被封装在 person 类里，通过一个类定义方法，就可以给外部暴露一些操作的接口的同时保证自己内部类的统一，我们可以在外部使用实例变量.方法名(参数); 来进行调用 看起来可能会有点麻烦，因为一个成员变量就要两个方法，所以在我们的 idea 中可以快捷生成get set 方法 : 空白位置-&gt;右键-&gt; generate -&gt; getter and setter-&gt;全选-&gt; Ok. 构造方法指的是在创建对象的时候，类自动调用的方法.语法:public 类名(传参){}注意: 没有返回值这一项 在我们 new 的时候.自动调用构造方法作用: 在创建对象的时候.给对象设置属性信息. java 会默认自动的送给每一个类一个无参构造方法 构造方法的重载构造方法也是方法，也可以进行重载。 作用: 可以又更多的方式去创建对象；可以使用 this 可以访问其他的构造方法 this() 成员方法定义方法的语法是： 修饰符 方法返回类型 方法名(方法参数列表) &#123; 若干方法语句; return 方法返回值;&#125; 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return 同样的我们既然有private字段那么也就有private方法，并且private方法不允许外部调用，但是我们可以在 privet 内部调用private方法 1234567891011121314151617class Person &#123; private String name; private int birth; public void setBirth(int birth) &#123; this.birth = birth; &#125; public int getAge() &#123; return calcAge(2019); // 调用private方法 &#125; // private方法: private int calcAge(int currentYear) &#123; return currentYear - this.birth; &#125;&#125; 5、静态在一个class中定义的字段，我们称之为实例字段，用static修饰的字段，称为静态字段：static field，实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间” 123456class Person &#123; public String name; public int age; // 定义静态字段number: public static int number;&#125; 可以有两者办法使用静态 12345678//直接通过实例变量访问静态对象//所有实例的静态字段都被修改了，原因是静态字段并不属于实例 hong.number = 99; System.out.println(ming.number); //通过类名访问静态变量Person.number = 99;System.out.println(Person.number); 但是不推荐用 实例变量.静态字段 去访问静态字段， 因为在 Java 程序中，实例对象并没有静态字段 ；实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为 类名.静态字段 来访问静态对象。所以推荐用类名来访问静态字段。 因为静态对象会比实例对象更先加载，就和司马迁不能给你编写历史，但是你可以给司马迁编写历史一样：不能够用 this 去访问实例对象，不能在静态方法里调用非静态方法，可以在静态方法里调用静态方法，也可以用类名来调用静态方法 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Person.setNumber(99); System.out.println(Person.number); &#125;&#125;class Person &#123; public static int number; public static void setNumber(int value) &#123; number = value; &#125;&#125; 特点: . 数据共享 (要变一起变) 属于类的，并不属于对象 优先于对象产生的 6、包和导包包:其实本质上就是文件夹，在代码中需要写 package+包名; 例如： 导包:import 包+类; 不同包之间需要进行导包才能互相访问 不需要导包: 在自己包里 java.lang 包 下的所有内容都不需要导包 比如： StringSystem.out.println0 7、继承继承:子类可以自动拥有父类中除了私有内容外的其他所有内容. 当出现 x 是一种 y 的时候. x 就可以继承 y，换句话说就是动物都会叫，猴子是动物，猴子继承了动物会叫的功能，所以猴子会叫 public class类extends父类&#123;&#125; 作用: 简化代码的开发. 子类对父类进行了扩展. 如果父类和子类存在相同属性，子类是如何继承的呢？ 使用super关键字调用父类，使用this关键字调用自己类，在调用变量时this关键字是先找自己类，再找父类； 父类： 123456public class Hero &#123; String name = &quot;英雄&quot; public fulei()&#123; System. out. print ln(&quot;我是父类的构造方法&quot;); &#125;&#125; 子类： 1234567891011121314151617public class SunWuKong extends Hero &#123; String name = &quot;孙大圣&quot;; public SunWuKong( ) &#123; super(); // 还原程序，在子 类构造方法的第一行，默认调用父类的构造方法 System. out. print ln(&quot;我是子类的构造方法&quot; );&#125; public void chi( )&#123; //想看到父类中的name System.out. print Ln(super.name) ; //先找自己类，然后找父类 System. out. println( this.name+&quot;在吃桃子&quot;) ;&#125; public static void main(String[] args) &#123; SunWuKong S = new SunWuKong( ) ; S.chi() ; &#125;&#125; 调用方法时一般默认在子类的第一个构造方法里最先使用super()调用父类的**无参构造方法，所以可以不写super()调用父类的无参构造方法，但是对于含参构造方**法，就需要在子类中使用super(参数)调用父类的含参构造方法，不然就会报错 那如果子类不满意继承来的方法怎么办呢？ 8、重写方法的重写，也即是子类对父类中提供的方法进行重新定义 语法: 子类和父类中的方法的声明完全一致，重写又被称为方法的覆盖； 如果子类想在重写的方法中使用父类原本的方法仍然可以使用super.方法名()的形式去调用，这种既重写了方法又调用了原方法叫做半盖 上面就是 toString 方法的重写 9、多态多态:同一个对象拥有多种形态 举个例子： 假如有三个动物，猫、狗、鸡，猫吃鱼、狗啃骨头、鸡啄米，现在有一个人，这个人要在早晨去喂这三个动物，应该怎么写呢？ 因为多态比较难一点所以就写详细一点 动物： public class Animal &#123; public void eat()&#123; System.out.println(&quot;动物会进食&quot;); &#125;&#125; 猫： public class Cat extends Animal &#123; public void eat()&#123; System.out.println(&quot;猫吃鱼&quot;); &#125;&#125; 狗： 123456public class Dog extends Animal &#123; public void eat()&#123; System.out.println(&quot;狗啃骨头&quot;); &#125;&#125; 鸡： 123456789public class Chicken extends Animal &#123; public void eat()&#123; System.out.println(&quot;鸡啄米&quot;); &#125; public void dance()&#123; System.out.println(&quot;练习时常两年半的舞蹈鸡&quot;);&#125;&#125; 人： 123456public class Person &#123; public void feedanimal(Animal ain)&#123; System.out.print(&quot;人在喂&quot;); ain.eat(); &#125;&#125; 场景： 123456789101112131415161718192021public class Scenario &#123; public static void main(String[] args) &#123; // 实例化 向上转型 Animal ain1 = new Cat(); Animal ain2 = new Chicken(); Animal ain3 = new Dog(); Person p = new Person(); System.out.println(&quot;在一个早晨&quot;); p.feedanimal(ain1); p.feedanimal(ain2); p.feedanimal(ain3); /* 在早晨 人在喂猫吃鱼 人在喂鸡啄米 人在喂狗啃骨头 */ &#125;&#125; 可以看出人在喂的时候只喂了动物，而不是把猫狗鸡都一个一个挨着喂，是因为猫狗鸡和动物有一个继承关系，并且我们在实例化的时候把子类对象赋值给了父类变量，相对于把子类们都统一到了父类里，其实这就是多态的体现，我们把这叫做向上转型 ，但是不难看出，鸡还有跳舞的功能被屏蔽了， 因为向上转型会屏蔽掉子类不同于父类的方法 有向上转型就有向下转型，我们把父类的变量转化回子类的变量就叫做向下转型，向下转型有可能有风险. java 要求必须要写强制类型转换(转换之后的数据类型)变量 12345678910111213public class Scenario &#123; public static void main(String[] args) &#123; Animal ain2 = new Chicken(); Chicken c = (Chicken) ain2; c.dance(); c.eat(); /* 练习时常两年半的舞蹈鸡 鸡啄米 */ &#125;&#125; 10、final 被final 修饰的变量不可以被改变，又被称为常量 被final修饰的方法不可以被重写. 被final修饰的类不可以被继承. 11、抽象只声明，不实现，可以有正常的方法 抽象方法:使用 abstract 来修饰，不可以有方法体，直接用分号结束即可； 抽象类:如果一个类中有抽象方法，这个类必须是一一个抽象类； 特点: 抽象类不可以创建对象； 抽象类的子类，必须重写父类中的抽象方法.否则,子类必须也是抽象类； 通过抽象类可以强制的要求子类中必须有哪些方法.； 12、接口特殊的抽象类：所有的方法都是抽象方法,用 interface 来声明 接口中所有的方法都是抽象方法。可以省略掉abstract； 接口中所有的内容都是公开的。公共的； 接口中所有的变量都是全局静态常量 public static final ； 能继承接口的只能是接口； 接口和类只能是实现关系implepents； 接口也具有多态性，也就是 接口可以把很多不相关的内容进行整合； 类只能单继承，接口支持多实现，也就是类可以继承一个类，实现多个接口； 13、成员变量初始值 java 中所有的变量必须先声明，后赋值才能使用 I java 中的成员变量，在创建对象的时候，都会执行一次初始化操作.都会给一个默认值. 基本数据类型默认值都是 0 包括 boolean -&gt; false 引用数据类型: null，null 表示空,什么都没有.占位. 14、toString默认的 toString() -&gt;包+ 类@内存地址 1234567891011121314151617package com.xyq.entity;public class Cat &#123;\t//类默认继承Object\tString name;\tString color ;\tpublic Cat(String name, String color)&#123; this.name = name; this.color = color;\t&#125;\tpublic static void main(String[] args) &#123; Cat C = new Cat( name:&quot;小花&quot;， color: &quot;绿色&quot;); //直接打印这个 System.out.println(c) ; //输出 com.xyq.entity.Cat@47d384ee //默认打印对象，自动的执行这个对象中的toString( )方法 System.out.println(c.toString()) ; //也输出 com.xyq.entity.Cat@47d384ee &#125;&#125; 很明显我们对父类 Stirng 里的 toString 方法并不满意，那么我们可以重写这个方法(上面有) 15、instanceof判断 xxx 对象是否是 xxx 类型的 1234567891011public class Cat extends Anima 1 &#123;\tpublic static void main(String[] args) &#123; Animal ani = new Animal( ) ; if(ani instanceof Cat)&#123; System. ou.println(&quot;是一只猫。撸一撸&quot;); &#125; else &#123; System. out.pr intln(&quot;不是一只猫&quot;); &#125;\t&#125;&#125; 16、内存分析 堆：主要存放对象. 栈：局部变量，以及基本数据类型的变量. 代码区：类和方法 数据区：常量池和静态变量","tags":["Java","OOP"],"categories":["JavaSE"]},{"title":"(一). 基础入门 - Java基础","path":"/javaSE-Basics.html","content":"前言 作为学习笔记，可能存在一些错误，若发现望指正，万分感激 本文主要记录了一些Java基础内容，如单例设计模式 类什么是类与对象 类：描述相同事物的共同特征的抽象。人类 对象：具体存在的实例，是真实的。实例&#x3D;&#x3D;对象 在代码层面：必须先有类，才能创建出对象。 如何定义类类的定义格式如下: 12345678修饰符 class 类名&#123; // 类中有且仅有的五大成分。 // 1.成员变量 （描述类和对象的属性信息） // 2.成员方法 （行为信息） // 3.构造器 （初始化类对象并且返回引用） // 4.代码块 // 5.内部类&#125; 如何通过类创建对象类名 对象名称 = new 类名(); 注意 类名的首字母应该大写，满足“驼峰写法”。 一个Java代码文件中可以定义多个类。但是只能有一个类是用public修饰的，而且.public修饰的类名必须成为代码的文件名称。 构造器构造器的作用通过调用构造器可以返回一个类的对象，构造器同时负责帮我们把对象的数据（属性和行为等信息）初始化好。 构造器的格式修饰符 类名(形参列表) &#123; // 构造体代码，执行代码&#125; 构造器初始化对象类名 对象名称 = new 构造器; 注意 一个类默认会自带一个 无参数构造器，即使不写它也存在， 但是如果一个类它写了一个构造器，那么默认的无参数构造器就被覆盖了! 封装什么是封装是Java语言的风格。是我们在开发中必须遵循的，即使毫无意义，代码还是要按照这个风格写! ! 封装的作用 1.可以提高安全性。 2.可以实现代码的组件化。 封装的步骤 使用 private 关键字来修饰成员变量。 使用public修饰getter和setter方法。 this关键字this关键字的作用 this代表所在类的当前对象的引用（地址值），即代表当前对象。 this关键字可以用在实例方法和构造器中。 this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。 this用在构造器，代表了构造器正在初始化的那个对象的引用 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ThisDemo02 &#123; public static void main(String[] args) &#123; Animal animal = new Animal(); animal.setName(&quot;小明&quot;); Animal animal1 = new Animal(&quot;哈哈&quot;,&#x27;男&#x27;); &#125;&#125;class Animal&#123; private String name; private char sex; /** * @return this.name * this有时候可以省略 * this-&gt;animal */ public String getName() &#123; return name; &#125; /** * @param name * 谁调用这个方法，this就指向谁 * this-&gt;animal animal.name = 小明 */ public void setName(String name) &#123; this.name = name; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125; /** * @param name * @param age * @param sex * * this-&gt;animal1 * animal1.name = 哈哈 * animal1.sex = 男 */ public Animal(String name, char sex) &#123; this.name = name; this.sex = sex; &#125; public Animal() &#123;&#125;&#125; static关键字引入我们之前定义了很多成员变量(name ,age，sex)，其实我们只写了一份，但是发现每个对象都可以用，就说明Java中这些成员变量或者方法是存在所属性的。有些是属于对象的，有些是属于类本身的。 如何理解 被static修饰的成员是属于类的是放在静态区中 没有static修饰的成员变量和方法则是属于对象的 成员变量有无static区分 有static修饰：属于类叫静态成员变量，与类一起加载一次， 直接用类名调用即可。 无static修饰：属于类的每个对象的叫实例成员变量，与类的对象一起加载，对象有多少个，实例成员变量就加载多少份。必须用类的对象调用 成员方法有无static区分 有static修饰：属于类叫静态方法，直接用类名调用即可 无static修饰：属于类的每个对象的叫实例方法，必须用类的对象调用。 成员变量的访问语法123456// 静态成员变量访问:// 类名.静态成员变量。// 对象.静态成员变量。(不推荐 )// 同一个类中访问可省略类名// 实例成员变量的访问:// 对象.实例成员变量 成员方法的访问语法123456// 静态成员方法访问：// 类名.静态方法// 对象.静态方法。(不推荐 )// 同一个类中访问可省略类名// 实例成员变量访问：// 对象.实例方法 面试常问 实例方法是否可以直接访问实例成员变量? 可以的，因为它们都属于对象。 实例方法是否可以直接访问静态成员变量? 可以的，静态成员变量可以被共享访问。 实例方法是否可以直接访问实例方法? 可以的，实例方法和实例方法都属于对象。 实例方法是否可以直接访问静态方法? 可以的，静态方法可以被共享访问! 静态方法是否可以直接访问实例变量? 不可以的，实例变量必须用对象访调 静态方法是否可以直接访问静态变量? 可以的， 静态成员变量可以被共享访问。 静态方法是否可以直接访问实例方法? 不可以的，实例方法必须用对象访问! ! 静态方法是否可以直接访问静态方法? 可以的，静态方法可以被共享访问! ! 继承继承的含义 一般到特殊 是is a的关系 子类继承父类的属性和行为，使得子类对象可以直接具有与父类相同的属性、相同的行为。 子类可以直接访问父类中的非私有的属性和行为。 继承的格式通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下： 1234567class 父类 &#123;\t...&#125;class 子类 extends 父类 &#123;\t...&#125; 需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的 子类不能继承的内容 子类不能继承父类的构造器，因为子类有自己的构造器 (争议)子类是可以继承父类的私有成员的，只是不能直接访问而已。以后可以暴力去访问继承自父类的私有成员 (争议)子类是不能继承父类的静态成员的子类只是可以访问父类的静态成员，父类的静态成员只有一份可以被子类共享访问。共享并非继承。 继承后子类成员变量访问特点就近原则: 子类有找子类，子类没有找父类，父类没有就报错。 this代表了当前对象的引用，可以用于访问当前子类对象的成员变量。 super代表了父类对象的引用，可以用于访问父类中的成员变量。 方法重写的概念 发生在子父类之间的关系 子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 子类返回值类型范围相同或者更小 子类修饰符权限相同或者更大 子类异常抛出范围一样或更小 @Override重写注解 这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。 建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！ 注意 父类被重写后只能通过子类中转调用或者实例化父类调用 私有方法和静态方法都不能被重写 继承后构造器特点子类所有构造器的第一行都会先调用父类的无参构造器，再执行自己（先有爸爸，才能有儿子） 可以在子类构造器中使用super(…)调用指定构造器，以便初始化继承自父类的数据 this关键字拓展可以使用this关键字实现构造器默认值：this(…)可以根据参数类型访问本类其他构造器。此时！由对应被调用的构造器去调用父类构造器 注意：this(…)和super(…)必须放在构造器的第一行， 否则报错!所以this(…)和super(…)不能同时出现在构造器中!! 继承的特点 Java只支持单继承，不支持多继承。 假如可以多继承，若两个父类都有某一方法，且子类多继承这两个父类，在实例化子类时调用这个相同的方法，则会程序出现不知道调用谁而出现类的二义性！ 一个类可以有多个子类。 可以多层继承。 顶层父类是Object类。所有的类默认继承Object，作为父类。 抽象类概念 抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。 public abstract void run()； 特征与注意事项 继承抽象类的子类必须重写父类所有的抽象方法 无法创建对象(其他的都有) 假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义 有构造器 供子类创建对象时，初始化父类成员使用的。 意义 为了派生子类 体现模板思想，部分实现、部分抽象，可以设计模板设计模式 设计模式——优秀软件设计架构和思想 模板设计模式作用：优化代码架构，提高代码复用型，实现部分实现，部分抽象，抽象部分交给使用模板的人重复实现 接口概述 体现的是规范的思想（公开） 接口是更加彻底的抽象 在JDK8之前，接口中的成分包含：抽象方法和常量 public static final（抽象类里可省略） 常量：变量值只有一个，而且在程序运行的过程中不可更改!变量名全大写 12345678//接口的定义格式：修饰符 interface 接口名称&#123; // 抽象方法&#125;// 修饰符：public|缺省// 接口的声明：interface// 接口名称：首字母大写，满足“驼峰模式” 使用 一个类实现接口，这个称为实现类。 接口是用来被类实现的，实现的关键字是implements,按口可以多实现。 一个类实现接口必须重写完接口中全部的抽象方法，否则这个类要定义成抽象类 类与接口之间的关系是多实现的，一个类可以同时实现多个接口 意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。 123456/**接口的实现： 在Java中接口是被实现的，实现接口的类称为实现类。 实现类的格式:*/[修饰符] class 类名 implements 接口1,接口2,接口3...&#123;&#125; 接口与接口之间是可以多继承的 12345678910111213141516171819public interface Abc &#123; void go(); void test();&#125;/** 法律规范：接口*/public interface Law &#123; void rule(); void test();&#125; * * 总结： * 接口与类之间是多实现的。 * 接口与接口之间是多继承的。 * */public interface SportMan extends Law , Abc &#123; void run();&#125; JDK 8之后的接口新增方法接口不再纯洁了，接口中不再只是抽象方法，接口还可以有默认方法（也就是实例方法），和静态方法了，还包含了私有实例方法和私有静态方法 默认方法：默认加入public修饰，可省略；使用 default 修饰，不可省略，供子类调用或者子类重写。 静态方法：默认加入public修饰，可省略；使用 static 修饰，供接口直接调用。 私有方法：1.9开始新增，使用 private 修饰，供接口中的默认方法或者静态方法调用。 1234567891011public interface InterFaceName &#123; public default void method() &#123; // 执行语句 &#125; public static void method2() &#123; // 执行语句 &#125; private void method() &#123; // 执行语句 &#125;&#125; 接口小结 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。 接口中的方法全是抽象方法，默认会自动加上public abstract修饰 JDK 8开始，接口不再纯洁，支持静态方法，默认方法，私有方法。 接口中，没有构造器，不能创建对象。 类与接口是多实现的 接口与接口是多继承的 接口体现的规范。 代码块静态代码块 每次执行类，加载类的时候都会先执行静态代码块一次。 静态代码块是自动触发执行的，只要程序启动静态代码块就会先执行一次。 作用：在启动程序之前可以做资源的初始化，一般用于初始化静态资源。 static&#123; // 执行代码&#125; 实例代码块 无static修饰。属于对象，与对象的创建一起执行的。 每次调用构造器初始化对象，实例代码块都要自动触发执行一次。 实例代码块实际上是提取到每一个构造器中去执行的。 作用：实例代码块用于初始化对象的资源。 &#123; // 执行代码&#125; final关键字基本知识 final： 不可改变，最终的含义。可以用于修饰类、方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，有且仅能被赋值一次。 修饰局部变量时，防止在执行过程中被修改 修饰成员变量 时可以在被定义的 时候赋值一次，或者在静态代码块里赋值一次 abstract和final是互斥关系，不能同时修饰成员 单例设计模式什么是单例？ 一个类只有一个对象实例，可以节约内存提高性能，有8种 有哪些？ 饿汉单例设计模式使用类的时候已经将对象创建完毕，不管以后会不会使用到该实例化对象，先创建了再说 123456789101112public class Singleton &#123; // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 private Singleton() &#123;&#125; // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。 private static final Singleton instance = new Singleton(); // 3.定义一个静态方法返回这个唯一对象。 public static Singleton getInstance() &#123; return instance; &#125;&#125; 懒汉单例设计模式调用getInstance()方法时实例才被创建，先不急着实例化出对象，等要用的时候才例化出对象 12345678910111213141516public class Singleton &#123; // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。 private static Singleton instance; // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 private Singleton() &#123;&#125; // 3.定义一个静态方法返回这个唯一对象。要用的时候才例化出对象 public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 枚举类定义枚举的格式enum 枚举名 &#123; //第一行都是罗列枚举实例,这些枚举实例直接写大写名字即可。 BOY, GIRL; // 男，女&#125; 特点 final修饰的，不能被继承 枚举是不能在外部创建对象的，枚举的构造器默认是私有的。 枚举类在第一行罗列若干个枚举对象。（多例） 第一行都是常量，存储的是枚举类的对象。 枚举通常用于做信息的标志和分类。 使用Sex s ＝ Sex.BOY // BOYs.ordinal() // 枚举对象索引位置 多态概念同一个类型对象，执同一个行为，在不同状态下表现出不同的行为特征，多态是出现在继承或者实现关系中的。 格式：// 方法调用（行为）：编译看左边，运行看右边// 变量调用：编译运行都看左边父类类型 变量名 = new 子类/实现类构造器;变量名.方法名(); 存在条件 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 多态优势 组件化切换，可以实现类于类的解耦 拓展性，便利 不能调用子类独有的功能，小范围自动转换为大范围 内部类提供更好的封装性，内部类也更多权限修饰符，封装性也更多控制，体现出组件的思想，寄身 静态内部类 属于外部类本身，只会加载一次，可以通过外部类名称.内部类名称实例化。内部类中可以直接访问外部类静态成员，但是不能访问实例成员 实例内部类 属于外部类对象，不能定义静态成员，但可以定义常量，可以通过外部类名称.内部类 name ＝ new 外部类().new 内部类()来实例化，可以访问外部的静态和实例成员 局部内部类 和实例内部类很像 匿名内部类 没有名字的局部内部类，也是一个匿名内部类的对象，是子类类型 权限修饰符 public protected 缺省（空的） private 本类中 √ √ √ √ 本包下的其他类类 √ √ √ 其他包下的子类 √ √ 其他包中的无关类 √","tags":["Java"],"categories":["JavaSE"]},{"title":"3xui面版搭建Reality协议，使用链式代理，最简单的魔法","path":"/workflow/3X-UI.html","content":"摘要通过3xui实现链式代理，自建节点，高速低延迟 搭建dokcer-compose搭建123456789101112131415161718services: 3x-ui: image: ghcr.io/mhsanaei/3x-ui:latest container_name: 3xui restart: always mem_limit: 85m ports: - 20000-20005:20000-20005/tcp - 20000-20005:20000-20005/udp - 2053:2053/tcp volumes: - ./cert:/root/cert - ./db:/etc/x-ui logging: driver: json-file options: max-size: &quot;1m&quot; max-file: &quot;3&quot; 这边建议您通过docker compose up -d 运行后配置反向代理！但是需要开放20000-20005的端口（也可以自己选自己喜欢的端口），用于节点。 脚本搭建bash &lt;(curl -Ls https://raw.githubusercontent.com/mhsanaei/3x-ui/master/install.sh) 搭建节点基本配置证书申请见：泛域名证书申请 反向代理配置如下： 123456789101112#3xuiserver &#123; listen 443 ssl; server_name xui.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:2053/; &#125;&#125; 参考配置 vmess+ws类型：协议：vmess、端口：20001、传输：WebSocket reality类型节点：协议：vless、端口：20000、安全：REALITY、用户Flow：xtls-rprx-vision，Dest：目标网站:端口，SNI：目标网站 目标网站查询指南： 选择带有域名的 不要选证书为黄色的，比如 端口和自己的节点的端口一致，比如你的端口是443，那就是整个域名，比如你的端口是8080，那就是域名后面带有端口 8080 ，比如 exp.com:8080，当然对应的Dest：exp.com:8080，SNI：exp.com:8080 ASN查询：https://tools.ipip.net/as.php目标网站：https://fofa.info 下面查询可以修改自己的country和自己服务器的相同，以及端口等 asn==&quot;25820&quot; &amp;&amp; country==&quot;US&quot; &amp;&amp; port==&quot;443&quot; &amp;&amp; cert!=&quot;Let&#x27;s Encrypt&quot; &amp;&amp; cert.issuer!=&quot;ZeroSSL&quot; &amp;&amp; status_code=&quot;200&quot; 链式代理请求-&gt;服务器A-&gt;服务器B-&gt;目的 因为阿里云服务器（服务器A）很多流媒体无法访问，如果有其他vps或者ip等等（服务器B），可以在（服务器A）设置里面配置出站规则：你的vps的节点也好、socks也好，只要可以访问到你其他vps（服务器B）,让B帮你发请求。然后在路由规则里添加Domain比如：geosite:netflix,geosite:spotify,geosite:tiktok,geosite:meta,geosite:apple,geosite:reddit,geosite:openai然后配置Outbound Tag为你出站规则里访问服务器B的标签，就实现了请求分流。","tags":[null,null,null,null],"categories":[null]},{"title":"alist的多种搭建方式，优化分享链接，实现浏览器直接预览","path":"/workflow/Alist.html","content":"摘要展示alist的docker搭建方式，以及直接搭建。实现挂载服务器指定目录文件，并且可以对其进行预览、而不是触发下载 搭建docker搭建# 目录：/home/docker/alistmkdir /home/docker/alistcd /home/docker/alistvi docker-compose.yml 123456789101112131415161718services: alist: image: xhofe/alist:main container_name: alist restart: always mem_limit: 100m user: root ports: - &quot;5244:5244&quot; volumes: - /home/docker/nginx/certs:/opt/alist/data/cert - /home/data:/home/data - ./data:/opt/alist/data logging: driver: json-file options: max-size: &quot;1M&quot; max-file: &quot;3&quot; 这边建议您通过docker compose up -d 运行后，配置反向代理 直接搭建123456789# 默认安装在 `/opt/alist` 中。 # 自定义安装路径，将安装路径作为第二个参数添加，必须是绝对路径（如果路径以 alist 结尾，则直接安装到给定路径，否则会安装在给定路径 alist 目录下）# 如 安装到 `/home`# Installcurl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s install /home# updatecurl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s update /home# Uninstallcurl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s uninstall /home 配置注意记得去config.json里把user 值设置为root 基础设置1234567891011121314151617访问地址：http://YOUR_IP:5244/配置文件路径：/home/alist/data/config.json---------如何获取密码？--------先cd到alist所在目录:cd /home/alist随机设置新密码:./alist admin random或者手动设置新密码:./alist admin set NEW_PASSWORD----------------------------启动服务中查看状态：systemctl status alist启动服务：systemctl start alist重启服务：systemctl restart alist停止服务：systemctl stop alist 反向代理123456789101112# alistserver &#123; listen 443 ssl; server_name alist.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:5244/; &#125;&#125; 挂载目录 预览处理 把&#x2F;d的请求重定向到nginx服务，然后监听本地的80请求，再设置跟路径即可 需要注意的是：比如请求 https://alist.exp.top/d/oss/Blog/source/imgs/github.svg 他重定向后的路径在服务器中就为 http://127.0.0.1:80/oss/Blog/source/imgs/github.svg 确保root目录对应的路径下有这些文件 12345678910111213141516171819202122232425262728# alistserver &#123; listen 443 ssl; server_name alist.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:5244/; &#125; # 处理 /d/ 请求，重写路径并代理到 80 端口 location /d/ &#123; rewrite ^/p/(.*)$ /$1 break; proxy_pass http://127.0.0.1:80/; &#125;&#125;server &#123; listen 80; server_name 127.0.0.1; root /home/data; location / &#123; try_files $uri $uri/ =404; &#125;&#125; rclone挂载alist到电脑（可选）下载：rclone和winfsp 配置： 把含有exe文件的目录添加到系统环境变量 打开cmd运行窗口使用指令rclone config修改配置 填写alist登录账号 选择webdav 选择其他 输入挂载到本地的名称 用户名称就输alist账号 输入y填写并确认alist密码 按3下enter并输入q退出 开机自动挂载： 新建bat，输入以下内容，再双击查看是否成功运行 # 第一个alist是之前设置的挂载到本地的名称 # alist:/ 表示挂载根目录# D:/alist 本地的哪个路径@echo offrclone mount alist:/ D:/alist --vfs-cache-mode full --use-mmap --allow-other --no-check-certificate --no-gzip-encoding --copy-links 创建任务计划，通过在Windows搜索框中输入”任务计划程序”找到并打开，创建基本任务，触发器选 计算机启动时，选择 启动程序 后路径选择刚刚创建的bat文件，完成创建 右键点击该任务，选择“属性”，在“常规”选项卡中，勾选“使用最高权限运行”，在“操作”选项卡中，点击“编辑”（Edit）在“编辑操作”窗口中，在bat路径前添加cmd.exe /c，并在“添加参数”中输入/c start &quot;&quot; /b &quot;C:\\path\\to\\your\\mount_alist.bat&quot;。 这样就可以开机后，rclone在后台无感运行了","tags":[null,null,null],"categories":[null]},{"title":"Nginx 反向代理速成教学与泛域名证书的申请","path":"/workflow/Nginx.html","content":"摘要本指南介绍了三种 Nginx 安装方法：直接安装、从源码编译安装及 Docker 安装。直接安装最为简便，适合大多数情况；从源码编译安装提供更高灵活性；Docker 安装则便于容器化部署。此外，还介绍了如何配置 Nginx 实现反向代理和 HTTPS 加密访问，例如将所有 sync.exp.com 的请求转发到 http://127.0.0.1:8384。 安装直接安装(建议)sudo apt update sudo apt install nginx-full# 目录在/etc/nginxwhereis nginx 编译安装（可能缺失模块）123456789101112131415161718192021222324cd /home# https://github.com/syncthing/syncthing/releaseswget https://nginx.org/download/nginx-1.26.2.tar.gz# 解压tar -xzvf nginx-1.26.2.tar.gz # 删除压缩包rm -f nginx-1.26.2.tar.gz# 重命名(可选)mv nginx-1.26.2 nginx# 创建日志文件sudo touch /home/logs/nginx.log# 编译sudo apt-get install build-essential libpcre3 libpcre3-dev zlib1g-dev openssl libssl-dev# --prefix：Nginx主要安装路径，后续Nginx子目录依照这个变量展开./configure \\--prefix=/home/nginx/nginxmake &amp;&amp; make install# 创建链接可以在任何地方访问nginxsudo ln -s /home/nginx/nginx/sbin/nginx /usr/local/bin/nginxwhich nginx docker安装目录：&#x2F;home&#x2F;docker&#x2F;nginx mkdir /home/docker/nginxcd /home/docker/nginxvi docker-compose.yml 先注释到nginx的挂载目录 运行容器 执行命令复制配置到主机，建议绝对目录 docker cp nginx:&#x2F;etc&#x2F;nginx &#x2F;home&#x2F;docker&#x2F;nginx 取消注释 重启容器 12345678910111213141516171819202122services: nginx: restart: always container_name: nginx image: nginx:latest # 设置内存限制为120MB mem_limit: 120m memswap_limit: -1 # user: root ports: - 80:80 - 443:443 volumes: - ./nginx:/etc/nginx - ./src:/var/www/html:rw,cached - ./certs:/etc/certs - /home/data:/home/data logging: driver: json-file options: max-size: &quot;3m&quot; max-file: &quot;3&quot; docker-compsoe up -d 进行部署 基础知识基础命令1234567891011# 测试配置文件是否有语法错误 nginx -t # 查看状态sudo systemctl status nginx# 启动sudo systemctl start nginx# 停止sudo systemctl stop nginx# 重新加载sudo systemctl reload nginx 反向代理先看如下代码： 123456789server &#123; listen 8000 ; server_name [服务器的ip地址|域名]; location / &#123; proxy_pass http://127.0.0.1:8080; ##需要代理的服务器地址 index index.html; &#125;&#125; 此代码是nginx配置的一部分，他有如下作用： 用户访问你的公网 ip:8000，该请求端口因为被nginx监听，所以会被nginx发送到地址为http://127.0.0.1:8080 ，也就是把8000端口请求转到了内网8080端口，然后返回root 目录下的index.html信息。 操作示例我们之前已经搭建好了syncthing服务器，假如我们购买的域名为 exp.com ，接下来我们将进行泛域名证书申请和反向代理实现https加密访问也就是 ssl&#x2F;tls。 泛域名证书申请SSL（安全套接字层）及其后继者TLS（传输层安全性）是用于在联网计算机之间建立经过身份验证和加密的链接的协议。尽管随着 1999 年 TLS 1.0 的发布，SSL 协议已被弃用，但仍普遍将这些相关技术称为“SSL”或“SSL&#x2F;TLS”。最新版本是TLS 1.3 ，在RFC 8446 （2018 年 8 月）中定义。 12345678910111213141516# 安装acmecurl https://get.acme.sh | shcd /root/.acme.sh# DNS-API验证## 输入阿里云角色的kye和Secret## 注意！记得授权，在授权页搜索DNS，全选授权export Ali_Key=export Ali_Secret=# 注册账号./acme.sh --register-account -m 12341234@163.com# 解析域名 baidu 为例./acme.sh --issue -d exp.com -d *.exp.com --dns dns_ali# 证书目录/root/.acme.sh/exp.com_ecc 通过一键脚本申请证书# 地址## https://github.com/Missiu/debian-script## 详细说明见sudo wget -O /home/acme.py https://raw.githubusercontent.com/Missiu/debian-script/main/py/acme.py &amp;&amp; pip install termcolor &amp;&amp; sudo chmod 700 /home/acme.py &amp;&amp; sudo python3 /home/acme.py 其中证书目录似乎无法设置成功：可以使用如下命令同步到acme sudo mv /root/.acme.sh /home/acme &amp;&amp; sudo ln -s /home/acme /root/.acme.sh 反向代理并部署到nginx上复制证书cd /root/.acme.shmkdir /etc/nginx/cert# _通过该命令可将_ _`~/.acme.sh/exp.top`_ _内的证书copy到指定位置`acme.sh`签发了新证书后就自动完成该拷贝过程./acme.sh --install-cert -d exp.com --key-file /etc/nginx/cert/exp.com.key --fullchain-file /etc/nginx/cert/exp.com.cer --reloadcmd &#x27;service nginx force-reload&#x27; 最简单的配置监听80端口，把所有请求转到 443 端口，并使用证书加密，这样所有该证书的子域名都可以生效 # 我们在conf.d新建 .conf 文件，因为nginx 默认导入了该文件夹下所有 .conf 文件cd /etc/nginx/conf.dvim exp.com.conf 以下代码，会监听80和443端口，所有exp.com的子域名，和exp.com都会被重定向到https，也就是访问443端口，然后443端口开起了ssl，我们访问exp.com的子域名sync.exp.com的所有请求都会被发送到http://127.0.0.1:8384 123456789101112131415161718# http(80) -&gt; https(443/ssl)server &#123; listen 80; server_name *.exp.top exp.top; return 301 https://$host$request_uri;&#125;# syncthingserver &#123; listen 443 ssl; server_name sync.exp.com; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8384/; &#125;&#125; 教程中所有nginx配置一览12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# http(80) -&gt; https(443/ssl)server &#123; listen 80; server_name *.exp.top exp.top; return 301 https://$host$request_uri;&#125;# syncthingserver &#123; listen 443 ssl; server_name sync.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8384/; &#125;&#125;# blogserver &#123; listen 443 ssl; server_name www.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; # 我这里是oss目录 root /home/data/blog; index index.html index.htm; location / &#123; try_files $uri $uri/ =404; &#125;&#125;# alistserver &#123; listen 443 ssl; server_name alist.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:5244/; &#125; # 处理 /d/ 请求，重写路径并代理到 80 端口 location /d/ &#123; rewrite ^/p/(.*)$ /$1 break; proxy_pass http://127.0.0.1:80/; &#125;&#125;server &#123; listen 80; server_name 127.0.0.1; root /home/data; location / &#123; try_files $uri $uri/ =404; &#125;&#125;#bitwortenserver &#123; listen 443 ssl; server_name bitwt.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8000/; &#125;&#125;#3xuiserver &#123; listen 443 ssl; server_name xui.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:2053/; &#125;&#125;","tags":[null,null,null,null],"categories":[null]},{"title":"Hexo搭建个人博客，Stellar主题美化教程，hexo结合obsidian实现一键发布","path":"/workflow/Hexo.html","content":"需求分析内容展示需要写在简历里，所以当点进博客主目录需要快速概览的查看到总共做了什么内容。最好以图片的形式进行展现，这就需要排序功能，把高质量的，可以彰显技术力的文章放在前面，当点进去后会看到其同类型的笔记，浏览完后想返回时会注意到文档目录和个人简介按钮，到这里应该就知道整个博客的点击流程。其中点击个人简介会展示自己开源项目详细解释与地址，以及一些技术的描述，这些技术可以通过类似点击标签的形式访问到对应的文章（如果有） 编辑发布需要方便编写，在编写完后一键发布，并且不需要再设置博客的其他配置。已发布和未发布的文章不应有太大差距，编译前后使用同一套语法，附件方便管理，每个文章有对应的附件文件夹，文章链接不应很长，需要进行高效的SEO，当然需要有评论功能，其他人也可以通过邮箱和我进行交流 效果展示 初步化建议： 一个前端编译器如：vscode、webstorm 有node环境。建议版本在20.10.0以下，如18.20.0 安装hexo安装npm install hexo-cli -ghexo init blogcd blognpm install stellara安装npm i hexo-theme-stellar# 在 `blog/_config.yml` 文件中找到并修改theme: stellar # 也可以使用源码的方式进行安装git clone https://github.com/xaoxuu/hexo-theme-stellar.git# 把他放在themes目录下即可# 在 `blog/_config.yml` 文件中找到并修改theme: stellar 运行使用 hexo s 运行或者在编译器里找到package.json文件直接点击运行 软件笔记软件推荐obsidian，地址：https://obsidian.md/download，当然其他软件也可以，但是非本地存储的软件不太使用本教程 配置hexo 配置附件相对链接# 下载插件会转为 绝对路径npm install hexo-asset-image --save 我的配置 123456new_post_name: :hash.md # 新文章的文件名称post_asset_folder: truerelative_link: false # 把链接改为与根目录的相对位址 marked: prependRoot: true postAsset: true 站点图标12345678# 在在主站点的 _config.yml 里配置## 匹配到的文件将会被不做改动地复制到 public 目录中。 您可使用 glob 表达式来匹配路径。skip_render: images/**# 在source目录下新建imgs,访问路径为 images/xx.jpg# 在在主站点的 _config.yml 里配置avatar: &#x27;/images/avatar.png&#x27; # 站点头像 favicon: &#x27;/images/favicon-28-dog.svg&#x27; # 站点icon 推送Github或者OSS1234567891011121314151617181920212223# 安装插件npm install hexo-deployer-git --savenpm install hexo-deployer-ali-oss --save# 部署设置 # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: - type: git repo: git@github.com:Missiu/missiu.github.io.git # example, https://github.com/hexojs/hexojs.github.io branch: main - type: ali-oss region: &lt;您的oss 区域代码&gt; accessKeyId: &lt;您的oss accessKeyId&gt; accessKeySecret: &lt;您的oss accessKeySecret&gt; bucket: &lt;您的bucket name&gt;\tcacheControl: images: public, max-age=15552000 # 缓存时间6个月 css: public, max-age=1209600 # 缓存时间14天 js: public, max-age=259200 # 缓存时间3天 html: public, max-age=259200 # 缓存时间3天 other: no-cache # 缓存时间0 完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148# Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: Hzh subtitle: &quot;我亦无他，唯手熟尔 | Life-long learning&quot; # 网站副标题 description: &#x27;主要分享一些学习笔记和个人见解&#x27; # 网站描述 keywords: [ &#x27;计算机&#x27;,&#x27;开发&#x27;,&#x27;编程&#x27;,&#x27;网站&#x27;,&#x27;博客&#x27;,&#x27;技术&#x27;,&#x27;学习&#x27;,&#x27;教程&#x27;,&#x27;服务器&#x27;,&#x27;Java&#x27;,&#x27;后端&#x27; ] # 网站的关键词。 支持多个关键词。 author: Huzhihao language: - zh-CN - en - zh-TW timezone: &#x27;Asia/Shanghai&#x27; avatar: &#x27;/images/avatar.png&#x27; # 站点头像 favicon: &#x27;/images/favicon-28-dog.svg&#x27; # 站点icon # URL ## 网站地址，比如github地址： ## &#x27;https://username.github.io/project&#x27; url: http://localhost:4000/ permalink: :abbrlink.html # 文章的 永久链接 格式 permalink_defaults: # 永久链接中各部分的默认值 pretty_urls: # 美化永久链接 trailing_index: true # 设置 false 以删除「页面」永久链接结尾的&#x27;index.html&#x27;部分 trailing_html: true # 设置 false 以删除「文章」永久链接结尾的&#x27;.html&#x27;部分 # Directory source_dir: source # 源文件夹。您的内容的存储位置 public_dir: public # 公共文件夹。静态站点将在哪里生成 tag_dir: tags # 标签文件夹 archive_dir: archives # 归档文件夹 category_dir: categories # 分类文件夹 code_dir: downloads/code # Include code 文件夹，source_dir 下的子目录 i18n_dir: :lang # 国际化（i18n）文件夹 # https://github.com/micromatch/micromatch#extended-globbing skip_render: [images/**] # 匹配到的文件将会被不做改动地复制到 public 目录中。 您可使用 glob 表达式来匹配路径。 # Writing new_post_name: :title.md # 新文章的文件名称 default_layout: post # 预设布局 #titlecase: false # 把标题转换为 title caseexternal_link: # 在新标签中打开链接 # enable: true # 在新标签中打开链接 # field: site # 对整个网站（site）生效或仅对文章（post）生效 # exclude: &#x27;&#x27; # 需要排除的域名。 主域名和子域名如 www 需分别配置 filename_case: 0 # 修改文件名称大小写，1 小写; 2 大写 render_drafts: false # 显示草稿 # https://hexo.io/zh-cn/docs/asset-folders # 如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。 # 然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 post_asset_folder: true # 启用 资源文件夹 #资源图片将会被自动解析为其对应文章的路径。 ## 例如： image.jpg 位置为 /2020/01/02/foo/image.jpg,这表示它是 /2020/01/02/foo/ 文章的一张资源图片 ## ![](image.jpg) 将会被解析为 &lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt; 。 relative_link: false # 把链接改为与根目录的相对位址 marked: prependRoot: true postAsset: true future: true # 显示未来的文章 # https://hexo.io/zh-cn/docs/syntax-highlight syntax_highlighter: highlight.js # 代码块的设置, 请参考 代码高亮 进行设置 # 代码块的设置, 请参考 Highlight.js 进行设置 # https://hexo.io/zh-cn/docs/syntax-highlight#Highlight-js highlight: line_number: true # 行号显示。 auto_detect: false # 自动检测代码块的语言。十分耗费资源! tab_replace: &#x27;&#x27; # 用给定字符串替换代码块内的制表符。 默认为 2 个空格。 line_threshold: 5 # 接受一个可选的阈值，只有代码块的行数超过这个阈值才显示行数。 默认值为 0。 wrap: true # 支持行号显示 hljs: false # 当 hljs 设置为 true 时，所有代码块的 HTML 输出均会给 class 添加 hljs- 前缀（无论 wrap 是否开启 # 代码块的设置, 请参考 PrismJS 进行设置 # https://hexo.io/zh-cn/docs/syntax-highlight#PrismJS prismjs: preprocess: true # Hexo 内建的 PrismJS 支持浏览器端高亮（preprocess 设置为 false）和服务器端高亮（preprocess 设置为 true）两种方式。 line_number: true # 因为 line_number 功能依赖 wrap，你无法在配置中关闭 wrap 而又开启 line_number。 如果你将 line_number 设置为 true 的话，wrap 将被自动开启 tab_replace: &#x27;&#x27; # 将代码块内的 \\t 替换为给定的字符串。 默认为 2 个空格。 line_threshold: 5 # 接受一个可选的阈值，只有代码块的行数超过这个阈值才显示行数。 默认值为 0。 # Home page setting # path: Root path for your blogs index page. (default = &#x27;&#x27;) # per_page: Posts displayed per page. (0 = disable pagination) # order_by: Posts order. (Order by date descending by default) # https://github.com/hexojs/hexo-generator-index index_generator: # 生成帖子档案，由hexo-generator-index提供支持 path: &#x27;&#x27; # 博客索引页的根路径 per_page: 10 # 每页显示的帖子。 order_by: -date # 帖子订单。默认情况下按降序日期（从新到旧）排序。 pagination_dir: page # URL格式，参见下面的分页设置 # Category &amp; Tag default_category: post # 默认分类 category_map: # 分类别名 tag_map: # 标签别名 # Metadata elements ## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta meta_generator: true # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD # 日期格式 time_format: HH:mm:ss # 时间格式 ## 当 Front Matter 中没有指定 updated 时 updated 的取值 ### mtime: 使用文件的最后修改时间。 这是从 Hexo 3.0.0 开始的默认行为。 ### date: 使用 date 作为 updated 的值。 可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变 ### empty: 直接删除 updated。 使用这一选项可能会导致大部分主题和插件无法正常工作。 updated_option: &#x27;date&#x27; # Pagination ## 每页显示的帖子数。 0 关闭分页功能 per_page: 100 pagination_dir: page # 使用以下选项可明确处理或忽略某些文件/文件夹。 可以使用 glob 表达式 进行路径匹配。 ## include 和 exclude 选项只会应用到 source/ ，而 ignore 选项会应用到所有文件夹 # https://hexo.io/zh-cn/docs/configuration include: # 包含隐藏文件（包括名称以下划线开头的文件/文件夹，* 除外） exclude: # 排除文件或文件夹 ignore: # 忽略文件/文件夹 # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: stellar# 部署设置 # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: - type: git repo: git@github.com:Missiu/missiu.github.io.git # example, https://github.com/hexojs/hexojs.github.io branch: main - type: ali-oss region: &lt;您的oss 区域代码&gt; accessKeyId: &lt;您的oss accessKeyId&gt; accessKeySecret: &lt;您的oss accessKeySecret&gt; bucket: &lt;您的bucket name&gt;\tcacheControl: images: public, max-age=15552000 # 缓存时间6个月 css: public, max-age=1209600 # 缓存时间14天 js: public, max-age=259200 # 缓存时间3天 html: public, max-age=259200 # 缓存时间3天 other: no-cache # 缓存时间0 stellara配置文章封面# 可以在 front-matter 里配置自己的图片地址,比如cover: /workflow/IMG-20240808143434703.png 文章推荐123456789# 要实现相关文章推荐功能，您需要安装插件npm i hexo-related-popular-posts -save# 在 _config.stellar.yml 中配置## 开启后会在每篇文章的下方推荐相同类型的文章article: related_posts: enable: true title: 您可能感兴趣的文章 文章配置12345678# 在主题配置文件中：_config.stellar.ymlarticle: # 建议您通过 `description` 或者 `excerpt` 方式生成摘要，但如果您希望自动从文章内容截取一定字数的文字作为摘要，可以这样设置：\tauto_excerpt: 200 # 许可协议\tlicense: &#x27;本文由 [Mr. Hu](/about/) 原创, 采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。&#x27;\t# 分享链接\tshare: [wechat, weibo, link] 实现博客专栏这个专栏有点文章分类的那个意味，建议用于处理5篇及其一下的同类型文章 在文章 front-matter 里配置 topic 字段 # 这个值是专栏唯一值 ，比如：Java 专栏topic: java 创建一个专栏：在 blog/source/_data/ 文件夹中创建一个 topic 文件夹，在其中放入各个专栏的描述文件，文件名就是项目的 id，比如这里是 java # 这里是blog/source/_data/topic/java.ymlname: Java # 在面包屑导航上会显示较短的名字 title: Java 由Java基础到Java高级 # 在列表页会显示完整的专栏标题 description: 包含Java基础知识、JVM、Java多线程，以及常问面试题order_by: -date # 默认是按发布日期倒序排序 示例路径： 关于页面# 直接在source/about创建index.md文件即可# 建议指定 front-matter 的 menu_id为about，这会影响后续侧边栏的配置--- menu_id: about --- 实现文档功能这个文档功能可以处理很多的同类型文章，需要注意的是其存放的位置不同于其他文章，同样以Java为例： 修改wiki路径（可选）： # 在_config.stellar.yml目录下site_tree: wiki: base_dir: books # books / products ... 在 blog/source/_data/ 文件夹中创建一个 wiki 文件夹，在其中放入各个项目的文档。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 这里是blog/source/_data/wiki/java.yml# 基本信息 name: Java # 在面包屑导航上会显示较短的名字 title: Java 由Java基础到Java高级 # 在列表页会显示完整的专栏标题 description: 包含Java基础知识、JVM、Java多线程，以及常问面试题 tags: icon:# 是否显示封面cover: coverpage: false # 该文档的仓库链接（如果有） repo: Missiu/Beaudar-Comments # 配置搜索功能 search: filter: /books/java/ placeholder: 在 Java 中搜索... # 显示许可协议license: true# 显示分享share: true# 如果您希望自定义某个项目的侧边栏组件，可以设置 `sidebar` 值leftbar: - tree # 目录树 # - timeline_stellar_releases # 发布时间线 # - related # 相关文章 # 项目评论设置 comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/Missiu/Beaudar-Comments/issues) 反馈。&#x27; # 评论服务配置 comments: service: beaudar beaudar: repo: Missiu/Beaudar-Comments # 修改 wiki 路径 优先级最高，每个不同的文档可以配置不同的base_dirsite_tree: wiki: base_dir: books # books / products ...# 基础目录设置 base_dir: /books/java/ # 指定项目所在文件夹和目录树tree: &#x27;快速开始&#x27;: - workflow/workflow &#x27;基本使用&#x27;: - JVM/JVM 需要给文章添加关键字，然后该文章可能在 source/books/java/workflow目录下 # front-matterwiki: java 在 blog/source/_data/ 文件夹中创建一个 wiki.yml 文件，在其中写入需要显示的项目 - java 示例路径 侧边栏导航我的侧边栏设计为 ： 博客 + 文档 + 关于 三个部分 ，需要针对这个三个部分进行设置 1234567891011121314151617181920212223# 在_config.stellar.yml文件里# 侧边栏主功能导航菜单 menubar: columns: 3 # 一行多少个 items: # 可按照自己需求增加，符合以下格式即可 # id: 页面中高亮的 menu_id # theme: 高亮时的颜色，仅 svg 中 fill=&quot;currentColor&quot; 时有效 # icon: 支持 svg/img 标签，可以定义在 icons.yml 文件中，也支持外部图片的 URL # title: 标题 # url: 点击跳转到哪，支持相对路径和绝对路径 - id: post theme: &#x27;&#x27; icon: &#x27;&#x27; title: 专栏 url: /topic/ - id: wiki theme: &#x27;&#x27; icon: &#x27;&#x27; title: 文档 url: /wiki/ - id: about theme: &#x27;&#x27; icon: &#x27;&#x27; title: 关于 url: /about/ 侧边栏背景12345678# 在_config.stellar.yml中style: leftbar: # 可以设置：纯色/渐变色/图片作为背景 # background: var(--leftbar-bg) background-image: url(/images/background.png) blur-px: 200px blur-bg: var(--alpha50) 搜索功能12345678# 在_config.stellar.yml中search: service: local_search # local_search, algolia_search, todo... local_search: # 在 front-matter 中设置 indexing:false 来避免被搜索索引 field: all # post, page, all path: /search.json # 搜索文件存放位置 content: true # 是否搜索内容 codeblock: true # 是否搜索代码块 评论功能Beaudar 是 Utterances 的中文版本，相比 Utterances 有更多的体验优化，可以按时间倒序排序。 # _config.stellar.ymlcomments: service: beaudar beaudar: repo: Missiu/Beaudar-Comments 在obsidian中的 front-matter建议在obsidian安装插件：Templater 在其中新进文本文件比如： front-matter.txt 1234567891011121314151617181920212223242526272829---# 文章标题 title: （一）充分利用云服务器，如何围绕云服务器搭建自己的工作流# 文章创建时间date: 2024-08-18 21:01:43# 标签列表tags: []# 分类列表categories: []# 文章更新时间updated: 2024-08-18 21:01:43# 封面图片链接cover: # 文章置顶顺序，数字越大越靠前sticky:# 参考资料列表references: []# 是否允许评论comments: true# 是否允许被搜索引擎收录,设置 false 避免被搜索indexing: truetopic: []# tech/storytype: tech# 专栏 idtopic: # 文档 idwiki: --- 完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580######## Stellar info ######## stellar: version: &#x27;1.29.1&#x27; homepage: &#x27;https://xaoxuu.com/wiki/stellar/&#x27; repo: &#x27;https://github.com/xaoxuu/hexo-theme-stellar&#x27; main_css: /css/main.css main_js: /js/main.js ######## head tags ######## preconnect: # - https://gcore.jsdelivr.net # - https://cdn.jsdelivr.net # - https://unpkg.com open_graph: enable: true twitter_id: # for open_graph meta ######## Sidebar ######## # 左上角显示的 logo 区域，包含图标、大标题、副标题 logo: avatar: &#x27;[&#123;config.avatar&#125;](/about/)&#x27; # you can set avatar link in _config.yml or &#x27;[https://xxx.png](/about/)&#x27; title: &#x27;[&#123;config.title&#125;](/)&#x27; # you can set html tag like: &#x27;[&lt;img no-lazy height=&quot;32px&quot; src=&quot;xxx&quot;/&gt;](/)&#x27; subtitle: &#x27;&#123;config.subtitle&#125;&#x27; # &#x27;文字1 | 文字2&#x27; (鼠标放上去会切换到文字2) # 侧边栏主功能导航菜单 menubar: columns: 3 # 一行多少个 items: # 可按照自己需求增加，符合以下格式即可 # id: 页面中高亮的 menu_id # theme: 高亮时的颜色，仅 svg 中 fill=&quot;currentColor&quot; 时有效 # icon: 支持 svg/img 标签，可以定义在 icons.yml 文件中，也支持外部图片的 URL # title: 标题 # url: 点击跳转到哪，支持相对路径和绝对路径 - id: post theme: &#x27;&#x27; icon: &#x27;&#x27; title: 专栏 url: /topic/ - id: wiki theme: &#x27;&#x27; icon: &#x27;&#x27; title: 文档 url: /wiki/ - id: about theme: &#x27;&#x27; icon: &#x27;&#x27; title: 关于 url: /about/ # - id: post # theme: &#x27;#1BCDFC&#x27; # icon: solar:documents-bold-duotone # title: 博客 # url: / # - id: wiki # theme: &#x27;#3DC550&#x27; # icon: solar:notebook-bookmark-bold-duotone # title: 文档 # url: /wiki/ # - id: explore # theme: &#x27;#FA6400&#x27; # icon: solar:planet-bold-duotone # title: 探索 # url: /explore/ # - id: social # theme: &#x27;#F44336&#x27; # icon: solar:chat-square-like-bold-duotone # title: 社交 # url: /friends/ ######## Main ######## # 站点主结构树 site_tree: # -- 列表类页面 -- # # 主页配置 home: leftbar: welcome, recent rightbar: # 博客列表页配置 index_blog: base_dir: blog # 只影响自动生成的页面路径 menu_id: post # 未在 front-matter 中指定 menu_id 时，layout 为 post 的页面默认使用这里配置的 menu_id leftbar: welcome, recent # for categories/tags/archives rightbar: nav_tabs: # 近期发布 分类 标签 专栏 归档 and ... # &#x27;朋友文章&#x27;: /friends/rss/ # 博客专栏列表页配置 index_topic: base_dir: topic # 只影响自动生成的页面路径 menu_id: post # 未在 front-matter 中指定 menu_id 时，layout 为 topic 的页面默认使用这里配置的 menu_id # 文档列表页配置 index_wiki: base_dir: wiki # 只影响自动生成的页面路径 menu_id: wiki # 未在 front-matter 中指定 menu_id 时，layout 为 wiki 的页面默认使用这里配置的 menu_id leftbar: related, recent # for wiki rightbar: nav_tabs: # &#x27;more&#x27;: https://github.com/xaoxuu # -- 内容类页面 -- # # 博客文章内页配置 post: menu_id: post # 未在 front-matter 中指定 menu_id 时，layout 为 post 的页面默认使用这里配置的 menu_id leftbar: related, recent # for pages using &#x27;layout:post&#x27; rightbar: ghrepo, toc # 博客专栏文章内页配置 topic: menu_id: post # 文档内页配置 wiki: menu_id: wiki # 未在 front-matter 中指定 menu_id 时，layout 为 wiki 的页面默认使用这里配置的 menu_id leftbar: tree, related, recent # for wiki rightbar: ghrepo, toc # 笔记本列表页配置 notebooks: base_dir: notebooks # 笔记本列表页的路径。以及未指定 base_dir 的笔记本的路径前缀。 menu_id: notebooks # 笔记本列表页高亮的主导航栏菜单按钮。 # 笔记本列表页的左侧栏和右侧栏。 leftbar: recent # recent within all notebooks rightbar: null # 笔记列表页配置 notes: # 笔记列表页和笔记页高亮的主导航栏菜单按钮。 # 可以在笔记本 yaml 的 menu_id 字段中覆盖此参数。 # 可以在笔记的 front-matter/menu_id 中覆盖此参数。 menu_id: notebooks # 笔记列表页的左侧栏和右侧栏。可以在笔记本 yaml 的 leftbar 和 rightbar 字段中覆盖此参数。 leftbar: tagtree, recent # recent of current notebook rightbar: null # 笔记页配置 note: # 笔记页的左侧栏和右侧栏 # 可以在笔记本 yaml 的 note_leftbar 和 note_rightbar 字段中覆盖此参数。 # 可以在笔记的 front-matter/leftbar 和 rightbar 字段中覆盖此参数。 leftbar: tagtree, recent # recent of current notebook rightbar: toc # 作者信息配置 author: base_dir: author # 只影响自动生成的页面路径 menu_id: post leftbar: recent, timeline rightbar: timeline # 错误页配置 error_page: menu_id: post &#x27;404&#x27;: &#x27;/404.html&#x27; leftbar: recent, timeline rightbar: timeline # 其它自定义页面配置 layout: page page: leftbar: recent rightbar: toc ######## Notebook ######## notebook: # 如果没有指定 excerpt 和 description，将自动取多长的内容作为文章摘要。 auto_excerpt: 128 # 可以为某个 tag 设定图标（显示在标签树中）。 tagcons: &#x27;&#x27;: solar:hashtag-linear # 每页显示多少篇笔记。0 表示不分页，null 则 fallback 到 hexo 的配置。 # 可以在笔记本 yaml 的 per_page 字段中覆盖此参数。 per_page: null # 笔记的排序方式。默认按照 updated 降序排序。 # 可以在笔记本 yaml 的 order_by 字段中覆盖此参数。 # 注意：置顶的笔记会始终排在最前面。 # 在 front-matter 中设置 pin:true|number 或 sticky:true|number 来置顶。 order_by: -updated # 是否在笔记页面显示许可协议。false 表示不显示。true 表示沿用主题许可协议内容。也可以给定具体的文本指定协议内容。 # 可以在笔记本 yaml 的 license 字段中覆盖此参数。 # 可以在笔记的 front-matter/license 中覆盖此参数。 license: false # 是否在笔记页面显示分享按钮。 # 可以在笔记本 yaml 的 share 字段中覆盖此参数。 # 可以在笔记的 front-matter/share 中覆盖此参数。 share: false ######## Article ######## article: # 文章类型，决定布局风格，可以在 front-matter/topic/wiki 中覆盖此参数 type: tech # tech: 默认技术类文章, story: 图文类文章，文字和段落间增距大 # 缩进两个文字宽度，适合文字类博客，可以在 front-matter/topic/wiki 中覆盖此参数 indent: # true / false # 如果没有指定封面，是否根据 tags 作为关键词搜索封面图片？ auto_cover: false # search from https://source.unsplash.com/ # 封面图宽高比 cover_ratio: 2.4 # 如果没有指定横幅，是否根据 tags 作为关键词搜索横幅图片？ auto_banner: false # search from https://source.unsplash.com/ # 如果没有指定 excerpt 和 description，将自动取多长的内容作为文章摘要？ auto_excerpt: 128 # 分类颜色 category_color: &#x27;探索号&#x27;: &#x27;#f44336&#x27; # 文章许可协议 license: &#x27;本文由 [Mr. Hu](/about/) 原创, 采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。&#x27; # 分享 share: [ wechat, weibo, link ] # [wechat, weibo, email, link] # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: true title: 您可能感兴趣的文章 max_count: 5 search: service: local_search # local_search, algolia_search, todo... local_search: # 在 front-matter 中设置 indexing:false 来避免被搜索索引 field: all # post, page, all path: /search.json # 搜索文件存放位置 content: true # 是否搜索内容 codeblock: true # 是否搜索代码块（需要content: true) algolia_search: # Docsearch https://docsearch.algolia.com/apply/ 申请 appId: apiKey: indexName: ######## Comments ######## comments: service: beaudar # beaudar, utterances, giscus, twikoo, waline, artalk comment_title: 快来参与讨论吧~ lazyload: false # true / false # beaudar # https://beaudar.lipk.org/ beaudar: repo: Missiu/Beaudar-Comments issue-term: pathname issue-number: theme: preferred-color-scheme label: input-position: top # top/bottom 评论框位置 comment-order: desc # desc 排序 keep-theme: # true/false loading: false branch: main # utterances # https://utteranc.es/ utterances: repo: xxx/xxx issue-term: pathname issue-number: theme: preferred-color-scheme label: # giscus # https://giscus.app/zh-CN giscus: src: https://giscus.app/client.js data-repo: xxx/xxx # [在此输入仓库] data-repo-id: # [在此输入仓库 ID] data-category: # [在此输入分类名] data-category-id: data-mapping: pathname data-strict: 0 data-reactions-enabled: 1 data-emit-metadata: 0 data-input-position: top # top, bottom data-theme: preferred_color_scheme data-lang: zh-CN data-loading: # lazy crossorigin: anonymous # Twikoo # https://twikoo.js.org/ twikoo: js: https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js # 建议锁定版本 envId: https://xxx # vercel函数 # Waline # https://waline.js.org/ waline: js: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline.js css: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline.css meta_css: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline-meta.css # Waline server address url, you should set this to your own link serverURL: https://waline.vercel.app # If false, comment count will only be displayed in post page, not in home page commentCount: true # Pageviews count, Note: You should not enable both `waline.pageview` and `leancloud_visitors`. pageview: false # Custom emoji # emoji: # - https://unpkg.com/@waline/emojis@1.1.0/weibo # - https://unpkg.com/@waline/emojis@1.1.0/alus # - https://unpkg.com/@waline/emojis@1.1.0/bilibili # - https://unpkg.com/@waline/emojis@1.1.0/qq # - https://unpkg.com/@waline/emojis@1.1.0/tieba # - https://unpkg.com/@waline/emojis@1.1.0/tw-emoji # - https://unpkg.com/@waline/emojis@1.1.0/bmoji # 设置自己的图床服务，替换默认的 Base 64 编码嵌入（有体积大小限制），在评论中上传图片更加方便 # imageUploader: # 适配了兰空图床V1、V2版本 # 以兰空图床V1为例，下列填写内容为： # fileName: file # tokenName: Authorization # api: https://xxxxxx/api/v1/upload # token: Bearer xxxxxxxxxxxxxx # resp: data.links.url # 以兰空图床V2为例，下列填写内容为： # fileName: image # tokenName: token # api: https://xxxxxx/api/upload # token: xxxxxxxxxxxxxx # resp: data.url # fileName: # 根据版本二选一 # tokenName: # 根据版本二选一 # api: # 图床 api 地址 # token: # 图床验证 # resp: # 图片地址返回值的字段 # Artalk # https://artalk.js.org/ artalk: css: https://unpkg.com/artalk@2.8.5/dist/Artalk.css js: https://unpkg.com/artalk@2.8.5/dist/Artalk.js server: # 后端服务地址 placeholder: &#x27;&#x27; darkMode: auto ######## Footer ######## footer: social: # github: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg&quot;/&gt;&#x27; # url: / # music: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3845874.svg&quot;/&gt;&#x27; # url: / # unsplash: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3616429.svg&quot;/&gt;&#x27; # url: / # comments: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/942ebbf1a4b91.svg&quot;/&gt;&#x27; # url: /about/#comments # theme: # icon: default:theme # onclick: &#x27;switchTheme()&#x27; sitemap: # &#x27;博客&#x27;: # - &#x27;[近期](/)&#x27; # - &#x27;[分类](/)&#x27; # - &#x27;[标签](/)&#x27; # - &#x27;[归档](/)&#x27; # &#x27;项目&#x27;: # - &#x27;[开源库](/)&#x27; # &#x27;社交&#x27;: # - &#x27;[友链](/)&#x27; # - &#x27;[留言板](/)&#x27; # &#x27;更多&#x27;: # - &#x27;[关于本站](/)&#x27; # - &#x27;[GitHub](/)&#x27; content: | # 支持 Markdown 格式 本站由 [&#123;author.name&#125;](/) 使用 [&#123;theme.name&#125; &#123;theme.version&#125;](&#123;theme.tree&#125;) 主题创建。 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。 # 主题用户越多，开发者维护和更新的积极性就越高，如果您喜欢本主题，请在适当的位置显示主题信息和仓库链接以表支持。 ######## Tag Plugins ######## tag_plugins: # &#123;% box %&#125; / &#123;% note %&#125; note: default_color: &#x27;&#x27; # light, dark, red, orange, yellow, green, cyan, blue, purple, warning, error border: true # true / false # &#123;% checkbox %&#125; checkbox: interactive: false # enable interactive for user # &#123;% quot %&#125; quot: default: # 可以自行配置多种图标方案 prefix: https://bu.dusays.com/2022/10/24/63567d3e092ff.png suffix: https://bu.dusays.com/2022/10/24/63567d3e0ab55.png hashtag: prefix: https://bu.dusays.com/2022/10/24/63567d3e07da3.png question: prefix: ph:seal-question-fill # &#123;% emoji %&#125; emoji: default: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/&#123;name&#125;.gif twemoji: https://gcore.jsdelivr.net/gh/twitter/twemoji/assets/svg/&#123;name&#125;.svg qq: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/&#123;name&#125;.gif aru: https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/&#123;name&#125;.gif tieba: https://gcore.jsdelivr.net/gh/cdn-x/emoji/tieba/&#123;name&#125;.png blobcat: https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/&#123;name&#125;.png icon: # 留空时，图标和文字颜色相同 default_color: accent # theme, accent, red, orange, yellow, green, cyan, blue, purple # &#123;% button 标题 链接 %&#125; button: default_color: theme # theme, accent, red, orange, yellow, green, cyan, blue, purple # &#123;% image %&#125; image: fancybox: false # true, false # &#123;% copy xxx %&#125; copy: toast: 复制成功 # &#123;% timeline %&#125; timeline: max-height: 80vh # &#123;% mark %&#125; mark: default_color: yellow # light, dark, red, orange, yellow, green, cyan, blue, purple, warning, error # &#123;% hashtag %&#125; hashtag: default_color: # red, orange, yellow, green, cyan, blue, purple # &#123;% okr o1 percent:0.5 status:normal %&#125; okr: border: true # 是否显示边框 status: # 可以自行增加 # 进行中状态 in_track: color: blue # red, orange, yellow, green, cyan, blue, purple label: 正常 at_risk: color: yellow label: 风险 off_track: color: orange label: 延期 # 结果状态 finished: color: green label: 已完成 unfinished: color: red label: 未完成 # &#123;% gallery %&#125; gallery: layout: grid # grid / flow size: mix # s / m / l / xl / mix ratio: square # origin / square # 基础依赖 dependencies: jquery: https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js marked: https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js # 内置服务，按需加载（页面内用到了就会加载，没有用到就不会加载） data_services: # 外部 md 渲染 mdrender: js: /js/services/mdrender.js # 数据填充类 siteinfo: js: /js/services/siteinfo.js # 设置 api 可以自动提取网页标题、图标，服务部署方法：https://github.com/xaoxuu/site-info-api/ # 接口测试通过后，把按钮的 href 部分替换成 &#123;href&#125; 之后填写到下方，例如：https://api.vlts.cc/site_info/v1?url=&#123;href&#125; api: ghinfo: js: /js/services/ghinfo.js # 网格布局类 sites: js: /js/services/sites.js friends: js: /js/services/friends.js # 列表布局类 timeline: js: /js/services/timeline.js fcircle: js: /js/services/fcircle.js weibo: js: /js/services/weibo.js memos: js: /js/services/memos.js # 扩展插件接入方法：(插件名下面用 #plugin# 代替) # 1. 在这里增加 #plugin# 配置，至少赢含有 enable 字段，默认为空（不启用） # 2. 新建文件 layout/_plugins/#plugin#.ejs 文件中设置编写加载代码。 # 2.1. 在该文件中可以直接使用 conf 来读取用户在【步骤 1】填写的配置字段内容 # 2.2. 如果需要引入 css 或 js，可以使用 utils.css(xxx)、utils.js(xxx)，具体可参考 layout/_plugins/fancybox.ejs# 2.3. 如果需要本地 js 文件，请放入 /source/js/plugins 文件夹中，引入方式为：utils.js(&#x27;/js/plugins/xxx.js&#x27;); # 3. 如果这个插件只需要引入外部文件，可以在【步骤 1】处增加 inject 字段，而无需进入【步骤 2】创建 ejs，参考 katexplugins: # preload preload: enable: true service: flying_pages # flying_pages flying_pages: https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js # lazyload # https://www.npmjs.com/package/vanilla-lazyload lazyload: enable: true # [hexo clean &amp;&amp; hexo s] is required after changing this value. js: https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js transition: fade # blur, fade # https://fancyapps.com/docs/ui/fancybox/ # available for &#123;% image xxx %&#125; fancybox: enable: true loader: /js/plugins/fancybox-loader.js js: https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js css: https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css # 让 md 语法图片支持放大可以这样写: .md-text img:not([class]), .md-text .image img # 可以处理评论区的图片（不支持 iframe 类评论系统）例如： # 使用 twikoo 评论可以写: .tk-content img:not([class*=&quot;emo&quot;]) # 使用 waline 评论可以写: #waline_container .vcontent img selector: .timenode p&gt;img # 多个选择器用英文逗号隔开 # swiper swiper: enable: true css: https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css js: https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js # https://scrollrevealjs.org/api/reveal.html scrollreveal: enable: #true js: https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js distance: 16px duration: 800 # ms interval: 100 # ms scale: 1 # 0.1~1 # AI 摘要 # https://github.com/qxchuckle/Post-Summary-AI tianli_gpt: enable: #true js: https://jsd.onmicrosoft.cn/gh/qxchuckle/Post-Summary-AI@6.0/chuckle-post-ai.min.js field: post # all, post, wiki key: 5Q5mpqRK5DkwT1X9Gi5e # tianli_gpt key total_length: 1000 # 设置提交的字数限制，默认为1000字，上限为5000，超过5000字符将被截断 typewriter: true # 打字机动画 summary_directly: true # 是否直接显示摘要，否则显示 AI 简介 rec_method: all # all, web # 文章推荐方式，all：匹配数据库内所有文章进行推荐，web：仅当前站内的文章，默认all hide_shuttle: true # 是否隐藏矩阵穿梭 summary_toggle: false interface: name: AI摘要 introduce: &#x27;我是文章辅助AI: QX-AI，点击下方的按钮，让我生成本文简介、推荐相关文章等。&#x27; version: TianliGPT button: [&quot;介绍自己&quot;, &quot;推荐文章&quot;, &quot;生成摘要&quot;, &quot;矩阵穿梭&quot;] # Katex - The fastest math typesetting library for the web # https://katex.org/docs/autorender.html # https://github.com/KaTeX/KaTeX # 使用 hexo-renderer-markdown-it-plus 作为公式渲染器：npm uninstall hexo-renderer-marked --save npm install hexo-renderer-markdown-it-plus --save katex: enable: #true # hexo-renderer-markdown-it-plus 默认开启 katex，此选项仅用于引入样式 inject: | &lt;link rel=&quot;stylesheet&quot; href=&quot;https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css&quot; integrity=&quot;sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0&quot; crossorigin=&quot;anonymous&quot;&gt; # MathJax # 需在Markdown文件开头加入mathjax: true # 推荐使用Pandoc: npm uninstall hexo-renderer-marked --save &amp; npm install hexo-renderer-pandoc --save mathjax: enable: # true # 可以在特定文章的 front-matter 中设置 mathjax: true 来开启，也可以在这里设置全局开启 js: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML # Mermaid - markdwon to flow chart, seq chart, class chart ... # 需要安装 npm install --save hexo-filter-mermaid-diagrams # 使用时 需要在Markdown文件开头加入 mermaid: true # 使用示例： # ```mermaid # graph LR # A(Section A) --&gt;|option 1| B(Section A) # B --&gt;|option 2| C(Section C) # ``` mermaid: enable: # true # 可以在特定文章的 front-matter 中设置 mermaid: true 来开启，也可以在这里设置全局开启 style_optimization: false # use custom style in stellar # js: https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js js: https://cdn.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js # Available themes: default | dark | forest | neutral theme: neutral # 代码块复制按钮 copycode: enable: true default_text: &#x27;Copy&#x27; success_text: &#x27;Copied&#x27; toast: 复制成功 # 赫蹏 (Heti) - 专为中文网页内容设计的排版样式增强 # https://github.com/sivan/heti heti: enable: false # 此插件会和代码块冲突，仅适用于纯中文博主。 css: https://unpkg.com/heti@0.9.2/umd/heti.min.css js: https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js style: prefers_theme: auto # auto / light / dark smooth_scroll: false # true / false 开启时如果目录过长可能无法准确定位 font-size: root: 16px # 改这个会影响全局所有文字的字号 body: 17px # 影响正文区域的字号，如果改成 px 则不受 root 影响 code: 85% # 相较于其所在行的文本大小，建议用百分比 codeblock: 0.8125rem # 13px font-family: logo: &#x27;system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#x27; body: &#x27;system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#x27; code: &#x27;Menlo, Monaco, Consolas, system-ui, &quot;Courier New&quot;, monospace, sans-serif&#x27; codeblock: &#x27;Menlo, Monaco, Consolas, system-ui, &quot;Courier New&quot;, monospace, sans-serif&#x27; text-align: left prefix: h2: https://api.iconify.design/ci:heading-h2.svg border-radius: card-l: 16px # 侧边栏、文章横幅位置的圆角 card: 12px # 文章内大部分卡片的圆角 bar: 8px # 横条类元素的圆角 image: 12px # 图片圆角 color: # 动态颜色（会根据明暗主题重设明度值，只用关心色相和饱和度即可） background: &#x27;hsl(212 16% 98%)&#x27; # 浅色背景颜色 block: &#x27;hsl(212 8% 95%)&#x27; # 块背景颜色 code: &#x27;hsl(220 20% 10%)&#x27; # &#x27;hsl(14 100% 48%)&#x27; # 行内代码颜色 text: &#x27;hsl(0 0% 20%)&#x27; # 文本颜色 # 主题色配置（不会根据明暗动态调整，请设置为通用的颜色） theme: &#x27;hsl(192 98% 55%)&#x27; # 主题色 accent: &#x27;hsl(14 100% 57%)&#x27; # 强调色 link: &#x27;hsl(207 90% 54%)&#x27; # 超链接颜色 hover: &#x27;hsl(14 100% 57%)&#x27; # 按钮高亮颜色 animated_avatar: animate: auto # auto, always background: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp codeblock: scrollbar: 4px highlightjs_theme: https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css loading: loading: 正在加载 error: 加载失败，请稍后重试。 gradient: # https://webgradients.com/ start: &#x27;linear-gradient(to right, hsl(215, 95%, 64%), hsl(195, 95%, 60%), hsl(165, 95%, 56%), hsl(165, 95%, 56%), hsl(195 95% 60%), hsl(215, 95%, 64%))&#x27; leftbar: # 可以设置：纯色/渐变色/图片作为背景 # background: var(--leftbar-bg) background-image: url(/images/background.png) blur-px: 200px blur-bg: var(--alpha50) paginator: prev: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/arrow/f049bbd4e88ec.svg next: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/arrow/064b95430caf4.svg error_page: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/404/1c830bfcd517d.svg site: background-image: #&#x27;url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.14/image/site-bg1@small.webp)&#x27; # 未完全适配，慎用 blur-px: 100px blur-bg: var(--alpha75) default: avatar: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg link: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg cover: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg image: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg project: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2779789.png banner: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/banner/books.jpg topic: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/10433048.png api_host: ghapi: https://api.github.com ghraw: https://raw.githubusercontent.com gist: https://gist.github.com 自动化自动同步把博客的source和笔记的进行同步，比如：D:\\My\\Notes\\_source ---- D:\\My\\blog\\source。我这里使用FreeFileSync同步电脑本地目录，下载地址https://freefilesync.org/。 打开绿色的，拖动两个要同步的目录，就双向同步就行，保存下来。然后打开红色的，把保存下来的文件拖进去，点击开始进行自动同步。然后创建快捷方式，打开 win+r 输入 shell:startup ，把快捷方式拖进去。 自动发布编写脚本：注意日志路径，同样创建快捷方式，把它放大笔记的某个地方，点击就可以推送到github和oss 123456789101112131415161718192021222324252627282930#!/bin/bash # 设置日志文件路径（将路径替换为你想保存日志的实际路径） LOGFILE=&quot;D:/My/Notes/_drafts/deploy_log.txt&quot; # 确保日志文件为空并设置为 UTF-8 编码 : &gt; &quot;$LOGFILE&quot; # 清空文件内容 # 清理 Hexo 生成的文件 echo &quot;正在执行 hexo clean...&quot; | tee -a &quot;$LOGFILE&quot; if ! hexo clean 2&gt;&amp;1 | tee -a &quot;$LOGFILE&quot;; then echo &quot;hexo clean 执行失败，脚本终止。&quot; | tee -a &quot;$LOGFILE&quot; exit 1 fi # 生成静态文件 echo &quot;正在执行 hexo generate...&quot; | tee -a &quot;$LOGFILE&quot; if ! hexo generate 2&gt;&amp;1 | tee -a &quot;$LOGFILE&quot;; then echo &quot;hexo generate 执行失败，脚本终止。&quot; | tee -a &quot;$LOGFILE&quot; exit 1 fi # 部署生成的文件到指定的目标位置 echo &quot;正在执行 hexo deploy...&quot; | tee -a &quot;$LOGFILE&quot; if ! hexo deploy 2&gt;&amp;1 | tee -a &quot;$LOGFILE&quot;; then echo &quot;hexo deploy 执行失败，脚本终止。&quot; | tee -a &quot;$LOGFILE&quot; exit 1 fi echo &quot;所有任务完成！&quot; | tee -a &quot;$LOGFILE&quot; nginx代理详细见 nginx 章节。这里注意如果是要访问oss，那么需要在nginx.conf 里设置 user 为root 身份进行运行。 配置文件如下：配置文件在&#x2F;etc&#x2F;nginx&#x2F;conf.d里。而nginx.conf 在其上一级目录 12345678910111213141516# blogserver &#123; listen 443 ssl; server_name www.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; # 我这里是oss目录 root /home/data/blog; index index.html index.htm; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 示例图：ps aux | grep nginx","tags":[null,null,null,null,null],"categories":[null]},{"title":"基于syncthing+oss+云服务器的文件同步与数据备份教程","path":"/workflow/Syncthing.html","content":"摘要从需求分析到具体实现，快速实现基于syncthing+oss+云服务器的文件同步与数据备份，此专栏的目的是充分利用云服务器，所以没有选择CDN，而是通过oss内外访问云服务，以云服务器为出口进行同步。 前言需求 数据安全，最重要的一个需求 备份容量，目前需求100G左右 价格不贵，百度云vip188&#x2F;年，以他为标准，浮动100左右 下载速度快，最起码别是100多kb&#x2F;s 可预览，可以线上看看图片、视频什么的 多端同步：最起码要可以把手机和电脑数据同步起来，最起码要有版本控制，以及多种同步类型 自动备份：要能自动备份多个不同的文件夹，比如图片、文档什么的 思路 Syncthing 是多端同步的工具，其功能类似于微力同步，但是开源，他是P2P的，这样就要求两个设备必须同时在线。 使用云服务器搭建Syncthing作为中转和备份服务器，这样就可以只一个设备在线，因为云服务器是不停机的 如果是需要经常同步的我选择直接存在服务器的云盘里 如果是备份，我在云服务器里挂载OSS为目录，通过内网访问OSS，这样就没有流量费用 使用alist挂载云服务器本地目录+rclone挂载Alist到电脑进行预览（可选） 页面展示Syncthing - 服务器 Syncthing - 电脑 Syncthing - 安卓 效果展示 服务器带宽 30M ，同步和备份时速度可接受，内存占用为100M以内 存储容量：云盘自带60G+OSS的40G &#x3D; 100G 电脑开机自启：Syncthing，完全无感 手机可以后台常驻运行Syncthing，记得开启允许后台高耗电，以及设置息屏联网，实现无感同步。 优点 可以无感备份与同步任何文件！ 速度取决于你的服务器，无限速问题 数据很安全，用的都是开源项目，数据放在阿里云的服务器和OSS里，如果还不放心可以增加容灾设计 可玩性较高，几乎完全满足需求！ 手机可以常驻后台备份！ 缺点 折腾起来比较麻烦 手机常驻后台会增加发热问题 syncthing 同步和冲突处理没有那么细的粒度 拓展 有时间可以整一个一键脚本，直接部署 香港服务器都有了，顺便整点魔法 整一个服务器监控看板 把UI面版都整上Https 如果想可以设计docker进行部署，需要注意容器编排和目录映射问题 准备好了吗！发车！ 核心：Syncthing 需要：云服务器，OSS对象存储，电脑，手机 数据安全：数据为本地存储，云端则为阿里云服务器+OSS，次方案使用的项目均为开源项目 我的配置：阿里云香港轻量服务器（debian11），9元一年OSS标准存储资源包，Win10笔记本，安卓手机 实际花费：阿里云香港轻量服务器 288&#x2F;年就够用了，我买的是408.00一年的那个 建议选择带宽较大的轻量服务器，大可以选择自己觉得便宜和稳定的，注意：服务器和oss存在地域问题！选同一个地域的，不然要nginx代理。 实操安装Syncthing服务器直接安装123456789101112131415161718192021222324252627282930cd /home# https://github.com/syncthing/syncthing/releaseswget https://github.com/syncthing/syncthing/releases/download/v1.27.10/syncthing-linux-amd64-v1.27.10.tar.gz# 解压tar -xzvf syncthing-linux-amd64-v1.27.10.tar.gz# 删除压缩包rm -f syncthing-linux-amd64-v1.27.10.tar.gz# 重命名(可选)mv /home/syncthing-linux-amd64-v1.27.10 /home/syncthing# 创建日志文件mkdir /home/logs/sudo touch /home/logs/syncthing.log# 修改`/home/username/.config/syncthing/config.xml`中的`gui`标签，把`127.0.0.1`改成`0.0.0.0`，开启远程访问# 如果你的usernam为root，那么config.xml在/root/.local/state/syncthing# 可选的！后续会开启反向代理vim /root/.local/state/syncthing/config.xml# 官方文档：https://docs.syncthing.net/users/stdiscosrv.html# 后台运行cd /home/syncthingnohup ./syncthing &gt; /home/logs/syncthing.log 2&gt;&amp;1 &amp;# 使用jobs查看运行情况jobs# 查看日志cat /home/logs/syncthing.log docker-compose 安装# 目录：/home/docker/syncthingmkdir /home/docker/syncthingcd /home/docker/syncthingvi docker-compose.yml 123456789101112131415161718services: syncthing: image: syncthing/syncthing:latest container_name: syncthing hostname: syncthing #optional restart: always mem_limit: 120m memswap_limit: -1 user: root environment: - PUID=1000 - PGID=1000 - TZ=Asia/Shanghai volumes: - ./syncthing:/var/syncthing - /home/data:/home/data # 此次配置额外添加的路径 ports: - &#x27;8384:8384&#x27; # 面版端口 PC访问：Github下载windows版本的Syncthing，直接运行即可 开机自启，后台运行： 创建bat文件写入 start &quot;Syncthing&quot; syncthing.exe -no-console -no-browser 创建快捷方式后，Win+R 输入 shell:startup，把快捷方式拖进去 Android访问：Github下载android版本的Syncthing，直接运行即可，给足权限，让他常驻后台 服务器挂载OSSoss的创建与配置资源包购买：https://oss.console.aliyun.com/packagebucket创建：https://oss.console.aliyun.com/bucket 名称随意 地域选择和自己服务器相同的地方 私有读写即可，因为我们是通过服务器出的公网流量，服务器和oss之间的访问用内网就行了，免费且高速，缺点是oss的访问速度全看服务器的带宽了。 示例：ECS地域OSS地域 挂载OSS到ECS12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 进入目录cd /home# 更新索引sudo apt-get -y update # 安装ossfssudo apt-get install automake autotools-dev g++ git libcurl4-gnutls-dev \\ libfuse-dev libssl-dev libxml2-dev make pkg-config# 克隆编译代码git clone https://github.com/aliyun/ossfs.gitcd ossfs./autogen.sh./configuremakesudo make install# 配置全局密钥，输入OSS对应的key和secret，不知道怎么获取看这个：# https://blog.csdn.net/weixin_45606067/article/details/114292972# my-access-key-id 你的key # my-access-key-secret 你的secret# my-bucket是你的存储空间名称echo my-bucket:my-access-key-id:my-access-key-secret &gt; /etc/passwd-ossfs# 也可以进行编辑vim /etc/passwd-ossfschmod 600 /etc/passwd-ossfs# 挂载oss目录# /path/to/mountpoint是你挂载到的服务器上的目录# my-oss-endpoint是你oss的访问域，一定要选内网的！ossfs my-bucket /path/to/mountpoint -ourl=my-oss-endpoint# 示例mkdir /home/data/blogossfs my-notes-blog /home/data/blog -ourl=oss-cn-hongkong-internal.aliyuncs.com# 查看挂载情况（可选）df | grep ossfs# 详细情况（可选）# /root/Data/OSS 是挂载的路径df -hT /root/Data/OSS# 删除挂载点（可选）sudo umount /root/Data/OSS 123456789101112131415161718192021222324252627282930313233# 项目地址https://github.com/aliyun/ossfs/releases# 安装命令，需要和上面项目地址查询出版本对应mkdir /home/ossfssudo wget -P /home/ossfs https://gosspublic.alicdn.com/ossfs/ossfs_1.91.3_ubuntu16.04_amd64.debsudo apt-get updatesudo apt-get install gdebi-coresudo gdebi ossfs_1.91.3_ubuntu16.04_amd64.deb### 1.将账号信息保存到账号信息配置文件/etc/passwd-ossfs下，并设置文件权限为640echo bucket-test-1:AAAI************:AAA8x************************* &gt; /etc/passwd-ossfsecho bucket-test-2:BBBI************:BBB8x************************* &gt;&gt; /etc/passwd-ossfschmod 640 /etc/passwd-ossfs### 2.创建挂载目录，将杭州地域名称为bucket-test-1、bucket-test-2的bucket分别挂载到/tmp/ossfs-1、/tmp/ossfs-2目录下mkdir /tmp/ossfs-1mkdir /tmp/ossfs-2ossfs bucket-test-1 /tmp/ossfs-1 -ourl=http://oss-cn-hangzhou.aliyuncs.comossfs bucket-test-2 /tmp/ossfs-2 -ourl=http://oss-cn-hangzhou.aliyuncs.com## 将账号信息保存到账号信息配置文件/etc/passwd-ossfs-3下，并设置文件权限为600echo bucket-test-3:CCCIbZcdVCmQ****:CCC8x0y9hxQ31coh7A5e2MZEUz**** &gt; /etc/passwd-ossfs-3chmod 600 /etc/passwd-ossfs-3\t##创建挂载目录，将杭州地域名称为bucket-test-3的bucket挂载到/tmp/ossfs-3目录下 mkdir /tmp/ossfs-3ossfs bucket-test-3 /tmp/ossfs-3 -ourl=http://oss-cn-hangzhou.aliyuncs.com -opasswd_file=/etc/passwd-ossfs-3## 将账号信息保存到账号信息配置文件/etc/passwd-ossfs-4下，并设置文件权限为600echo bucket-test-4:DDDIbZcdVCmQ****:DDD8x0y9hxQ31coh7A5e2MZEUz**** &gt; /etc/passwd-ossfs-4chmod 600 /etc/passwd-ossfs-4##创建挂载目录，将杭州地域名称为bucket-test-4的bucket挂载到/tmp/ossfs-4目录下mkdir /tmp/ossfs-4ossfs bucket-test-4 /tmp/ossfs-4 -ourl=http://oss-cn-hangzhou.aliyuncs.com -opasswd_file=/etc/passwd-ossfs-4 注意我这里挂载了两个目录，syncthing使用的oss和我后续博客上推使用的oss是两个不同的存储空间，但是都是和服务器在同一个地域 配置Syncthing搭建发现服务器先通过发现服务器 (Discosrv)发现和索引用户，当用户设备接入发现服务器后，服务器会进行设备的连接通告，当设备之间同意连接后进行连接；两台设备建立连接后，数据需要通过 NAT 穿透的方式实现交换。 1234567891011121314151617181920212223cd /home/syncthing# 仓库在：https://github.com/syncthing/discosrv/releases，想用新的直接换新链接就行wget https://github.com/syncthing/discosrv/releases/download/v1.23.4/stdiscosrv-linux-amd64-v1.23.4.tar.gz# 解压tar -xzvf stdiscosrv-linux-amd64-v1.23.4.tar.gz# 删除压缩包rm -f stdiscosrv-linux-amd64-v1.23.4.tar.gz# 重命名(可选)mv stdiscosrv-linux-amd64-v1.23.4 stdiscosrv# 创建日志文件sudo touch /home/logs/stdiscosrv.log# 官方文档：https://docs.syncthing.net/users/stdiscosrv.html# 后台运行cd stdiscosrvnohup ./stdiscosrv &gt; /home/logs/stdiscosrv.log 2&gt;&amp;1 &amp;# 使用jobs查看运行情况jobs# 查看日志cat /home/logs/stdiscosrv.log 搭建中继节点如果 NAT 穿透不成功，就需要中继 (Relaysrv)服务器传输数据，假如电脑要和手机进行笔记同步，通信过程就是：电脑-中继-手机，当然Syncthing自带有公共网络服务，但是此文章使用云服务器就是为了搭建一个中继的通信过程 1234567891011121314151617181920212223242526cd /home/syncthing# 仓库在：https://github.com/syncthing/discosrv/releases，想用新的直接换新链接就行wget https://github.com/syncthing/relaysrv/releases/download/v1.22.1/strelaysrv-linux-amd64-v1.22.1.tar.gz# 解压tar -xzvf strelaysrv-linux-amd64-v1.22.1.tar.gz# 删除压缩包rm -f strelaysrv-linux-amd64-v1.22.1.tar.gz# 重命名(可选)mv strelaysrv-linux-amd64-v1.22.1 strelaysrv# 创建日志文件sudo touch /home/logs/strelaysrv.log# 运行 # https://docs.syncthing.net/users/strelaysrv.html# pools为空是不加入公共中继节点，部署为私有cd strelaysrvnohup ./strelaysrv -pools=&quot;&quot; &gt; /home/logs/strelaysrv.log 2&gt;&amp;1 &amp;# 使用jobs查看运行情况jobs# 查看日志cat /home/logs/strelaysrv.log 可以先配置反向代理和泛域名证书，详细见nginx章节，配置文件如下： 123456789101112# syncthingserver &#123; listen 443 ssl; server_name sync.exp.com; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8384/; &#125;&#125; 再回来配置syncthing，记得给电脑、服务器、手机都配置一下，协议监听地址对应中继节点地址，全局发现服务器和全局发现的地址。还有记得开放端口：22067&#x2F;tcp 和 8443&#x2F;tcp 123456789101112# 查看日志cat /home/logs/strelaysrv.logcat /home/logs/stdiscosrv.log# 协议监听地址，中继服务URI relay://公网IP:22067?id=中继服务器device ID relay://0.0.0.0:22067/?id=DGSNZJM-MASJL6U-WJJA2RJ-GDTAALI-JZOF6NS-KPPDNQU-T4TV7OQ-YK6ATAM&amp;networkTimeout=2m0s&amp;pingInterval=1m0s&amp;statusAddr=%3A22070# 全局发现服务器 https://公网IP:8443/?id=发现服务器device ID 记得每个安装了sync的设备都要设置！ 配置说明举个例子：文件夹路径是本地计算机的路径，比如我们现在需要电脑同步到服务器，那么过程就是 打开电脑上的 syncthing http://127.0.0.1:8384/，添加文件夹，路径选择自己电脑本地的要上传的文件路径，如：D:\\My\\Notes，在共享里选择服务器上的 syncthing 打开服务器上的 syncthing ，你会看到发过来的共享请求，那么在接受后的配置里面，选择你需要保存在服务器上的地址，比如挂载后的OSS地址或者服务器的其他地方 现在如果你需要再同步给手机，那么就选择服务器上电脑发过来的共享文件夹，同样的点击共享就可以分享到手机","tags":[null,null,null,null,null,null],"categories":[null]},{"title":"充分利用云服务器！如何围绕云服务器搭建自己的工作流","path":"/workflow/Workflow.html","content":"需求 实现笔记和其他文件的同步与备份 实现笔记和博客的融合，可以很方便的进行编辑、修改、发布 实现博客和个人简历的融合 科学上网 密码管理 思路围绕云服务器进行多端同步的思路展开与工作流构建。包含大致功能如下： 同步与备份：通过搭建Syncthing的中继服务器和发现服务器，把手机、电脑、pad、服务器联系起来，其中云服务器不但可以中转、存储还能通过内网访问挂载到服务器的oss，以增加存储空间实现备份效果 预览与下载：通过Alist挂载服务器目录，配合重定向实现在浏览器上预览的图床功能，当然下载功能也不在话下。 笔记：通过Obsidian写笔记，因为笔记数据按照文件夹的形式进行本地存储，所以可以通过相对链接渲染图片、视频等，如果要放其他格式文档，比如pdf、xmind文档等，则可以从alist上获取下载链接。 博客：使用hexo静态博客，主题为Stellar。本地编译，通过同步可以把实现在Obsidian的笔记目录下写完文章自动同步到博客的目录下，再配合脚本与插件实现一件编写、发布、修改、推送一条路服务，真正把博客和笔记相互交融！ 密码管理：使用Bitwardn 自建后台服务，把密码放在自己的服务上。 科学上网：使用3-xui搭建节点，配合v2rayN实现科学上网。其中整理了部分节点种类，实现链式代理。 服务器安全与运维：因为我搭建没有采用docker进行搭建，搭建完些占用也才30%左右，而docker虽然更好管理但是占用更高。其中安全需要尽量被攻击，一般就是ddos攻击，然后对运行的服务进行监控、日志的处理、数据的备份、服务器碎片文件的处理等（待更新） SEO：搜索优化，博客都搭起来了怎么能不让别人看到，除了在csdn、掘金等其他博文聚集地发送博客引流，也需要让搜索引擎收录并放在前面。（待更新） 准备 服务器：我的是阿里云香港轻量服务器2H2G，34&#x2F;月。 oss：阿里云标准存储数据包，9&#x2F;年 知道怎么获得阿里云子用户的ccessKey ID 和 AccessKey Secret，以及对其进行授权 vscode或者webstorm，以及本地node环境，在hexo编译的时候可以用 遇到问题可以在博客评论，也可以直接发邮件问，建议先搜一下 常见问题使用密码无法远程链接登录服务器原因可能是服务器PasswordAuthentication参数为no 解决123456# 查看`/etc/ssh/sshd_config`的参数`PasswordAuthentication`配置是否有误。cat /etc/ssh/sshd_config# 将`PasswordAuthentication no`修改为`PasswordAuthentication yes`。sudo vim /etc/ssh/sshd_config# 重启SSHD服务使配置生效。sudo systemctl restart sshd.service 同步到oss目录失败，无法访问、未找到目录原因可能是用户权限不够，可以看看访问oss的应用，比如nginx，运行时的角色是什么，一般root角色才能访问访问挂载的oss目录 解决123456# 使用root用户启动应用，可以使用下面命令查看# 很详细sudo apt install htop# 看自己无法访问oss的服务是不是root用户htop nginx 出现 502错误一般是服务器网络问题，请求走不通。 先使用：curl http://127.0.0.1:端口查看服务是否运行 在确认自己的服务是docker部署还是直接安装，如果docker部署是需要使用 ip addr 命令查看docker0的ip地址，不能用127.0.0.1","tags":[null,null,null,null,null,null,null,null,null,null],"categories":[null]},{"title":"多种方法搭建私有bitwardn服务器   bitwarden & Vaultwarden","path":"/workflow/Bitwarden.html","content":"摘要开源的密码管理工具，我们搭建的是私有服务器，可以在手机下载对应应用以及在浏览器下载对应插件对私有服务器进行链接 搭建docker-compose 搭建注意看环境配置，一般DOMAIN、ADMIN_TOKEN和SIGNUPS_ALLOWED需要修改，建议在第一次部署的时候设置SIGNUPS_ALLOWED为true，创建账户后设置为false 1234567891011121314151617181920212223242526services: vaultwarden: container_name: vaultwarden image: vaultwarden/server:latest restart: always volumes: - ./data:/data ports: - &#x27;8385:80&#x27; environment: - DOMAIN=https://pwd.exp.com # 这是您希望与您的Vaultwarden实例关联的域名。 - LOGIN_RATELIMIT_MAX_BURST=10 # 允许在一阵登录/两步验证尝试中的最大请求次数。 - LOGIN_RATELIMIT_SECONDS=60 # 这是来自同一IP的登录请求之间的平均秒数，在Vaultwarden限制登录次数之前。 - ADMIN_RATELIMIT_MAX_BURST=10 # 这与LOGIN_RATELIMIT_MAX_BURST相同，只争对admin面板。 - ADMIN_RATELIMIT_SECONDS=60 # 这与LOGIN_RATELIMIT_SECONDS相同 - ADMIN_SESSION_LIFETIME=20 # 会话持续时间 - ADMIN_TOKEN=aaa # 此值是Vaultwarden管理员面板的令牌（一种密码）。为了安全起见，这应该是一个长的随机字符串。如果未设置此值，则管理员面板将被禁用。建议openssl rand -base64 48 生成ADMIN_TOKEN确保安全 - SENDS_ALLOWED=true # 此设置决定是否允许用户创建Bitwarden发送 - 一种凭证共享形式。 - EMERGENCY_ACCESS_ALLOWED=true # 此设置控制用户是否可以启用紧急访问其账户的权限。例如，这样做可以在用户去世后，配偶可以访问密码库以获取账户凭证。可能的值：true / false。 - WEB_VAULT_ENABLED=true # 此设置决定了网络保险库是否可访问。一旦您配置了您的账户和客户端，停止您的容器，然后将此值切换为false并重启Vaultwarden，可以用来防止未授权访问。可能的值：true/false。 - SIGNUPS_ALLOWED=false # 此设置控制新用户是否可以在没有邀请的情况下注册账户。可能的值：true / false。 logging: driver: json-file options: max-size: &quot;1m&quot; max-file: &quot;3&quot; 直接搭建12345678910111213141516171819# 创建文件夹mkdir /home/vw-imagecd /home/vw-image# 拉取可执行文件wget https://raw.githubusercontent.com/jjlin/docker-image-extract/main/docker-image-extract# 给运行权限chmod +x docker-image-extract# 提取docker中的可执行程序./docker-image-extract vaultwarden/server:alpine# 拷贝文件和目录mkdir -p /home/vaultwardencd output/# 将需要用到的 文件和目录拷贝到前面建好的目录cp -rf vaultwarden web-vault/ data/ /home/vaultwarden/# 下载环境配置文件wget https://raw.githubusercontent.com/dani-garcia/vaultwarden/main/.env.template -O vaultwarden.env 修改配置文件，直接复制在顶部就行，主要修改DOMAIN、ADMIN_TOKEN、SIGNUPS_ALLOWED 1234567891011121314151617181920212223242526272829# 这是您希望与您的Vaultwarden实例关联的域名。DOMAIN=https://bitwt.exp.top # 允许在一阵登录/两步验证尝试中的最大请求次数。LOGIN_RATELIMIT_MAX_BURST=10# 这是来自同一IP的登录请求之间的平均秒数，在Vaultwarden限制登录次数之前。LOGIN_RATELIMIT_SECONDS=60 # 这与LOGIN_RATELIMIT_MAX_BURST相同，只争对admin面板。ADMIN_RATELIMIT_MAX_BURST=10 # 这与LOGIN_RATELIMIT_SECONDS相同ADMIN_RATELIMIT_SECONDS=60 # 会话持续时间ADMIN_SESSION_LIFETIME=20 # 此值是Vaultwarden管理员面板的令牌（一种密码）。为了安全起见，这应该是一个长的随机字符串。如果未设置此值，则管理员面板将被禁用。## 建议openssl rand -base64 48 生成ADMIN_TOKEN确保安全ADMIN_TOKEN=# 此设置决定是否允许用户创建Bitwarden发送 - 一种凭证共享形式。SENDS_ALLOWED=true# 此设置控制用户是否可以启用紧急访问其账户的权限。例如，这样做可以在用户去世后，配偶可以访问密码库以获取账户凭证。可能的值：true / false。EMERGENCY_ACCESS_ALLOWED=true # 此设置决定了网络保险库是否可访问。一旦您配置了您的账户和客户端，停止您的容器，然后将此值切换为false并重启Vaultwarden，可以用来防止未授权访问。可能的值：true/false。WEB_VAULT_ENABLED=true # 此设置控制新用户是否可以在没有邀请的情况下注册账户。可能的值：true / false。SIGNUPS_ALLOWED=true# 给web端发送通知用的WEBSOCKET_ENABLED=true# IP地址WEBSOCKET_ADDRESS=0.0.0.0# 运行端口WEBSOCKET_PORT=8000 创建启动脚本 vim /etc/systemd/system/vaultwarden.service 12345678910111213141516171819202122232425262728293031323334[Unit]Description=vaultwarden Server (Rust Edition)Documentation=https://github.com/dani-garcia/vaultwarden# Only sqliteAfter=network.target network-online.targetRequires=network-online.target# MariaDB# After=network.target mariadb.service# Requires=mariadb.service# Mysql# After=network.target mysqld.service# Requires=mysqld.service# PostgreSQL# After=network.target postgresql.service# Requires=postgresql.service[Service]# The location of the .env file for configurationEnvironmentFile=/home/vaultwarden/vaultwarden.env# The location of the compiled binaryExecStart=/home/vaultwarden/vaultwarden# Set reasonable connection and process limitsLimitNOFILE=1048576LimitNPROC=64# Only allow writes to the following directory and set it to the working directory (user and password data are stored here)WorkingDirectory=/home/vaultwarden[Install]WantedBy=multi-user.target 启动 12345678# 重载配置文件systemctl daemon-reload# 启动sudo systemctl start vaultwarden.service# 删除/home/vw-imagerm -rf /home/vw-image 配置反向代理123456789101112#bitwortenserver &#123; listen 443 ssl; server_name bitwt.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8000/; &#125;&#125;","tags":[null,null,null],"categories":[null]}]
[{"title":"(三). 夯实基础 - Java 常见面试题","path":"/JavaSE-Java基础面试.html","content":"源文件地址：java知识框架 前言 是什么 怎么用 底层&#x2F;原理&#x2F;实现 优缺点 延伸拓展 Java概述Java语言和C语言有哪些区别？ 面向过程：比如需要把大象塞进冰箱，一共是打开冰箱，塞进大象，关闭冰箱三步，关注的是大象塞进冰箱的过程 面向对象：同样的需要把大象塞进冰箱，就需要 New 大象对象、冰箱对象，基于两个对象进行操作 C语言是面向过程的语言，Java是面向对象，Java不提供指针直接访问内存，Java有自动内存管理机制 JVM、JDK 和 JRE 有什么区别？ JVM：Java Virtual Machine，也就是 Java 虚拟机，是 Java 实现跨平台的关键所在，针对不同的操作系统，有不同的 JVM 实现。JVM 负责将 Java 字节码转换为特定平台的机器码，并执行。 JRE：Java Runtime Environment，也就是 Java 运行时环境，包含了运行 Java 程序所必需的库，以及 Java 虚拟机（JVM）。 JDK：Java Development Kit，是一套完整的 Java SDK（软件开发工具包），包括了 JRE 以及编译器（javac）、Java 文档生成工具（Javadoc）、Java 调试器等开发工具。为开发者提供了开发、编译、调试 Java 程序的一整套环境。 JDK是完整的软件开发工具包，JRE是 Java 运行时环境，JVM是 Java 虚拟机，JDK 包含 JRE，JRE 包含 JVM。 说说什么是跨平台性？原理是什么 字节码是把源码 .java 通过jdk中的Javac编译成虚拟机可以识别的 .class 文件 （编译） 其中Java虚拟机就是把字节码转化为特定平台的机器码 （解释） 对应的机器执行二进制机器码 （执行） 一次编译后，可以在多个系统平台上运行。Java 程序是通过 Java 虚拟机在系统平台上运行的，只要该系统可以安装相应的 Java 虚拟机，该系统就可以运行 java 程序。 基础语法什么是自动拆箱&#x2F;装箱？为什么拆箱就是将包装类型对象转换为其对应的基本数据类型，而装箱则是将基本数据类型转换为相应的包装类型对象。 好处： 包装类型可以为 null，而基本数据类型不可以，这使得包装类型可以应用于 POJO 中，而基本数据类型则不行，因为数据库的查询结果可能是 null，如果使用基本数据类型的话，因为要自动拆箱，就会抛出 NullPointerException(空指针异常) 的异常。 包装类型可用于泛型，而基本数据类型不可以，因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本数据类型是个例外。 什么是泛型？泛型擦除是什么？使用类型参数解决了元素的不确定性——参数类型为 String 的集合中是不允许存放其他类型元素的，取出数据的时候也不需要强制类型转换了。Java 虚拟机会将泛型的类型变量擦除，并替换为限定类型（没有限定的话，就用 Object）。但是也存在一定问题，比如String 和 Date 是不同的类，他们分别作为ArrayList的限定类型时，编译后进行类型擦除，其中类型变量 String 和 Date都会消失。 这就可能让重载的方法编译成相同的方法导致编译失败。 自动类型转换、强制类型转换？1字节&#x3D;8bit &#x3D;二进制&#x3D;&gt;2^8 个数 就好比小杯水倒入大杯水、大杯水倒入小杯水，其中主要关注强制类型转换，比如把double转为float，也就是把双精度转为单精度就会导致精度丢失，在short类型在和int类型运算的时候运算结果会自动转化为int类型等 需要注意：默认情况下，没有后缀的浮点数字面量会被视为double类型。如果带有f或F后缀，则被视为float类型。所以float f&#x3D;3.4;是错误的。 char型变量中能不能存贮一个中文汉字?和int类型可以互转吗？char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。其中char类型转int（可发生自动转换）会输出其编码对应的值，同理int转char需要强制转换。 &amp;和&amp;&amp;有什么区别？ &amp; 是逻辑与，如果第一个条件如果不成立，还会进行下一个条件的比较，这里如果有username != null &amp; !username.equals(&quot;&quot;) 根本不能进行字符串的 equals 比较，否则会产生NullPointerException 异常。 &amp;&amp; 是短路运算，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;。 逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 &amp;是逻辑与，&amp;两边的条件都会进行判断；&amp;&amp;是短路与，如果&amp;&amp;的第一个条件为true才会进行下一个条件判断。 switch 是否能作用在 byte&#x2F;long&#x2F;String 上？ Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。 从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。 从 Java 7 开始，expr 还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的。 Java5以前就可以使用byte数据类型，Java5的时候支持了枚举类型，Java7开始支持字符串类型他是通过hashcode来进行比较的，但是目前Java不支持Long类型，因为switch语句要求条件表达式是一个32位的整数类型，而long类型是64位的整数类型。 用最有效率的方法计算 2 乘以 8？ 算速运算符、逻辑运算符、位运算符、逻辑运算符、赋值运算符、三元运算符 按位与操作符：&amp;，它用于将两个操作数的每一位进行对比。如果两个操作数的对应位都是1，则结果为1，否则结果为0。 按位或操作符：|，它用于将两个操作数的每一位进行对比。如果两个操作数的对应位只要有一个是1，则结果为1，否则结果为0。 按位异或操作符：^，它用于将两个操作数的每一位进行对比。如果两个操作数的对应位相同，则结果为0，否则结果为1。 按位取反操作符：~，它用于将操作数的每一位进行取反操作，即1变为0，0变为1。 左移位操作符： &lt;&lt;，它用于将操作数的二进制值向左移动指定的位数。左移位操作符的结果是原来的值乘以2的移位数次幂。 右移位操作符： &gt;&gt;，它用于将操作数的二进制值向右移动指定的位数。右移位操作符的结果是原来的值除以2的移位数次幂。 无符号右移位操作符： &gt;&gt;&gt;，它用于将操作数的二进制值向右移动指定的位数，但是它会在空位上插入0，而不是符号位的复制。 位运算直接操作内存中的二进制位，因此它们在硬件层面上非常高效，并且位运算不涉及溢出问题。 说说自增自减运算？ 当运算符放在变量之前时(前缀)，先自增&#x2F;减，再赋值 当运算符放在变量之后时(后缀)，先赋值，再自增&#x2F;减。 对于 JVM 而言，它对自增运算的处理，是会先定义一个临时变量来接收 i 的值，然后进行自增运算，最后又将临时变量赋给了 i 1234567891011121314151617181920212223public static void main(String[] args) &#123; int count = 0; for(int i = 0;i &lt; 100;i++) &#123; count = count++; // count = autoAdd(count); &#125; System.out.println(&quot;count = &quot;+count); &#125;// count++ 等同于static int autoAdd(int count) &#123; int temp = count; count = count + 1; return temp; &#125;// ++count 等同于static int autoAdd(int count) &#123; count = count + 1; int temp = count; return temp; &#125; 综上所诉：前++，先自增，再赋值，反之亦然 讲一下数据准确性高是怎么保证的？在金融计算中，保证数据准确性有两种方案，一种使用 BigDecimal，BigDecimal在计算时，实际会把数值扩大10的n次倍，变成一个long型整数进行计算，整数计算时自然可以实现精度不丢失。一种将浮点数转换为整数 int 进行计算。肯定不能使用 float 和 double 类型，它们无法避免浮点数运算中常见的精度问题，在处理小额支付或计算时，通过转换为较小的货币单位（如分），这样不仅提高了运算速度，还保证了计算的准确性。 Math.round(11.5) 等于多少？Math.round(-11.5) 等于多少 Math.round(11.5) &#x3D; 12 Math.round(-11.5) &#x3D; -11 假如画一个从左到右的数轴，Math.round的取值是向右靠的，负数靠近0，正数靠近正无穷。 面向对象面向对象编程有哪些特性？面向对象编程有三大特性：封装、继承、多态。 封装：数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。好处是减少耦合、隐藏信息和实现细节、类内部的结构可以自由修改、可以对成员进行更精确的控制，比如限定成员变量范围什么的。 继承：复用以前的代码，使用继承不仅大大的减少了代码量，也使得代码结构更加清晰可见。 多态：允许不同类的对象对同一消息做出响应，但表现出不同的行为（即方法的多样性），执行一段代码，Java 在运行时能根据对象类型的不同产生不同的结果 多态的目的？解决了什么问题是为了提高代码的灵活性和可扩展性，使得代码更容易维护和扩展。比如说动态绑定，允许在程序在运行时再确定调用的是子类还是父类的方法。 说说重载、重写的关系与区别。 重载（overload）：一个类里有多个名字相同但参数个数不同的方法 重写（override）：子类具有和父类一样的方法（参数相同、返回类型相同、方法名相同，但方法体可能不同），用于提供父类已经声明的方法的特殊实现，是实现多态的基础条件。 因为构造器不能被继承，所以构造器不能被重写，只能被重载。 访问修饰符 public、private、protected、以及不写（默认）时的区别？ private : 在同一类内可见。可以修饰变量、方法。注意：不能修饰类（外部类） default （即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。 protected : 对同一包内的类和所有子类可见。可以修饰变量、方法。注意：不能修饰类（外部类）。 public : 对所有类可见。可以修饰类、接口、变量、方法 组要区别就是在，同一个类中、同一个包中、子类中以及全局范围的可见性 this 关键字有什么作用？和super 关键字有什么区别？可以作为引用变量，指向当前对象。这样可以是调用当前类的成员变量、方法、构造方，作为当前类的引用参数传递，甚至可以作为返回值等。但是super关键字，他是指向父类对象，我们主要用它来调用父类方法、构造方法。 抽象类和接口有什么区别？和普通类呢？ 特性 抽象类 接口 类 定义 不能实例化，只能被继承的类。 定义一组方法规范。 可以实例化的具体类。 关键字 abstract interface class 方法实现 可以包含抽象方法（没有方法体）和具体方法（有方法体）。 只能包含抽象方法（Java 8+ 可以有默认和静态方法）。 只能包含具体方法（有方法体）。 成员变量 可以有成员变量（实例变量）。 只能有静态常量（使用public static final修饰）。 可以有成员变量。 继承关系 一个类只能继承一个抽象类（单继承）。 一个类可以实现多个接口（多实现）。 可以继承一个类。 访问修饰符 可以有各种访问修饰符（public, protected, private）。 方法默认是public，不能有其他修饰符。 可以有各种访问修饰符。 用途 提供一个基础实现，子类可以选择性的重写。 定义一个类需要遵循的契约或标准。 实现具体功能或行为。 多重继承 不支持（只能单继承）。 支持（一个类可以实现多个接口）。 不支持（只能单继承）。 实例化 不能直接实例化。 不能直接实例化。 可以直接实例化。 构造器 可以有构造器。 不能有构造器。 可以有构造器。 首先在定义上，抽象类不能被实例化，只能被继承，而接口是一组方法规范，只能被实现。然后他们的修饰关键字不同，比如抽象类是abstract，接口是interface，类是class。具体内容不同，比如抽象类既可以有抽象方法，也可以有具体方法，但是接口只能有抽象方法，在Java8后可以用默认方法和静态方法，类就不能有抽象方法。其中接口最为特别，他是可以被多实现和多继承的，也就是一个类可以实现多个接口，一个接口可以继承多个接口。 其次在应用上，接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用。假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。 成员变量与局部变量的区别有哪些？ 成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数。 如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。 成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。 总得来说，如果成员遍历被static修饰，那么他是属于类的，如果没有则是属于对象的，而局部变量是在⽅法中定义的变量或是⽅法的参数。 静态变量和实例变量的区别？静态方法、实例方法呢？静态：方便在没有创建对象的情况下进行调用 静态变量: 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本。 实例变量: 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 静态方法：static 修饰的方法，也被称为类方法。在外部调⽤静态⽅法时，可以使⽤”类名.⽅法名“的⽅式，也可以使⽤”对象名.方法名“的⽅式。静态方法里不能访问类的非静态成员变量和方法。 实例⽅法：依存于类的实例，需要使用”对象名.方法名“的⽅式调用；可以访问类的所有成员变量和方法。 总得来说，被static修饰的变量和方法，都是方便在没有创建对象的时候进行调用，可以通过类名或者对象名直接调用静态方法，实例方法则是依存与某一实例，通过创建对象进行访问。 是否可以从一个static方法内部发出对非static方法的调用？不可以，因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。 ==和equals方法究竟有什么区别？对于==，如果比较的是基本数据类型，那就比较的是值，如果比较的是引用数据类型，那比较的是地址值。而对于equals 他只能比较引用数据类型，如果没有重写Object中的equals方法，比较的就是两个对象的地址，重写了就得看是怎么重写的，比如Integer里就是比较值，而String是先地址后值、地址不同值相同返回true。 为什么重写 equals 时必须重写 hashCode ⽅法？首先我们需要明确equals和hashcode的作用与关系，如果equals没有被重写，通过他比较的对象可以保证是相等的，但是这样比较效率并不高，在Java基于hash的集合类里面，比如HashSet、HashMap、Hashtable 等，他们都使用了hashcode方法，可以保证在最快的时间内判断两个对象是否相等，但是由于有hash冲突的存在，不能保证比较值是一定正确的，所以他们都是先计算hashcode，获取到桶的索引，在使用equals来找到正确的对象。 回到问题，我们以HashSet为例，如果我们只重写了equals方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。 但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。 总得来说，hashCode 和 equals 两个方法是用来协同判断两个对象是否相等的，采用这种方式的原因是可以提高程序插入和查询的速度，如果在重写 equals 时，不重写 hashCode，就会导致在某些场景下，例如将两个相等的自定义对象存储在 Set 集合时，就会出现程序执行的异常，为了保证程序的正常执行，所以我们就需要在重写 equals 时，也一并重写 hashCode 方法才行。 final 关键字有什么作用？ 当 final 修饰一个类时，表明这个类不能被继承。比如，String 类、Integer 类和其他包装类都是用 final 修饰的。 当 final 修饰一个方法时，表明这个方法不能被重写（Override）。也就是说，如果一个类继承了某个类，并且想要改变父类中被 final 修饰的方法的行为，是不被允许的。 当 final 修饰一个变量时，表明这个变量的值一旦被初始化就不能被修改。 如果是基本数据类型的变量，其数值一旦在初始化之后就不能更改；如果是引用类型的变量，在对其初始化之后就不能再让其指向另一个对象。 final、finally、finalize 的区别？ final 是一个修饰符，可以修饰类、方法和变量。当 final 修饰一个类时，表明这个类不能被继承；当 final 修饰一个方法时，表明这个方法不能被重写；当 final 修饰一个变量时，表明这个变量是个常量，一旦赋值后，就不能再被修改了。 finally 是 Java 中异常处理的一部分，用来创建 try 块后面的 finally 块。无论 try 块中的代码是否抛出异常，finally 块中的代码总是会被执行。通常，finally 块被用来释放资源，如关闭文件、数据库连接等。 finalize 是Object 类的一个方法，用于在垃圾回收器将对象从内存中清除出去之前做一些必要的清理工作。 Java 是值传递，还是引用传递？值传递，首先值传递是在传参的过程中原参数不变，引用传递是传递的参数本身，所以原参数会变。在Java中当一个对象被作为参数传递到方法中时，该参数的值就是该对象的引用，但是这个引用并不会影响原参数，他只是原参数的一个副本，Java只有值传递。"},{"title":"(一). 夯实基础 - Java基础语法","path":"/JavaSE-Java基础.html","content":"前言 作为学习笔记，可能存在一些错误，若发现望指正，万分感激 本文主要记录了一些Java基础内容，如单例设计模式 类什么是类与对象 类：描述相同事物的共同特征的抽象。人类 对象：具体存在的实例，是真实的。实例&#x3D;&#x3D;对象 在代码层面：必须先有类，才能创建出对象。 如何定义类类的定义格式如下: 12345678修饰符 class 类名&#123; // 类中有且仅有的五大成分。 // 1.成员变量 （描述类和对象的属性信息） // 2.成员方法 （行为信息） // 3.构造器 （初始化类对象并且返回引用） // 4.代码块 // 5.内部类&#125; 如何通过类创建对象类名 对象名称 = new 类名(); 注意 类名的首字母应该大写，满足“驼峰写法”。 一个Java代码文件中可以定义多个类。但是只能有一个类是用public修饰的，而且.public修饰的类名必须成为代码的文件名称。 构造器构造器的作用通过调用构造器可以返回一个类的对象，构造器同时负责帮我们把对象的数据（属性和行为等信息）初始化好。 构造器的格式修饰符 类名(形参列表) &#123; // 构造体代码，执行代码&#125; 构造器初始化对象类名 对象名称 = new 构造器; 注意 一个类默认会自带一个 无参数构造器，即使不写它也存在， 但是如果一个类它写了一个构造器，那么默认的无参数构造器就被覆盖了! 封装什么是封装是Java语言的风格。是我们在开发中必须遵循的，即使毫无意义，代码还是要按照这个风格写! ! 封装的作用 1.可以提高安全性。 2.可以实现代码的组件化。 封装的步骤 使用 private 关键字来修饰成员变量。 使用public修饰getter和setter方法。 this关键字this关键字的作用 this代表所在类的当前对象的引用（地址值），即代表当前对象。 this关键字可以用在实例方法和构造器中。 this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。 this用在构造器，代表了构造器正在初始化的那个对象的引用 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ThisDemo02 &#123; public static void main(String[] args) &#123; Animal animal = new Animal(); animal.setName(&quot;小明&quot;); Animal animal1 = new Animal(&quot;哈哈&quot;,&#x27;男&#x27;); &#125;&#125;class Animal&#123; private String name; private char sex; /** * @return this.name * this有时候可以省略 * this-&gt;animal */ public String getName() &#123; return name; &#125; /** * @param name * 谁调用这个方法，this就指向谁 * this-&gt;animal animal.name = 小明 */ public void setName(String name) &#123; this.name = name; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125; /** * @param name * @param age * @param sex * * this-&gt;animal1 * animal1.name = 哈哈 * animal1.sex = 男 */ public Animal(String name, char sex) &#123; this.name = name; this.sex = sex; &#125; public Animal() &#123;&#125;&#125; static关键字引入我们之前定义了很多成员变量(name ,age，sex)，其实我们只写了一份，但是发现每个对象都可以用，就说明Java中这些成员变量或者方法是存在所属性的。有些是属于对象的，有些是属于类本身的。 如何理解 被static修饰的成员是属于类的是放在静态区中 没有static修饰的成员变量和方法则是属于对象的 成员变量有无static区分 有static修饰：属于类叫静态成员变量，与类一起加载一次， 直接用类名调用即可。 无static修饰：属于类的每个对象的叫实例成员变量，与类的对象一起加载，对象有多少个，实例成员变量就加载多少份。必须用类的对象调用 成员方法有无static区分 有static修饰：属于类叫静态方法，直接用类名调用即可 无static修饰：属于类的每个对象的叫实例方法，必须用类的对象调用。 成员变量的访问语法123456// 静态成员变量访问:// 类名.静态成员变量。// 对象.静态成员变量。(不推荐 )// 同一个类中访问可省略类名// 实例成员变量的访问:// 对象.实例成员变量 成员方法的访问语法123456// 静态成员方法访问：// 类名.静态方法// 对象.静态方法。(不推荐 )// 同一个类中访问可省略类名// 实例成员变量访问：// 对象.实例方法 面试常问 实例方法是否可以直接访问实例成员变量?可以的，因为它们都属于对象。 实例方法是否可以直接访问静态成员变量?可以的，静态成员变量可以被共享访问。 实例方法是否可以直接访问实例方法?可以的，实例方法和实例方法都属于对象。 实例方法是否可以直接访问静态方法?可以的，静态方法可以被共享访问! 静态方法是否可以直接访问实例变量?不可以的，实例变量必须用对象访调 静态方法是否可以直接访问静态变量?可以的， 静态成员变量可以被共享访问。 静态方法是否可以直接访问实例方法?不可以的，实例方法必须用对象访问! ! 静态方法是否可以直接访问静态方法?可以的，静态方法可以被共享访问! ! 继承继承的含义 一般到特殊 是is a的关系 子类继承父类的属性和行为，使得子类对象可以直接具有与父类相同的属性、相同的行为。 子类可以直接访问父类中的非私有的属性和行为。 继承的格式通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下： 1234567class 父类 &#123;\t...&#125;class 子类 extends 父类 &#123;\t...&#125; 需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的 子类不能继承的内容 子类不能继承父类的构造器，因为子类有自己的构造器 (争议)子类是可以继承父类的私有成员的，只是不能直接访问而已。以后可以暴力去访问继承自父类的私有成员 (争议)子类是不能继承父类的静态成员的子类只是可以访问父类的静态成员，父类的静态成员只有一份可以被子类共享访问。共享并非继承。 继承后子类成员变量访问特点就近原则: 子类有找子类，子类没有找父类，父类没有就报错。 this代表了当前对象的引用，可以用于访问当前子类对象的成员变量。 super代表了父类对象的引用，可以用于访问父类中的成员变量。 方法重写的概念 发生在子父类之间的关系 子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 子类返回值类型范围相同或者更小 子类修饰符权限相同或者更大 子类异常抛出范围一样或更小 @Override重写注解 这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。 建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！ 注意 父类被重写后只能通过子类中转调用或者实例化父类调用 私有方法和静态方法都不能被重写 继承后构造器特点子类所有构造器的第一行都会先调用父类的无参构造器，再执行自己（先有爸爸，才能有儿子） 可以在子类构造器中使用super(…)调用指定构造器，以便初始化继承自父类的数据 this关键字拓展可以使用this关键字实现构造器默认值：this(…)可以根据参数类型访问本类其他构造器。此时！由对应被调用的构造器去调用父类构造器 注意：this(…)和super(…)必须放在构造器的第一行， 否则报错!所以this(…)和super(…)不能同时出现在构造器中!! 继承的特点 Java只支持单继承，不支持多继承。 假如可以多继承，若两个父类都有某一方法，且子类多继承这两个父类，在实例化子类时调用这个相同的方法，则会程序出现不知道调用谁而出现类的二义性！ 一个类可以有多个子类。 可以多层继承。 顶层父类是Object类。所有的类默认继承Object，作为父类。 抽象类概念 抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。 public abstract void run()； 特征与注意事项 继承抽象类的子类必须重写父类所有的抽象方法 无法创建对象(其他的都有) 假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义 有构造器 供子类创建对象时，初始化父类成员使用的。 意义 为了派生子类 体现模板思想，部分实现、部分抽象，可以设计模板设计模式 设计模式——优秀软件设计架构和思想 模板设计模式作用：优化代码架构，提高代码复用型，实现部分实现，部分抽象，抽象部分交给使用模板的人重复实现 接口概述 体现的是规范的思想（公开） 接口是更加彻底的抽象 在JDK8之前，接口中的成分包含：抽象方法和常量 public static final（抽象类里可省略） 常量：变量值只有一个，而且在程序运行的过程中不可更改!变量名全大写 12345678//接口的定义格式：修饰符 interface 接口名称&#123; // 抽象方法&#125;// 修饰符：public|缺省// 接口的声明：interface// 接口名称：首字母大写，满足“驼峰模式” 使用 一个类实现接口，这个称为实现类。 接口是用来被类实现的，实现的关键字是implements,按口可以多实现。 一个类实现接口必须重写完接口中全部的抽象方法，否则这个类要定义成抽象类 类与接口之间的关系是多实现的，一个类可以同时实现多个接口 意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。 123456/**接口的实现： 在Java中接口是被实现的，实现接口的类称为实现类。 实现类的格式:*/[修饰符] class 类名 implements 接口1,接口2,接口3...&#123;&#125; 接口与接口之间是可以多继承的 12345678910111213141516171819public interface Abc &#123; void go(); void test();&#125;/** 法律规范：接口*/public interface Law &#123; void rule(); void test();&#125; * * 总结： * 接口与类之间是多实现的。 * 接口与接口之间是多继承的。 * */public interface SportMan extends Law , Abc &#123; void run();&#125; JDK 8之后的接口新增方法接口不再纯洁了，接口中不再只是抽象方法，接口还可以有默认方法（也就是实例方法），和静态方法了，还包含了私有实例方法和私有静态方法 默认方法：默认加入public修饰，可省略；使用 default 修饰，不可省略，供子类调用或者子类重写。 静态方法：默认加入public修饰，可省略；使用 static 修饰，供接口直接调用。 私有方法：1.9开始新增，使用 private 修饰，供接口中的默认方法或者静态方法调用。 1234567891011public interface InterFaceName &#123; public default void method() &#123; // 执行语句 &#125; public static void method2() &#123; // 执行语句 &#125; private void method() &#123; // 执行语句 &#125;&#125; 接口小结 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。 接口中的方法全是抽象方法，默认会自动加上public abstract修饰 JDK 8开始，接口不再纯洁，支持静态方法，默认方法，私有方法。 接口中，没有构造器，不能创建对象。 类与接口是多实现的 接口与接口是多继承的 接口体现的规范。 代码块静态代码块 每次执行类，加载类的时候都会先执行静态代码块一次。 静态代码块是自动触发执行的，只要程序启动静态代码块就会先执行一次。 作用：在启动程序之前可以做资源的初始化，一般用于初始化静态资源。 static&#123; // 执行代码&#125; 实例代码块 无static修饰。属于对象，与对象的创建一起执行的。 每次调用构造器初始化对象，实例代码块都要自动触发执行一次。 实例代码块实际上是提取到每一个构造器中去执行的。 作用：实例代码块用于初始化对象的资源。 &#123; // 执行代码&#125; final关键字基本知识 final： 不可改变，最终的含义。可以用于修饰类、方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，有且仅能被赋值一次。 修饰局部变量时，防止在执行过程中被修改 修饰成员变量 时可以在被定义的 时候赋值一次，或者在静态代码块里赋值一次 abstract和final是互斥关系，不能同时修饰成员 单例设计模式什么是单例？ 一个类只有一个对象实例，可以节约内存提高性能，有8种 有哪些？ 饿汉单例设计模式使用类的时候已经将对象创建完毕，不管以后会不会使用到该实例化对象，先创建了再说 123456789101112public class Singleton &#123; // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 private Singleton() &#123;&#125; // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。 private static final Singleton instance = new Singleton(); // 3.定义一个静态方法返回这个唯一对象。 public static Singleton getInstance() &#123; return instance; &#125;&#125; 懒汉单例设计模式调用getInstance()方法时实例才被创建，先不急着实例化出对象，等要用的时候才例化出对象 12345678910111213141516public class Singleton &#123; // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。 private static Singleton instance; // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 private Singleton() &#123;&#125; // 3.定义一个静态方法返回这个唯一对象。要用的时候才例化出对象 public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 枚举类定义枚举的格式enum 枚举名 &#123; //第一行都是罗列枚举实例,这些枚举实例直接写大写名字即可。 BOY, GIRL; // 男，女&#125; 特点 final修饰的，不能被继承 枚举是不能在外部创建对象的，枚举的构造器默认是私有的。 枚举类在第一行罗列若干个枚举对象。（多例） 第一行都是常量，存储的是枚举类的对象。 枚举通常用于做信息的标志和分类。 使用Sex s ＝ Sex.BOY // BOYs.ordinal() // 枚举对象索引位置 多态概念同一个类型对象，执同一个行为，在不同状态下表现出不同的行为特征，多态是出现在继承或者实现关系中的。 格式：// 方法调用（行为）：编译看左边，运行看右边// 变量调用：编译运行都看左边父类类型 变量名 = new 子类/实现类构造器;变量名.方法名(); 存在条件 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 多态优势 组件化切换，可以实现类于类的解耦 拓展性，便利 不能调用子类独有的功能，小范围自动转换为大范围 内部类提供更好的封装性，内部类也更多权限修饰符，封装性也更多控制，体现出组件的思想，寄身 静态内部类 属于外部类本身，只会加载一次，可以通过外部类名称.内部类名称实例化。内部类中可以直接访问外部类静态成员，但是不能访问实例成员 实例内部类 属于外部类对象，不能定义静态成员，但可以定义常量，可以通过外部类名称.内部类 name ＝ new 外部类().new 内部类()来实例化，可以访问外部的静态和实例成员 局部内部类 和实例内部类很像 匿名内部类 没有名字的局部内部类，也是一个匿名内部类的对象，是子类类型 权限修饰符 public protected 缺省（空的） private 本类中 √ √ √ √ 本包下的其他类类 √ √ √ 其他包下的子类 √ √ 其他包中的无关类 √","tags":["笔记","Java"],"categories":["JavaSE"]},{"title":"(二). 夯实基础 - Java面向对象","path":"/JavaSE-面向对象.html","content":"面向对象编程顾名思义，面向对象，你得首先有个对象，有了对象后，就可以和对象进行互动，所以面向对象编程是通过对象的方式，把现实世界映射到计算机模型的一种编程方法；与面向对象编程相反的是面向过程编程，是把模型分解成一步一步的过程 面向对象基础现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance） 先仔细看看这简单的段代码吧~ 相信在此框架下，后面学起来更轻松~ 123456789101112131415161718192021222324252627282930313233// 定义了一个人类public class person&#123; //成员变量 String name; //名字 int age; // 年龄 //无参构造方法 public person()&#123;&#125; //含参数构造方法 public person(String name,int age)&#123; this.name = name; this.age = age; &#125; //成员方法 public void eat()&#123; System.out.println(this.name+&quot;在&quot;+this.age+&quot;岁就已经学会干饭了&quot;); &#125; public static void main(String[] args)&#123; //无参实例化 person p1 = new person(); p1.name = &quot;小红&quot;; p1.age = 18; //调用eat方法 p1.eat(); // 含参实例化 person p2 = new person(&quot;小明&quot;,80); //调用eat方法 p2.eat(); &#125; &#125; 1、 类class 是一种对象模版，它定义了如何创建实例，因此，class 本身就是一种数据类型 定义 class在 Java 中，创建一个类，例如，给这个类命名为Person，就是定义一个class： class Person &#123; public String name; public int age;&#125; 一个class可以包含多个字段（field），字段用来描述一个类的特征，通过 class 把一组数据汇集到一个对象上，实现了数据封装 2、 实例instance 是根据 class 创建的实例，可以创建多个 instance，每个 instance 类型相同，但各自属性可能不相同 创建实例new 操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例，所以是引用变量ming指向实例new Person(),可以通过这个变量来操作实例 Person ming = new Person(); 不同的实例在内存中对应位置不一样哦~ 3、this 关键字在调用方法的时候，java 会自动的把对象传递给方法， 在方法中由this来接收对象，就和开始所示代码一样；变量的查找顺序: 先找自己方法内。如果自己没有，就去this里面找 this:当前类的对象 this 可以在方法内部获取到对象中的属性信息 this 还可以区分局部变量和成员变量 4、方法访问权限 public 公共的.所有人都可访问 default 包访问权限.在自己包内可以随意访问. private 私有的. get set方法引入开始已经说了字段field可以用来用来描述一个类的特征，但是直接把field用public暴露给外部可能会破坏封装性。比如： 12345678910//定义person类class Person &#123; public String name; public int age;&#125;//实例化Person ming = new Person();ming.name = &quot;Xiao Ming&quot;;ming.age = -99; // age可以设置为负数 怎么办？使用private（私有） 字段 class Person &#123; private String name; private int age;&#125; private修饰field，就避免外部代码直接去访问field，那我们要怎么使用这些dield呢？ 我们需要方法（method） 来从外部代码间接修改field的值，比如我们使用使用外部方法getName来间接获取private字段的值，再使用setName来检查传入的参数对不对，从而达到筛选的效果 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; //实例化调用 Person ming = new Person(); ming.setName(&quot;Xiao Ming&quot;); // 设置name ming.setAge(12); // 设置age System.out.println(ming.getName() + &quot;, &quot; + ming.getAge()); &#125;&#125;//定义类class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125;// 在这里我们就筛选出了不能传入name为空的字符串， public void setName(String name) &#123; if (name==null) &#123; //抛出非法或者不合适的这个异常 throw new IllegalArgumentException(&quot;invalid name&quot;); &#125; //返回方法值 this.name = name; &#125; 同理 age 也可以如此操作，需要注意的是，这个方法相当于被封装在 person 类里，通过一个类定义方法，就可以给外部暴露一些操作的接口的同时保证自己内部类的统一，我们可以在外部使用实例变量.方法名(参数); 来进行调用 看起来可能会有点麻烦，因为一个成员变量就要两个方法，所以在我们的 idea 中可以快捷生成get set 方法 : 空白位置-&gt;右键-&gt; generate -&gt; getter and setter-&gt;全选-&gt; Ok. 构造方法指的是在创建对象的时候，类自动调用的方法.语法:public 类名(传参){}注意: 没有返回值这一项 在我们 new 的时候.自动调用构造方法作用: 在创建对象的时候.给对象设置属性信息. java 会默认自动的送给每一个类一个无参构造方法 构造方法的重载构造方法也是方法，也可以进行重载。 作用: 可以又更多的方式去创建对象；可以使用 this 可以访问其他的构造方法 this() 成员方法定义方法的语法是： 修饰符 方法返回类型 方法名(方法参数列表) &#123; 若干方法语句; return 方法返回值;&#125; 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return 同样的我们既然有private字段那么也就有private方法，并且private方法不允许外部调用，但是我们可以在 privet 内部调用private方法 1234567891011121314151617class Person &#123; private String name; private int birth; public void setBirth(int birth) &#123; this.birth = birth; &#125; public int getAge() &#123; return calcAge(2019); // 调用private方法 &#125; // private方法: private int calcAge(int currentYear) &#123; return currentYear - this.birth; &#125;&#125; 5、静态在一个class中定义的字段，我们称之为实例字段，用static修饰的字段，称为静态字段：static field，实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间” 123456class Person &#123; public String name; public int age; // 定义静态字段number: public static int number;&#125; 可以有两者办法使用静态 12345678//直接通过实例变量访问静态对象//所有实例的静态字段都被修改了，原因是静态字段并不属于实例 hong.number = 99; System.out.println(ming.number); //通过类名访问静态变量Person.number = 99;System.out.println(Person.number); 但是不推荐用 实例变量.静态字段 去访问静态字段， 因为在 Java 程序中，实例对象并没有静态字段 ；实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为 类名.静态字段 来访问静态对象。所以推荐用类名来访问静态字段。 因为静态对象会比实例对象更先加载，就和司马迁不能给你编写历史，但是你可以给司马迁编写历史一样：不能够用 this 去访问实例对象，不能在静态方法里调用非静态方法，可以在静态方法里调用静态方法，也可以用类名来调用静态方法 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Person.setNumber(99); System.out.println(Person.number); &#125;&#125;class Person &#123; public static int number; public static void setNumber(int value) &#123; number = value; &#125;&#125; 特点: . 数据共享 (要变一起变) 属于类的，并不属于对象 优先于对象产生的 6、包和导包包:其实本质上就是文件夹，在代码中需要写 package+包名; 例如： 导包:import 包+类; 不同包之间需要进行导包才能互相访问 不需要导包: 在自己包里 java.lang 包 下的所有内容都不需要导包 比如： StringSystem.out.println0 7、继承继承:子类可以自动拥有父类中除了私有内容外的其他所有内容. 当出现 x 是一种 y 的时候. x 就可以继承 y，换句话说就是动物都会叫，猴子是动物，猴子继承了动物会叫的功能，所以猴子会叫 public class类extends父类&#123;&#125; 作用: 简化代码的开发. 子类对父类进行了扩展. 如果父类和子类存在相同属性，子类是如何继承的呢？ 使用super关键字调用父类，使用this关键字调用自己类，在调用变量时this关键字是先找自己类，再找父类； 父类： 123456public class Hero &#123; String name = &quot;英雄&quot; public fulei()&#123; System. out. print ln(&quot;我是父类的构造方法&quot;); &#125;&#125; 子类： 1234567891011121314151617public class SunWuKong extends Hero &#123; String name = &quot;孙大圣&quot;; public SunWuKong( ) &#123; super(); // 还原程序，在子 类构造方法的第一行，默认调用父类的构造方法 System. out. print ln(&quot;我是子类的构造方法&quot; );&#125; public void chi( )&#123; //想看到父类中的name System.out. print Ln(super.name) ; //先找自己类，然后找父类 System. out. println( this.name+&quot;在吃桃子&quot;) ;&#125; public static void main(String[] args) &#123; SunWuKong S = new SunWuKong( ) ; S.chi() ; &#125;&#125; 调用方法时一般默认在子类的第一个构造方法里最先使用super()调用父类的**无参构造方法，所以可以不写super()调用父类的无参构造方法，但是对于含参构造方**法，就需要在子类中使用super(参数)调用父类的含参构造方法，不然就会报错 那如果子类不满意继承来的方法怎么办呢？ 8、重写方法的重写，也即是子类对父类中提供的方法进行重新定义 语法: 子类和父类中的方法的声明完全一致，重写又被称为方法的覆盖； 如果子类想在重写的方法中使用父类原本的方法仍然可以使用super.方法名()的形式去调用，这种既重写了方法又调用了原方法叫做半盖 上面就是 toString 方法的重写 9、多态多态:同一个对象拥有多种形态 举个例子： 假如有三个动物，猫、狗、鸡，猫吃鱼、狗啃骨头、鸡啄米，现在有一个人，这个人要在早晨去喂这三个动物，应该怎么写呢？ 因为多态比较难一点所以就写详细一点 动物： public class Animal &#123; public void eat()&#123; System.out.println(&quot;动物会进食&quot;); &#125;&#125; 猫： public class Cat extends Animal &#123; public void eat()&#123; System.out.println(&quot;猫吃鱼&quot;); &#125;&#125; 狗： 123456public class Dog extends Animal &#123; public void eat()&#123; System.out.println(&quot;狗啃骨头&quot;); &#125;&#125; 鸡： 123456789public class Chicken extends Animal &#123; public void eat()&#123; System.out.println(&quot;鸡啄米&quot;); &#125; public void dance()&#123; System.out.println(&quot;练习时常两年半的舞蹈鸡&quot;);&#125;&#125; 人： 123456public class Person &#123; public void feedanimal(Animal ain)&#123; System.out.print(&quot;人在喂&quot;); ain.eat(); &#125;&#125; 场景： 123456789101112131415161718192021public class Scenario &#123; public static void main(String[] args) &#123; // 实例化 向上转型 Animal ain1 = new Cat(); Animal ain2 = new Chicken(); Animal ain3 = new Dog(); Person p = new Person(); System.out.println(&quot;在一个早晨&quot;); p.feedanimal(ain1); p.feedanimal(ain2); p.feedanimal(ain3); /* 在早晨 人在喂猫吃鱼 人在喂鸡啄米 人在喂狗啃骨头 */ &#125;&#125; 可以看出人在喂的时候只喂了动物，而不是把猫狗鸡都一个一个挨着喂，是因为猫狗鸡和动物有一个继承关系，并且我们在实例化的时候把子类对象赋值给了父类变量，相对于把子类们都统一到了父类里，其实这就是多态的体现，我们把这叫做向上转型 ，但是不难看出，鸡还有跳舞的功能被屏蔽了， 因为向上转型会屏蔽掉子类不同于父类的方法 有向上转型就有向下转型，我们把父类的变量转化回子类的变量就叫做向下转型，向下转型有可能有风险. java 要求必须要写强制类型转换(转换之后的数据类型)变量 12345678910111213public class Scenario &#123; public static void main(String[] args) &#123; Animal ain2 = new Chicken(); Chicken c = (Chicken) ain2; c.dance(); c.eat(); /* 练习时常两年半的舞蹈鸡 鸡啄米 */ &#125;&#125; 10、final 被final 修饰的变量不可以被改变，又被称为常量 被final修饰的方法不可以被重写. 被final修饰的类不可以被继承. 11、抽象只声明，不实现，可以有正常的方法 抽象方法:使用 abstract 来修饰，不可以有方法体，直接用分号结束即可； 抽象类:如果一个类中有抽象方法，这个类必须是一一个抽象类； 特点: 抽象类不可以创建对象； 抽象类的子类，必须重写父类中的抽象方法.否则,子类必须也是抽象类； 通过抽象类可以强制的要求子类中必须有哪些方法.； 12、接口特殊的抽象类：所有的方法都是抽象方法,用 interface 来声明 接口中所有的方法都是抽象方法。可以省略掉abstract； 接口中所有的内容都是公开的。公共的； 接口中所有的变量都是全局静态常量 public static final ； 能继承接口的只能是接口； 接口和类只能是实现关系implepents； 接口也具有多态性，也就是 接口可以把很多不相关的内容进行整合； 类只能单继承，接口支持多实现，也就是类可以继承一个类，实现多个接口； 13、成员变量初始值 java 中所有的变量必须先声明，后赋值才能使用 I java 中的成员变量，在创建对象的时候，都会执行一次初始化操作.都会给一个默认值. 基本数据类型默认值都是 0 包括 boolean -&gt; false 引用数据类型: null，null 表示空,什么都没有.占位. 14、toString默认的 toString() -&gt;包+ 类@内存地址 1234567891011121314151617package com.xyq.entity;public class Cat &#123;\t//类默认继承Object\tString name;\tString color ;\tpublic Cat(String name, String color)&#123; this.name = name; this.color = color;\t&#125;\tpublic static void main(String[] args) &#123; Cat C = new Cat( name:&quot;小花&quot;， color: &quot;绿色&quot;); //直接打印这个 System.out.println(c) ; //输出 com.xyq.entity.Cat@47d384ee //默认打印对象，自动的执行这个对象中的toString( )方法 System.out.println(c.toString()) ; //也输出 com.xyq.entity.Cat@47d384ee &#125;&#125; 很明显我们对父类 Stirng 里的 toString 方法并不满意，那么我们可以重写这个方法(上面有) 15、instanceof判断 xxx 对象是否是 xxx 类型的 1234567891011public class Cat extends Anima 1 &#123;\tpublic static void main(String[] args) &#123; Animal ani = new Animal( ) ; if(ani instanceof Cat)&#123; System. ou.println(&quot;是一只猫。撸一撸&quot;); &#125; else &#123; System. out.pr intln(&quot;不是一只猫&quot;); &#125;\t&#125;&#125; 16、内存分析 堆：主要存放对象. 栈：局部变量，以及基本数据类型的变量. 代码区：类和方法 数据区：常量池和静态变量","tags":["笔记","Java","OOP"],"categories":["JavaSE"]},{"title":"3xui面版搭建Reality协议，使用链式代理，最简单的魔法","path":"/workflow/3xui.html","content":"摘要通过3xui实现链式代理，自建节点，高速低延迟 搭建dokcer-compose搭建123456789101112131415161718services: 3x-ui: image: ghcr.io/mhsanaei/3x-ui:latest container_name: 3xui restart: always mem_limit: 85m ports: - 20000-20005:20000-20005/tcp - 20000-20005:20000-20005/udp - 2053:2053/tcp volumes: - ./cert:/root/cert - ./db:/etc/x-ui logging: driver: json-file options: max-size: &quot;1m&quot; max-file: &quot;3&quot; 这边建议您通过docker compose up -d 运行后配置反向代理！但是需要开放20000-20005的端口（也可以自己选自己喜欢的端口），用于节点。 脚本搭建bash &lt;(curl -Ls https://raw.githubusercontent.com/mhsanaei/3x-ui/master/install.sh) 搭建节点基本配置证书申请见：泛域名证书申请 反向代理配置如下： 123456789101112#3xuiserver &#123; listen 443 ssl; server_name xui.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:2053/; &#125;&#125; 参考配置 vmess+ws类型：协议：vmess、端口：20001、传输：WebSocket reality类型节点：协议：vless、端口：20000、安全：REALITY、用户Flow：xtls-rprx-vision，Dest：目标网站:端口，SNI：目标网站 目标网站查询指南： 选择带有域名的 不要选证书为黄色的，比如 端口和自己的节点的端口一致，比如你的端口是443，那就是整个域名，比如你的端口是8080，那就是域名后面带有端口 8080 ，比如 exp.com:8080，当然对应的Dest：exp.com:8080，SNI：exp.com:8080 ASN查询：https://tools.ipip.net/as.php目标网站：https://fofa.info 下面查询可以修改自己的country和自己服务器的相同，以及端口等 asn==&quot;25820&quot; &amp;&amp; country==&quot;US&quot; &amp;&amp; port==&quot;443&quot; &amp;&amp; cert!=&quot;Let&#x27;s Encrypt&quot; &amp;&amp; cert.issuer!=&quot;ZeroSSL&quot; &amp;&amp; status_code=&quot;200&quot; 链式代理请求-&gt;服务器A-&gt;服务器B-&gt;目的 因为阿里云服务器（服务器A）很多流媒体无法访问，如果有其他vps或者ip等等（服务器B），可以在（服务器A）设置里面配置出站规则：你的vps的节点也好、socks也好，只要可以访问到你其他vps（服务器B）,让B帮你发请求。然后在路由规则里添加Domain比如：geosite:netflix,geosite:spotify,geosite:tiktok,geosite:meta,geosite:apple,geosite:reddit,geosite:openai然后配置Outbound Tag为你出站规则里访问服务器B的标签，就实现了请求分流。","tags":[null,null,null,null],"categories":[null]},{"title":"alist的多种搭建方式，优化分享链接，实现浏览器直接预览","path":"/workflow/alist.html","content":"摘要展示alist的docker搭建方式，以及直接搭建。实现挂载服务器指定目录文件，并且可以对其进行预览、而不是触发下载 搭建docker搭建# 目录：/home/docker/alistmkdir /home/docker/alistcd /home/docker/alistvi docker-compose.yml 123456789101112131415161718services: alist: image: xhofe/alist:main container_name: alist restart: always mem_limit: 100m user: root ports: - &quot;5244:5244&quot; volumes: - /home/docker/nginx/certs:/opt/alist/data/cert - /home/data:/home/data - ./data:/opt/alist/data logging: driver: json-file options: max-size: &quot;1M&quot; max-file: &quot;3&quot; 这边建议您通过docker compose up -d 运行后，配置反向代理 直接搭建123456789# 默认安装在 `/opt/alist` 中。 # 自定义安装路径，将安装路径作为第二个参数添加，必须是绝对路径（如果路径以 alist 结尾，则直接安装到给定路径，否则会安装在给定路径 alist 目录下）# 如 安装到 `/home`# Installcurl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s install /home# updatecurl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s update /home# Uninstallcurl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s uninstall /home 配置注意记得去config.json里把user 值设置为root 基础设置1234567891011121314151617访问地址：http://YOUR_IP:5244/配置文件路径：/home/alist/data/config.json---------如何获取密码？--------先cd到alist所在目录:cd /home/alist随机设置新密码:./alist admin random或者手动设置新密码:./alist admin set NEW_PASSWORD----------------------------启动服务中查看状态：systemctl status alist启动服务：systemctl start alist重启服务：systemctl restart alist停止服务：systemctl stop alist 反向代理123456789101112# alistserver &#123; listen 443 ssl; server_name alist.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:5244/; &#125;&#125; 挂载目录 预览处理 把&#x2F;d的请求重定向到nginx服务，然后监听本地的80请求，再设置跟路径即可 需要注意的是：比如请求 https://alist.exp.top/d/oss/Blog/source/imgs/github.svg 他重定向后的路径在服务器中就为 http://127.0.0.1:80/oss/Blog/source/imgs/github.svg 确保root目录对应的路径下有这些文件 12345678910111213141516171819202122232425262728# alistserver &#123; listen 443 ssl; server_name alist.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:5244/; &#125; # 处理 /d/ 请求，重写路径并代理到 80 端口 location /d/ &#123; rewrite ^/p/(.*)$ /$1 break; proxy_pass http://127.0.0.1:80/; &#125;&#125;server &#123; listen 80; server_name 127.0.0.1; root /home/data; location / &#123; try_files $uri $uri/ =404; &#125;&#125; rclone挂载alist到电脑（可选）下载：rclone和winfsp 配置： 把含有exe文件的目录添加到系统环境变量 打开cmd运行窗口使用指令rclone config修改配置 填写alist登录账号 选择webdav 选择其他 输入挂载到本地的名称 用户名称就输alist账号 输入y填写并确认alist密码 按3下enter并输入q退出 开机自动挂载： 新建bat，输入以下内容，再双击查看是否成功运行 # 第一个alist是之前设置的挂载到本地的名称 # alist:/ 表示挂载根目录# D:/alist 本地的哪个路径@echo offrclone mount alist:/ D:/alist --vfs-cache-mode full --use-mmap --allow-other --no-check-certificate --no-gzip-encoding --copy-links 创建任务计划，通过在Windows搜索框中输入”任务计划程序”找到并打开，创建基本任务，触发器选 计算机启动时，选择 启动程序 后路径选择刚刚创建的bat文件，完成创建 右键点击该任务，选择“属性”，在“常规”选项卡中，勾选“使用最高权限运行”，在“操作”选项卡中，点击“编辑”（Edit）在“编辑操作”窗口中，在bat路径前添加cmd.exe /c，并在“添加参数”中输入/c start &quot;&quot; /b &quot;C:\\path\\to\\your\\mount_alist.bat&quot;。 这样就可以开机后，rclone在后台无感运行了","tags":[null,null,null],"categories":[null]},{"title":"多种方法搭建私有bitwardn服务器   bitwarden & Vaultwarden","path":"/workflow/bitwarden.html","content":"摘要开源的密码管理工具，我们搭建的是私有服务器，可以在手机下载对应应用以及在浏览器下载对应插件对私有服务器进行链接 搭建docker-compose 搭建注意看环境配置，一般DOMAIN、ADMIN_TOKEN和SIGNUPS_ALLOWED需要修改，建议在第一次部署的时候设置SIGNUPS_ALLOWED为true，创建账户后设置为false 1234567891011121314151617181920212223242526services: vaultwarden: container_name: vaultwarden image: vaultwarden/server:latest restart: always volumes: - ./data:/data ports: - &#x27;8385:80&#x27; environment: - DOMAIN=https://pwd.exp.com # 这是您希望与您的Vaultwarden实例关联的域名。 - LOGIN_RATELIMIT_MAX_BURST=10 # 允许在一阵登录/两步验证尝试中的最大请求次数。 - LOGIN_RATELIMIT_SECONDS=60 # 这是来自同一IP的登录请求之间的平均秒数，在Vaultwarden限制登录次数之前。 - ADMIN_RATELIMIT_MAX_BURST=10 # 这与LOGIN_RATELIMIT_MAX_BURST相同，只争对admin面板。 - ADMIN_RATELIMIT_SECONDS=60 # 这与LOGIN_RATELIMIT_SECONDS相同 - ADMIN_SESSION_LIFETIME=20 # 会话持续时间 - ADMIN_TOKEN=aaa # 此值是Vaultwarden管理员面板的令牌（一种密码）。为了安全起见，这应该是一个长的随机字符串。如果未设置此值，则管理员面板将被禁用。建议openssl rand -base64 48 生成ADMIN_TOKEN确保安全 - SENDS_ALLOWED=true # 此设置决定是否允许用户创建Bitwarden发送 - 一种凭证共享形式。 - EMERGENCY_ACCESS_ALLOWED=true # 此设置控制用户是否可以启用紧急访问其账户的权限。例如，这样做可以在用户去世后，配偶可以访问密码库以获取账户凭证。可能的值：true / false。 - WEB_VAULT_ENABLED=true # 此设置决定了网络保险库是否可访问。一旦您配置了您的账户和客户端，停止您的容器，然后将此值切换为false并重启Vaultwarden，可以用来防止未授权访问。可能的值：true/false。 - SIGNUPS_ALLOWED=false # 此设置控制新用户是否可以在没有邀请的情况下注册账户。可能的值：true / false。 logging: driver: json-file options: max-size: &quot;1m&quot; max-file: &quot;3&quot; 直接搭建12345678910111213141516171819# 创建文件夹mkdir /home/vw-imagecd /home/vw-image# 拉取可执行文件wget https://raw.githubusercontent.com/jjlin/docker-image-extract/main/docker-image-extract# 给运行权限chmod +x docker-image-extract# 提取docker中的可执行程序./docker-image-extract vaultwarden/server:alpine# 拷贝文件和目录mkdir -p /home/vaultwardencd output/# 将需要用到的 文件和目录拷贝到前面建好的目录cp -rf vaultwarden web-vault/ data/ /home/vaultwarden/# 下载环境配置文件wget https://raw.githubusercontent.com/dani-garcia/vaultwarden/main/.env.template -O vaultwarden.env 修改配置文件，直接复制在顶部就行，主要修改DOMAIN、ADMIN_TOKEN、SIGNUPS_ALLOWED 1234567891011121314151617181920212223242526272829# 这是您希望与您的Vaultwarden实例关联的域名。DOMAIN=https://bitwt.exp.top # 允许在一阵登录/两步验证尝试中的最大请求次数。LOGIN_RATELIMIT_MAX_BURST=10# 这是来自同一IP的登录请求之间的平均秒数，在Vaultwarden限制登录次数之前。LOGIN_RATELIMIT_SECONDS=60 # 这与LOGIN_RATELIMIT_MAX_BURST相同，只争对admin面板。ADMIN_RATELIMIT_MAX_BURST=10 # 这与LOGIN_RATELIMIT_SECONDS相同ADMIN_RATELIMIT_SECONDS=60 # 会话持续时间ADMIN_SESSION_LIFETIME=20 # 此值是Vaultwarden管理员面板的令牌（一种密码）。为了安全起见，这应该是一个长的随机字符串。如果未设置此值，则管理员面板将被禁用。## 建议openssl rand -base64 48 生成ADMIN_TOKEN确保安全ADMIN_TOKEN=# 此设置决定是否允许用户创建Bitwarden发送 - 一种凭证共享形式。SENDS_ALLOWED=true# 此设置控制用户是否可以启用紧急访问其账户的权限。例如，这样做可以在用户去世后，配偶可以访问密码库以获取账户凭证。可能的值：true / false。EMERGENCY_ACCESS_ALLOWED=true # 此设置决定了网络保险库是否可访问。一旦您配置了您的账户和客户端，停止您的容器，然后将此值切换为false并重启Vaultwarden，可以用来防止未授权访问。可能的值：true/false。WEB_VAULT_ENABLED=true # 此设置控制新用户是否可以在没有邀请的情况下注册账户。可能的值：true / false。SIGNUPS_ALLOWED=true# 给web端发送通知用的WEBSOCKET_ENABLED=true# IP地址WEBSOCKET_ADDRESS=0.0.0.0# 运行端口WEBSOCKET_PORT=8000 创建启动脚本 vim /etc/systemd/system/vaultwarden.service 12345678910111213141516171819202122232425262728293031323334[Unit]Description=vaultwarden Server (Rust Edition)Documentation=https://github.com/dani-garcia/vaultwarden# Only sqliteAfter=network.target network-online.targetRequires=network-online.target# MariaDB# After=network.target mariadb.service# Requires=mariadb.service# Mysql# After=network.target mysqld.service# Requires=mysqld.service# PostgreSQL# After=network.target postgresql.service# Requires=postgresql.service[Service]# The location of the .env file for configurationEnvironmentFile=/home/vaultwarden/vaultwarden.env# The location of the compiled binaryExecStart=/home/vaultwarden/vaultwarden# Set reasonable connection and process limitsLimitNOFILE=1048576LimitNPROC=64# Only allow writes to the following directory and set it to the working directory (user and password data are stored here)WorkingDirectory=/home/vaultwarden[Install]WantedBy=multi-user.target 启动 12345678# 重载配置文件systemctl daemon-reload# 启动sudo systemctl start vaultwarden.service# 删除/home/vw-imagerm -rf /home/vw-image 配置反向代理123456789101112#bitwortenserver &#123; listen 443 ssl; server_name bitwt.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8000/; &#125;&#125;","tags":[null,null,null],"categories":[null]},{"title":"Hexo搭建个人博客，Stellar主题美化教程，hexo结合obsidian实现一键发布","path":"/workflow/hexo.html","content":"需求分析内容展示需要写在简历里，所以当点进博客主目录需要快速概览的查看到总共做了什么内容。最好以图片的形式进行展现，这就需要排序功能，把高质量的，可以彰显技术力的文章放在前面，当点进去后会看到其同类型的笔记，浏览完后想返回时会注意到文档目录和个人简介按钮，到这里应该就知道整个博客的点击流程。其中点击个人简介会展示自己开源项目详细解释与地址，以及一些技术的描述，这些技术可以通过类似点击标签的形式访问到对应的文章（如果有） 编辑发布需要方便编写，在编写完后一键发布，并且不需要再设置博客的其他配置。已发布和未发布的文章不应有太大差距，编译前后使用同一套语法，附件方便管理，每个文章有对应的附件文件夹，文章链接不应很长，需要进行高效的SEO，当然需要有评论功能，其他人也可以通过邮箱和我进行交流 效果展示 初步化建议： 一个前端编译器如：vscode、webstorm 有node环境。建议版本在20.10.0以下，如18.20.0 安装hexo安装npm install hexo-cli -ghexo init blogcd blognpm install stellara安装npm i hexo-theme-stellar# 在 `blog/_config.yml` 文件中找到并修改theme: stellar # 也可以使用源码的方式进行安装git clone https://github.com/xaoxuu/hexo-theme-stellar.git# 把他放在themes目录下即可# 在 `blog/_config.yml` 文件中找到并修改theme: stellar 运行使用 hexo s 运行或者在编译器里找到package.json文件直接点击运行 软件笔记软件推荐obsidian，地址：https://obsidian.md/download，当然其他软件也可以，但是非本地存储的软件不太使用本教程 配置hexo 配置附件相对链接# 下载插件会转为 绝对路径npm install hexo-asset-image --save 我的配置 123456new_post_name: :hash.md # 新文章的文件名称post_asset_folder: truerelative_link: false # 把链接改为与根目录的相对位址 marked: prependRoot: true postAsset: true 站点图标12345678# 在在主站点的 _config.yml 里配置## 匹配到的文件将会被不做改动地复制到 public 目录中。 您可使用 glob 表达式来匹配路径。skip_render: images/**# 在source目录下新建imgs,访问路径为 images/xx.jpg# 在在主站点的 _config.yml 里配置avatar: &#x27;/images/avatar.png&#x27; # 站点头像 favicon: &#x27;/images/favicon-28-dog.svg&#x27; # 站点icon 推送Github或者OSS1234567891011121314151617181920212223# 安装插件npm install hexo-deployer-git --savenpm install hexo-deployer-ali-oss --save# 部署设置 # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: - type: git repo: git@github.com:Missiu/missiu.github.io.git # example, https://github.com/hexojs/hexojs.github.io branch: main - type: ali-oss region: &lt;您的oss 区域代码&gt; accessKeyId: &lt;您的oss accessKeyId&gt; accessKeySecret: &lt;您的oss accessKeySecret&gt; bucket: &lt;您的bucket name&gt;\tcacheControl: images: public, max-age=15552000 # 缓存时间6个月 css: public, max-age=1209600 # 缓存时间14天 js: public, max-age=259200 # 缓存时间3天 html: public, max-age=259200 # 缓存时间3天 other: no-cache # 缓存时间0 完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148# Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: Hzh subtitle: &quot;我亦无他，唯手熟尔 | Life-long learning&quot; # 网站副标题 description: &#x27;主要分享一些学习笔记和个人见解&#x27; # 网站描述 keywords: [ &#x27;计算机&#x27;,&#x27;开发&#x27;,&#x27;编程&#x27;,&#x27;网站&#x27;,&#x27;博客&#x27;,&#x27;技术&#x27;,&#x27;学习&#x27;,&#x27;教程&#x27;,&#x27;服务器&#x27;,&#x27;Java&#x27;,&#x27;后端&#x27; ] # 网站的关键词。 支持多个关键词。 author: Huzhihao language: - zh-CN - en - zh-TW timezone: &#x27;Asia/Shanghai&#x27; avatar: &#x27;/images/avatar.png&#x27; # 站点头像 favicon: &#x27;/images/favicon-28-dog.svg&#x27; # 站点icon # URL ## 网站地址，比如github地址： ## &#x27;https://username.github.io/project&#x27; url: http://localhost:4000/ permalink: :abbrlink.html # 文章的 永久链接 格式 permalink_defaults: # 永久链接中各部分的默认值 pretty_urls: # 美化永久链接 trailing_index: true # 设置 false 以删除「页面」永久链接结尾的&#x27;index.html&#x27;部分 trailing_html: true # 设置 false 以删除「文章」永久链接结尾的&#x27;.html&#x27;部分 # Directory source_dir: source # 源文件夹。您的内容的存储位置 public_dir: public # 公共文件夹。静态站点将在哪里生成 tag_dir: tags # 标签文件夹 archive_dir: archives # 归档文件夹 category_dir: categories # 分类文件夹 code_dir: downloads/code # Include code 文件夹，source_dir 下的子目录 i18n_dir: :lang # 国际化（i18n）文件夹 # https://github.com/micromatch/micromatch#extended-globbing skip_render: [images/**] # 匹配到的文件将会被不做改动地复制到 public 目录中。 您可使用 glob 表达式来匹配路径。 # Writing new_post_name: :title.md # 新文章的文件名称 default_layout: post # 预设布局 #titlecase: false # 把标题转换为 title caseexternal_link: # 在新标签中打开链接 # enable: true # 在新标签中打开链接 # field: site # 对整个网站（site）生效或仅对文章（post）生效 # exclude: &#x27;&#x27; # 需要排除的域名。 主域名和子域名如 www 需分别配置 filename_case: 0 # 修改文件名称大小写，1 小写; 2 大写 render_drafts: false # 显示草稿 # https://hexo.io/zh-cn/docs/asset-folders # 如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。 # 然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 post_asset_folder: true # 启用 资源文件夹 #资源图片将会被自动解析为其对应文章的路径。 ## 例如： image.jpg 位置为 /2020/01/02/foo/image.jpg,这表示它是 /2020/01/02/foo/ 文章的一张资源图片 ## ![](image.jpg) 将会被解析为 &lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt; 。 relative_link: false # 把链接改为与根目录的相对位址 marked: prependRoot: true postAsset: true future: true # 显示未来的文章 # https://hexo.io/zh-cn/docs/syntax-highlight syntax_highlighter: highlight.js # 代码块的设置, 请参考 代码高亮 进行设置 # 代码块的设置, 请参考 Highlight.js 进行设置 # https://hexo.io/zh-cn/docs/syntax-highlight#Highlight-js highlight: line_number: true # 行号显示。 auto_detect: false # 自动检测代码块的语言。十分耗费资源! tab_replace: &#x27;&#x27; # 用给定字符串替换代码块内的制表符。 默认为 2 个空格。 line_threshold: 5 # 接受一个可选的阈值，只有代码块的行数超过这个阈值才显示行数。 默认值为 0。 wrap: true # 支持行号显示 hljs: false # 当 hljs 设置为 true 时，所有代码块的 HTML 输出均会给 class 添加 hljs- 前缀（无论 wrap 是否开启 # 代码块的设置, 请参考 PrismJS 进行设置 # https://hexo.io/zh-cn/docs/syntax-highlight#PrismJS prismjs: preprocess: true # Hexo 内建的 PrismJS 支持浏览器端高亮（preprocess 设置为 false）和服务器端高亮（preprocess 设置为 true）两种方式。 line_number: true # 因为 line_number 功能依赖 wrap，你无法在配置中关闭 wrap 而又开启 line_number。 如果你将 line_number 设置为 true 的话，wrap 将被自动开启 tab_replace: &#x27;&#x27; # 将代码块内的 \\t 替换为给定的字符串。 默认为 2 个空格。 line_threshold: 5 # 接受一个可选的阈值，只有代码块的行数超过这个阈值才显示行数。 默认值为 0。 # Home page setting # path: Root path for your blogs index page. (default = &#x27;&#x27;) # per_page: Posts displayed per page. (0 = disable pagination) # order_by: Posts order. (Order by date descending by default) # https://github.com/hexojs/hexo-generator-index index_generator: # 生成帖子档案，由hexo-generator-index提供支持 path: &#x27;&#x27; # 博客索引页的根路径 per_page: 10 # 每页显示的帖子。 order_by: -date # 帖子订单。默认情况下按降序日期（从新到旧）排序。 pagination_dir: page # URL格式，参见下面的分页设置 # Category &amp; Tag default_category: post # 默认分类 category_map: # 分类别名 tag_map: # 标签别名 # Metadata elements ## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta meta_generator: true # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD # 日期格式 time_format: HH:mm:ss # 时间格式 ## 当 Front Matter 中没有指定 updated 时 updated 的取值 ### mtime: 使用文件的最后修改时间。 这是从 Hexo 3.0.0 开始的默认行为。 ### date: 使用 date 作为 updated 的值。 可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变 ### empty: 直接删除 updated。 使用这一选项可能会导致大部分主题和插件无法正常工作。 updated_option: &#x27;date&#x27; # Pagination ## 每页显示的帖子数。 0 关闭分页功能 per_page: 100 pagination_dir: page # 使用以下选项可明确处理或忽略某些文件/文件夹。 可以使用 glob 表达式 进行路径匹配。 ## include 和 exclude 选项只会应用到 source/ ，而 ignore 选项会应用到所有文件夹 # https://hexo.io/zh-cn/docs/configuration include: # 包含隐藏文件（包括名称以下划线开头的文件/文件夹，* 除外） exclude: # 排除文件或文件夹 ignore: # 忽略文件/文件夹 # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: stellar# 部署设置 # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: - type: git repo: git@github.com:Missiu/missiu.github.io.git # example, https://github.com/hexojs/hexojs.github.io branch: main - type: ali-oss region: &lt;您的oss 区域代码&gt; accessKeyId: &lt;您的oss accessKeyId&gt; accessKeySecret: &lt;您的oss accessKeySecret&gt; bucket: &lt;您的bucket name&gt;\tcacheControl: images: public, max-age=15552000 # 缓存时间6个月 css: public, max-age=1209600 # 缓存时间14天 js: public, max-age=259200 # 缓存时间3天 html: public, max-age=259200 # 缓存时间3天 other: no-cache # 缓存时间0 stellara配置文章封面# 可以在 front-matter 里配置自己的图片地址,比如cover: /workflow/IMG-20240808143434703.png 文章推荐123456789# 要实现相关文章推荐功能，您需要安装插件npm i hexo-related-popular-posts -save# 在 _config.stellar.yml 中配置## 开启后会在每篇文章的下方推荐相同类型的文章article: related_posts: enable: true title: 您可能感兴趣的文章 文章配置12345678# 在主题配置文件中：_config.stellar.ymlarticle: # 建议您通过 `description` 或者 `excerpt` 方式生成摘要，但如果您希望自动从文章内容截取一定字数的文字作为摘要，可以这样设置：\tauto_excerpt: 200 # 许可协议\tlicense: &#x27;本文由 [Mr. Hu](/about/) 原创, 采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。&#x27;\t# 分享链接\tshare: [wechat, weibo, link] 实现博客专栏这个专栏有点文章分类的那个意味，建议用于处理5篇及其一下的同类型文章 在文章 front-matter 里配置 topic 字段 # 这个值是专栏唯一值 ，比如：Java 专栏topic: java 创建一个专栏：在 blog/source/_data/ 文件夹中创建一个 topic 文件夹，在其中放入各个专栏的描述文件，文件名就是项目的 id，比如这里是 java # 这里是blog/source/_data/topic/java.ymlname: Java # 在面包屑导航上会显示较短的名字 title: Java 由Java基础到Java高级 # 在列表页会显示完整的专栏标题 description: 包含Java基础知识、JVM、Java多线程，以及常问面试题order_by: -date # 默认是按发布日期倒序排序 示例路径： 关于页面# 直接在source/about创建index.md文件即可# 建议指定 front-matter 的 menu_id为about，这会影响后续侧边栏的配置--- menu_id: about --- 实现文档功能这个文档功能可以处理很多的同类型文章，需要注意的是其存放的位置不同于其他文章，同样以Java为例： 修改wiki路径（可选）： # 在_config.stellar.yml目录下site_tree: wiki: base_dir: books # books / products ... 在 blog/source/_data/ 文件夹中创建一个 wiki 文件夹，在其中放入各个项目的文档。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 这里是blog/source/_data/wiki/java.yml# 基本信息 name: Java # 在面包屑导航上会显示较短的名字 title: Java 由Java基础到Java高级 # 在列表页会显示完整的专栏标题 description: 包含Java基础知识、JVM、Java多线程，以及常问面试题 tags: icon:# 是否显示封面cover: coverpage: false # 该文档的仓库链接（如果有） repo: Missiu/Beaudar-Comments # 配置搜索功能 search: filter: /books/java/ placeholder: 在 Java 中搜索... # 显示许可协议license: true# 显示分享share: true# 如果您希望自定义某个项目的侧边栏组件，可以设置 `sidebar` 值leftbar: - tree # 目录树 # - timeline_stellar_releases # 发布时间线 # - related # 相关文章 # 项目评论设置 comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/Missiu/Beaudar-Comments/issues) 反馈。&#x27; # 评论服务配置 comments: service: beaudar beaudar: repo: Missiu/Beaudar-Comments # 修改 wiki 路径 优先级最高，每个不同的文档可以配置不同的base_dirsite_tree: wiki: base_dir: books # books / products ...# 基础目录设置 base_dir: /books/java/ # 指定项目所在文件夹和目录树tree: &#x27;快速开始&#x27;: - workflow/workflow &#x27;基本使用&#x27;: - JVM/JVM 需要给文章添加关键字，然后该文章可能在 source/books/java/workflow目录下 # front-matterwiki: java 在 blog/source/_data/ 文件夹中创建一个 wiki.yml 文件，在其中写入需要显示的项目 - java 示例路径 侧边栏导航我的侧边栏设计为 ： 博客 + 文档 + 关于 三个部分 ，需要针对这个三个部分进行设置 1234567891011121314151617181920212223# 在_config.stellar.yml文件里# 侧边栏主功能导航菜单 menubar: columns: 3 # 一行多少个 items: # 可按照自己需求增加，符合以下格式即可 # id: 页面中高亮的 menu_id # theme: 高亮时的颜色，仅 svg 中 fill=&quot;currentColor&quot; 时有效 # icon: 支持 svg/img 标签，可以定义在 icons.yml 文件中，也支持外部图片的 URL # title: 标题 # url: 点击跳转到哪，支持相对路径和绝对路径 - id: post theme: &#x27;&#x27; icon: &#x27;&#x27; title: 专栏 url: /topic/ - id: wiki theme: &#x27;&#x27; icon: &#x27;&#x27; title: 文档 url: /wiki/ - id: about theme: &#x27;&#x27; icon: &#x27;&#x27; title: 关于 url: /about/ 侧边栏背景12345678# 在_config.stellar.yml中style: leftbar: # 可以设置：纯色/渐变色/图片作为背景 # background: var(--leftbar-bg) background-image: url(/images/background.png) blur-px: 200px blur-bg: var(--alpha50) 搜索功能12345678# 在_config.stellar.yml中search: service: local_search # local_search, algolia_search, todo... local_search: # 在 front-matter 中设置 indexing:false 来避免被搜索索引 field: all # post, page, all path: /search.json # 搜索文件存放位置 content: true # 是否搜索内容 codeblock: true # 是否搜索代码块 评论功能Beaudar 是 Utterances 的中文版本，相比 Utterances 有更多的体验优化，可以按时间倒序排序。 # _config.stellar.ymlcomments: service: beaudar beaudar: repo: Missiu/Beaudar-Comments 在obsidian中的 front-matter建议在obsidian安装插件：Templater 在其中新进文本文件比如： front-matter.txt 1234567891011121314151617181920212223242526272829---# 文章标题 title: （一）充分利用云服务器，如何围绕云服务器搭建自己的工作流# 文章创建时间date: 2024-08-18 21:01:43# 标签列表tags: []# 分类列表categories: []# 文章更新时间updated: 2024-08-18 21:01:43# 封面图片链接cover: # 文章置顶顺序，数字越大越靠前sticky:# 参考资料列表references: []# 是否允许评论comments: true# 是否允许被搜索引擎收录,设置 false 避免被搜索indexing: truetopic: []# tech/storytype: tech# 专栏 idtopic: # 文档 idwiki: --- 完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580######## Stellar info ######## stellar: version: &#x27;1.29.1&#x27; homepage: &#x27;https://xaoxuu.com/wiki/stellar/&#x27; repo: &#x27;https://github.com/xaoxuu/hexo-theme-stellar&#x27; main_css: /css/main.css main_js: /js/main.js ######## head tags ######## preconnect: # - https://gcore.jsdelivr.net # - https://cdn.jsdelivr.net # - https://unpkg.com open_graph: enable: true twitter_id: # for open_graph meta ######## Sidebar ######## # 左上角显示的 logo 区域，包含图标、大标题、副标题 logo: avatar: &#x27;[&#123;config.avatar&#125;](/about/)&#x27; # you can set avatar link in _config.yml or &#x27;[https://xxx.png](/about/)&#x27; title: &#x27;[&#123;config.title&#125;](/)&#x27; # you can set html tag like: &#x27;[&lt;img no-lazy height=&quot;32px&quot; src=&quot;xxx&quot;/&gt;](/)&#x27; subtitle: &#x27;&#123;config.subtitle&#125;&#x27; # &#x27;文字1 | 文字2&#x27; (鼠标放上去会切换到文字2) # 侧边栏主功能导航菜单 menubar: columns: 3 # 一行多少个 items: # 可按照自己需求增加，符合以下格式即可 # id: 页面中高亮的 menu_id # theme: 高亮时的颜色，仅 svg 中 fill=&quot;currentColor&quot; 时有效 # icon: 支持 svg/img 标签，可以定义在 icons.yml 文件中，也支持外部图片的 URL # title: 标题 # url: 点击跳转到哪，支持相对路径和绝对路径 - id: post theme: &#x27;&#x27; icon: &#x27;&#x27; title: 专栏 url: /topic/ - id: wiki theme: &#x27;&#x27; icon: &#x27;&#x27; title: 文档 url: /wiki/ - id: about theme: &#x27;&#x27; icon: &#x27;&#x27; title: 关于 url: /about/ # - id: post # theme: &#x27;#1BCDFC&#x27; # icon: solar:documents-bold-duotone # title: 博客 # url: / # - id: wiki # theme: &#x27;#3DC550&#x27; # icon: solar:notebook-bookmark-bold-duotone # title: 文档 # url: /wiki/ # - id: explore # theme: &#x27;#FA6400&#x27; # icon: solar:planet-bold-duotone # title: 探索 # url: /explore/ # - id: social # theme: &#x27;#F44336&#x27; # icon: solar:chat-square-like-bold-duotone # title: 社交 # url: /friends/ ######## Main ######## # 站点主结构树 site_tree: # -- 列表类页面 -- # # 主页配置 home: leftbar: welcome, recent rightbar: # 博客列表页配置 index_blog: base_dir: blog # 只影响自动生成的页面路径 menu_id: post # 未在 front-matter 中指定 menu_id 时，layout 为 post 的页面默认使用这里配置的 menu_id leftbar: welcome, recent # for categories/tags/archives rightbar: nav_tabs: # 近期发布 分类 标签 专栏 归档 and ... # &#x27;朋友文章&#x27;: /friends/rss/ # 博客专栏列表页配置 index_topic: base_dir: topic # 只影响自动生成的页面路径 menu_id: post # 未在 front-matter 中指定 menu_id 时，layout 为 topic 的页面默认使用这里配置的 menu_id # 文档列表页配置 index_wiki: base_dir: wiki # 只影响自动生成的页面路径 menu_id: wiki # 未在 front-matter 中指定 menu_id 时，layout 为 wiki 的页面默认使用这里配置的 menu_id leftbar: related, recent # for wiki rightbar: nav_tabs: # &#x27;more&#x27;: https://github.com/xaoxuu # -- 内容类页面 -- # # 博客文章内页配置 post: menu_id: post # 未在 front-matter 中指定 menu_id 时，layout 为 post 的页面默认使用这里配置的 menu_id leftbar: related, recent # for pages using &#x27;layout:post&#x27; rightbar: ghrepo, toc # 博客专栏文章内页配置 topic: menu_id: post # 文档内页配置 wiki: menu_id: wiki # 未在 front-matter 中指定 menu_id 时，layout 为 wiki 的页面默认使用这里配置的 menu_id leftbar: tree, related, recent # for wiki rightbar: ghrepo, toc # 笔记本列表页配置 notebooks: base_dir: notebooks # 笔记本列表页的路径。以及未指定 base_dir 的笔记本的路径前缀。 menu_id: notebooks # 笔记本列表页高亮的主导航栏菜单按钮。 # 笔记本列表页的左侧栏和右侧栏。 leftbar: recent # recent within all notebooks rightbar: null # 笔记列表页配置 notes: # 笔记列表页和笔记页高亮的主导航栏菜单按钮。 # 可以在笔记本 yaml 的 menu_id 字段中覆盖此参数。 # 可以在笔记的 front-matter/menu_id 中覆盖此参数。 menu_id: notebooks # 笔记列表页的左侧栏和右侧栏。可以在笔记本 yaml 的 leftbar 和 rightbar 字段中覆盖此参数。 leftbar: tagtree, recent # recent of current notebook rightbar: null # 笔记页配置 note: # 笔记页的左侧栏和右侧栏 # 可以在笔记本 yaml 的 note_leftbar 和 note_rightbar 字段中覆盖此参数。 # 可以在笔记的 front-matter/leftbar 和 rightbar 字段中覆盖此参数。 leftbar: tagtree, recent # recent of current notebook rightbar: toc # 作者信息配置 author: base_dir: author # 只影响自动生成的页面路径 menu_id: post leftbar: recent, timeline rightbar: timeline # 错误页配置 error_page: menu_id: post &#x27;404&#x27;: &#x27;/404.html&#x27; leftbar: recent, timeline rightbar: timeline # 其它自定义页面配置 layout: page page: leftbar: recent rightbar: toc ######## Notebook ######## notebook: # 如果没有指定 excerpt 和 description，将自动取多长的内容作为文章摘要。 auto_excerpt: 128 # 可以为某个 tag 设定图标（显示在标签树中）。 tagcons: &#x27;&#x27;: solar:hashtag-linear # 每页显示多少篇笔记。0 表示不分页，null 则 fallback 到 hexo 的配置。 # 可以在笔记本 yaml 的 per_page 字段中覆盖此参数。 per_page: null # 笔记的排序方式。默认按照 updated 降序排序。 # 可以在笔记本 yaml 的 order_by 字段中覆盖此参数。 # 注意：置顶的笔记会始终排在最前面。 # 在 front-matter 中设置 pin:true|number 或 sticky:true|number 来置顶。 order_by: -updated # 是否在笔记页面显示许可协议。false 表示不显示。true 表示沿用主题许可协议内容。也可以给定具体的文本指定协议内容。 # 可以在笔记本 yaml 的 license 字段中覆盖此参数。 # 可以在笔记的 front-matter/license 中覆盖此参数。 license: false # 是否在笔记页面显示分享按钮。 # 可以在笔记本 yaml 的 share 字段中覆盖此参数。 # 可以在笔记的 front-matter/share 中覆盖此参数。 share: false ######## Article ######## article: # 文章类型，决定布局风格，可以在 front-matter/topic/wiki 中覆盖此参数 type: tech # tech: 默认技术类文章, story: 图文类文章，文字和段落间增距大 # 缩进两个文字宽度，适合文字类博客，可以在 front-matter/topic/wiki 中覆盖此参数 indent: # true / false # 如果没有指定封面，是否根据 tags 作为关键词搜索封面图片？ auto_cover: false # search from https://source.unsplash.com/ # 封面图宽高比 cover_ratio: 2.4 # 如果没有指定横幅，是否根据 tags 作为关键词搜索横幅图片？ auto_banner: false # search from https://source.unsplash.com/ # 如果没有指定 excerpt 和 description，将自动取多长的内容作为文章摘要？ auto_excerpt: 128 # 分类颜色 category_color: &#x27;探索号&#x27;: &#x27;#f44336&#x27; # 文章许可协议 license: &#x27;本文由 [Mr. Hu](/about/) 原创, 采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。&#x27; # 分享 share: [ wechat, weibo, link ] # [wechat, weibo, email, link] # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: true title: 您可能感兴趣的文章 max_count: 5 search: service: local_search # local_search, algolia_search, todo... local_search: # 在 front-matter 中设置 indexing:false 来避免被搜索索引 field: all # post, page, all path: /search.json # 搜索文件存放位置 content: true # 是否搜索内容 codeblock: true # 是否搜索代码块（需要content: true) algolia_search: # Docsearch https://docsearch.algolia.com/apply/ 申请 appId: apiKey: indexName: ######## Comments ######## comments: service: beaudar # beaudar, utterances, giscus, twikoo, waline, artalk comment_title: 快来参与讨论吧~ lazyload: false # true / false # beaudar # https://beaudar.lipk.org/ beaudar: repo: Missiu/Beaudar-Comments issue-term: pathname issue-number: theme: preferred-color-scheme label: input-position: top # top/bottom 评论框位置 comment-order: desc # desc 排序 keep-theme: # true/false loading: false branch: main # utterances # https://utteranc.es/ utterances: repo: xxx/xxx issue-term: pathname issue-number: theme: preferred-color-scheme label: # giscus # https://giscus.app/zh-CN giscus: src: https://giscus.app/client.js data-repo: xxx/xxx # [在此输入仓库] data-repo-id: # [在此输入仓库 ID] data-category: # [在此输入分类名] data-category-id: data-mapping: pathname data-strict: 0 data-reactions-enabled: 1 data-emit-metadata: 0 data-input-position: top # top, bottom data-theme: preferred_color_scheme data-lang: zh-CN data-loading: # lazy crossorigin: anonymous # Twikoo # https://twikoo.js.org/ twikoo: js: https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js # 建议锁定版本 envId: https://xxx # vercel函数 # Waline # https://waline.js.org/ waline: js: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline.js css: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline.css meta_css: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline-meta.css # Waline server address url, you should set this to your own link serverURL: https://waline.vercel.app # If false, comment count will only be displayed in post page, not in home page commentCount: true # Pageviews count, Note: You should not enable both `waline.pageview` and `leancloud_visitors`. pageview: false # Custom emoji # emoji: # - https://unpkg.com/@waline/emojis@1.1.0/weibo # - https://unpkg.com/@waline/emojis@1.1.0/alus # - https://unpkg.com/@waline/emojis@1.1.0/bilibili # - https://unpkg.com/@waline/emojis@1.1.0/qq # - https://unpkg.com/@waline/emojis@1.1.0/tieba # - https://unpkg.com/@waline/emojis@1.1.0/tw-emoji # - https://unpkg.com/@waline/emojis@1.1.0/bmoji # 设置自己的图床服务，替换默认的 Base 64 编码嵌入（有体积大小限制），在评论中上传图片更加方便 # imageUploader: # 适配了兰空图床V1、V2版本 # 以兰空图床V1为例，下列填写内容为： # fileName: file # tokenName: Authorization # api: https://xxxxxx/api/v1/upload # token: Bearer xxxxxxxxxxxxxx # resp: data.links.url # 以兰空图床V2为例，下列填写内容为： # fileName: image # tokenName: token # api: https://xxxxxx/api/upload # token: xxxxxxxxxxxxxx # resp: data.url # fileName: # 根据版本二选一 # tokenName: # 根据版本二选一 # api: # 图床 api 地址 # token: # 图床验证 # resp: # 图片地址返回值的字段 # Artalk # https://artalk.js.org/ artalk: css: https://unpkg.com/artalk@2.8.5/dist/Artalk.css js: https://unpkg.com/artalk@2.8.5/dist/Artalk.js server: # 后端服务地址 placeholder: &#x27;&#x27; darkMode: auto ######## Footer ######## footer: social: # github: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg&quot;/&gt;&#x27; # url: / # music: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3845874.svg&quot;/&gt;&#x27; # url: / # unsplash: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3616429.svg&quot;/&gt;&#x27; # url: / # comments: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/942ebbf1a4b91.svg&quot;/&gt;&#x27; # url: /about/#comments # theme: # icon: default:theme # onclick: &#x27;switchTheme()&#x27; sitemap: # &#x27;博客&#x27;: # - &#x27;[近期](/)&#x27; # - &#x27;[分类](/)&#x27; # - &#x27;[标签](/)&#x27; # - &#x27;[归档](/)&#x27; # &#x27;项目&#x27;: # - &#x27;[开源库](/)&#x27; # &#x27;社交&#x27;: # - &#x27;[友链](/)&#x27; # - &#x27;[留言板](/)&#x27; # &#x27;更多&#x27;: # - &#x27;[关于本站](/)&#x27; # - &#x27;[GitHub](/)&#x27; content: | # 支持 Markdown 格式 本站由 [&#123;author.name&#125;](/) 使用 [&#123;theme.name&#125; &#123;theme.version&#125;](&#123;theme.tree&#125;) 主题创建。 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。 # 主题用户越多，开发者维护和更新的积极性就越高，如果您喜欢本主题，请在适当的位置显示主题信息和仓库链接以表支持。 ######## Tag Plugins ######## tag_plugins: # &#123;% box %&#125; / &#123;% note %&#125; note: default_color: &#x27;&#x27; # light, dark, red, orange, yellow, green, cyan, blue, purple, warning, error border: true # true / false # &#123;% checkbox %&#125; checkbox: interactive: false # enable interactive for user # &#123;% quot %&#125; quot: default: # 可以自行配置多种图标方案 prefix: https://bu.dusays.com/2022/10/24/63567d3e092ff.png suffix: https://bu.dusays.com/2022/10/24/63567d3e0ab55.png hashtag: prefix: https://bu.dusays.com/2022/10/24/63567d3e07da3.png question: prefix: ph:seal-question-fill # &#123;% emoji %&#125; emoji: default: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/&#123;name&#125;.gif twemoji: https://gcore.jsdelivr.net/gh/twitter/twemoji/assets/svg/&#123;name&#125;.svg qq: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/&#123;name&#125;.gif aru: https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/&#123;name&#125;.gif tieba: https://gcore.jsdelivr.net/gh/cdn-x/emoji/tieba/&#123;name&#125;.png blobcat: https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/&#123;name&#125;.png icon: # 留空时，图标和文字颜色相同 default_color: accent # theme, accent, red, orange, yellow, green, cyan, blue, purple # &#123;% button 标题 链接 %&#125; button: default_color: theme # theme, accent, red, orange, yellow, green, cyan, blue, purple # &#123;% image %&#125; image: fancybox: false # true, false # &#123;% copy xxx %&#125; copy: toast: 复制成功 # &#123;% timeline %&#125; timeline: max-height: 80vh # &#123;% mark %&#125; mark: default_color: yellow # light, dark, red, orange, yellow, green, cyan, blue, purple, warning, error # &#123;% hashtag %&#125; hashtag: default_color: # red, orange, yellow, green, cyan, blue, purple # &#123;% okr o1 percent:0.5 status:normal %&#125; okr: border: true # 是否显示边框 status: # 可以自行增加 # 进行中状态 in_track: color: blue # red, orange, yellow, green, cyan, blue, purple label: 正常 at_risk: color: yellow label: 风险 off_track: color: orange label: 延期 # 结果状态 finished: color: green label: 已完成 unfinished: color: red label: 未完成 # &#123;% gallery %&#125; gallery: layout: grid # grid / flow size: mix # s / m / l / xl / mix ratio: square # origin / square # 基础依赖 dependencies: jquery: https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js marked: https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js # 内置服务，按需加载（页面内用到了就会加载，没有用到就不会加载） data_services: # 外部 md 渲染 mdrender: js: /js/services/mdrender.js # 数据填充类 siteinfo: js: /js/services/siteinfo.js # 设置 api 可以自动提取网页标题、图标，服务部署方法：https://github.com/xaoxuu/site-info-api/ # 接口测试通过后，把按钮的 href 部分替换成 &#123;href&#125; 之后填写到下方，例如：https://api.vlts.cc/site_info/v1?url=&#123;href&#125; api: ghinfo: js: /js/services/ghinfo.js # 网格布局类 sites: js: /js/services/sites.js friends: js: /js/services/friends.js # 列表布局类 timeline: js: /js/services/timeline.js fcircle: js: /js/services/fcircle.js weibo: js: /js/services/weibo.js memos: js: /js/services/memos.js # 扩展插件接入方法：(插件名下面用 #plugin# 代替) # 1. 在这里增加 #plugin# 配置，至少赢含有 enable 字段，默认为空（不启用） # 2. 新建文件 layout/_plugins/#plugin#.ejs 文件中设置编写加载代码。 # 2.1. 在该文件中可以直接使用 conf 来读取用户在【步骤 1】填写的配置字段内容 # 2.2. 如果需要引入 css 或 js，可以使用 utils.css(xxx)、utils.js(xxx)，具体可参考 layout/_plugins/fancybox.ejs# 2.3. 如果需要本地 js 文件，请放入 /source/js/plugins 文件夹中，引入方式为：utils.js(&#x27;/js/plugins/xxx.js&#x27;); # 3. 如果这个插件只需要引入外部文件，可以在【步骤 1】处增加 inject 字段，而无需进入【步骤 2】创建 ejs，参考 katexplugins: # preload preload: enable: true service: flying_pages # flying_pages flying_pages: https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js # lazyload # https://www.npmjs.com/package/vanilla-lazyload lazyload: enable: true # [hexo clean &amp;&amp; hexo s] is required after changing this value. js: https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js transition: fade # blur, fade # https://fancyapps.com/docs/ui/fancybox/ # available for &#123;% image xxx %&#125; fancybox: enable: true loader: /js/plugins/fancybox-loader.js js: https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js css: https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css # 让 md 语法图片支持放大可以这样写: .md-text img:not([class]), .md-text .image img # 可以处理评论区的图片（不支持 iframe 类评论系统）例如： # 使用 twikoo 评论可以写: .tk-content img:not([class*=&quot;emo&quot;]) # 使用 waline 评论可以写: #waline_container .vcontent img selector: .timenode p&gt;img # 多个选择器用英文逗号隔开 # swiper swiper: enable: true css: https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css js: https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js # https://scrollrevealjs.org/api/reveal.html scrollreveal: enable: #true js: https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js distance: 16px duration: 800 # ms interval: 100 # ms scale: 1 # 0.1~1 # AI 摘要 # https://github.com/qxchuckle/Post-Summary-AI tianli_gpt: enable: #true js: https://jsd.onmicrosoft.cn/gh/qxchuckle/Post-Summary-AI@6.0/chuckle-post-ai.min.js field: post # all, post, wiki key: 5Q5mpqRK5DkwT1X9Gi5e # tianli_gpt key total_length: 1000 # 设置提交的字数限制，默认为1000字，上限为5000，超过5000字符将被截断 typewriter: true # 打字机动画 summary_directly: true # 是否直接显示摘要，否则显示 AI 简介 rec_method: all # all, web # 文章推荐方式，all：匹配数据库内所有文章进行推荐，web：仅当前站内的文章，默认all hide_shuttle: true # 是否隐藏矩阵穿梭 summary_toggle: false interface: name: AI摘要 introduce: &#x27;我是文章辅助AI: QX-AI，点击下方的按钮，让我生成本文简介、推荐相关文章等。&#x27; version: TianliGPT button: [&quot;介绍自己&quot;, &quot;推荐文章&quot;, &quot;生成摘要&quot;, &quot;矩阵穿梭&quot;] # Katex - The fastest math typesetting library for the web # https://katex.org/docs/autorender.html # https://github.com/KaTeX/KaTeX # 使用 hexo-renderer-markdown-it-plus 作为公式渲染器：npm uninstall hexo-renderer-marked --save npm install hexo-renderer-markdown-it-plus --save katex: enable: #true # hexo-renderer-markdown-it-plus 默认开启 katex，此选项仅用于引入样式 inject: | &lt;link rel=&quot;stylesheet&quot; href=&quot;https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css&quot; integrity=&quot;sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0&quot; crossorigin=&quot;anonymous&quot;&gt; # MathJax # 需在Markdown文件开头加入mathjax: true # 推荐使用Pandoc: npm uninstall hexo-renderer-marked --save &amp; npm install hexo-renderer-pandoc --save mathjax: enable: # true # 可以在特定文章的 front-matter 中设置 mathjax: true 来开启，也可以在这里设置全局开启 js: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML # Mermaid - markdwon to flow chart, seq chart, class chart ... # 需要安装 npm install --save hexo-filter-mermaid-diagrams # 使用时 需要在Markdown文件开头加入 mermaid: true # 使用示例： # ```mermaid # graph LR # A(Section A) --&gt;|option 1| B(Section A) # B --&gt;|option 2| C(Section C) # ``` mermaid: enable: # true # 可以在特定文章的 front-matter 中设置 mermaid: true 来开启，也可以在这里设置全局开启 style_optimization: false # use custom style in stellar # js: https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js js: https://cdn.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js # Available themes: default | dark | forest | neutral theme: neutral # 代码块复制按钮 copycode: enable: true default_text: &#x27;Copy&#x27; success_text: &#x27;Copied&#x27; toast: 复制成功 # 赫蹏 (Heti) - 专为中文网页内容设计的排版样式增强 # https://github.com/sivan/heti heti: enable: false # 此插件会和代码块冲突，仅适用于纯中文博主。 css: https://unpkg.com/heti@0.9.2/umd/heti.min.css js: https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js style: prefers_theme: auto # auto / light / dark smooth_scroll: false # true / false 开启时如果目录过长可能无法准确定位 font-size: root: 16px # 改这个会影响全局所有文字的字号 body: 17px # 影响正文区域的字号，如果改成 px 则不受 root 影响 code: 85% # 相较于其所在行的文本大小，建议用百分比 codeblock: 0.8125rem # 13px font-family: logo: &#x27;system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#x27; body: &#x27;system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#x27; code: &#x27;Menlo, Monaco, Consolas, system-ui, &quot;Courier New&quot;, monospace, sans-serif&#x27; codeblock: &#x27;Menlo, Monaco, Consolas, system-ui, &quot;Courier New&quot;, monospace, sans-serif&#x27; text-align: left prefix: h2: https://api.iconify.design/ci:heading-h2.svg border-radius: card-l: 16px # 侧边栏、文章横幅位置的圆角 card: 12px # 文章内大部分卡片的圆角 bar: 8px # 横条类元素的圆角 image: 12px # 图片圆角 color: # 动态颜色（会根据明暗主题重设明度值，只用关心色相和饱和度即可） background: &#x27;hsl(212 16% 98%)&#x27; # 浅色背景颜色 block: &#x27;hsl(212 8% 95%)&#x27; # 块背景颜色 code: &#x27;hsl(220 20% 10%)&#x27; # &#x27;hsl(14 100% 48%)&#x27; # 行内代码颜色 text: &#x27;hsl(0 0% 20%)&#x27; # 文本颜色 # 主题色配置（不会根据明暗动态调整，请设置为通用的颜色） theme: &#x27;hsl(192 98% 55%)&#x27; # 主题色 accent: &#x27;hsl(14 100% 57%)&#x27; # 强调色 link: &#x27;hsl(207 90% 54%)&#x27; # 超链接颜色 hover: &#x27;hsl(14 100% 57%)&#x27; # 按钮高亮颜色 animated_avatar: animate: auto # auto, always background: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp codeblock: scrollbar: 4px highlightjs_theme: https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css loading: loading: 正在加载 error: 加载失败，请稍后重试。 gradient: # https://webgradients.com/ start: &#x27;linear-gradient(to right, hsl(215, 95%, 64%), hsl(195, 95%, 60%), hsl(165, 95%, 56%), hsl(165, 95%, 56%), hsl(195 95% 60%), hsl(215, 95%, 64%))&#x27; leftbar: # 可以设置：纯色/渐变色/图片作为背景 # background: var(--leftbar-bg) background-image: url(/images/background.png) blur-px: 200px blur-bg: var(--alpha50) paginator: prev: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/arrow/f049bbd4e88ec.svg next: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/arrow/064b95430caf4.svg error_page: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/404/1c830bfcd517d.svg site: background-image: #&#x27;url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.14/image/site-bg1@small.webp)&#x27; # 未完全适配，慎用 blur-px: 100px blur-bg: var(--alpha75) default: avatar: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg link: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg cover: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg image: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg project: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2779789.png banner: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/banner/books.jpg topic: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/10433048.png api_host: ghapi: https://api.github.com ghraw: https://raw.githubusercontent.com gist: https://gist.github.com 自动化自动同步把博客的source和笔记的进行同步，比如：D:\\My\\Notes\\_source ---- D:\\My\\blog\\source。我这里使用FreeFileSync同步电脑本地目录，下载地址https://freefilesync.org/。 打开绿色的，拖动两个要同步的目录，就双向同步就行，保存下来。然后打开红色的，把保存下来的文件拖进去，点击开始进行自动同步。然后创建快捷方式，打开 win+r 输入 shell:startup ，把快捷方式拖进去。 自动发布编写脚本：注意日志路径，同样创建快捷方式，把它放大笔记的某个地方，点击就可以推送到github和oss 123456789101112131415161718192021222324252627282930#!/bin/bash # 设置日志文件路径（将路径替换为你想保存日志的实际路径） LOGFILE=&quot;D:/My/Notes/_drafts/deploy_log.txt&quot; # 确保日志文件为空并设置为 UTF-8 编码 : &gt; &quot;$LOGFILE&quot; # 清空文件内容 # 清理 Hexo 生成的文件 echo &quot;正在执行 hexo clean...&quot; | tee -a &quot;$LOGFILE&quot; if ! hexo clean 2&gt;&amp;1 | tee -a &quot;$LOGFILE&quot;; then echo &quot;hexo clean 执行失败，脚本终止。&quot; | tee -a &quot;$LOGFILE&quot; exit 1 fi # 生成静态文件 echo &quot;正在执行 hexo generate...&quot; | tee -a &quot;$LOGFILE&quot; if ! hexo generate 2&gt;&amp;1 | tee -a &quot;$LOGFILE&quot;; then echo &quot;hexo generate 执行失败，脚本终止。&quot; | tee -a &quot;$LOGFILE&quot; exit 1 fi # 部署生成的文件到指定的目标位置 echo &quot;正在执行 hexo deploy...&quot; | tee -a &quot;$LOGFILE&quot; if ! hexo deploy 2&gt;&amp;1 | tee -a &quot;$LOGFILE&quot;; then echo &quot;hexo deploy 执行失败，脚本终止。&quot; | tee -a &quot;$LOGFILE&quot; exit 1 fi echo &quot;所有任务完成！&quot; | tee -a &quot;$LOGFILE&quot; nginx代理详细见 nginx 章节。这里注意如果是要访问oss，那么需要在nginx.conf 里设置 user 为root 身份进行运行。 配置文件如下：配置文件在&#x2F;etc&#x2F;nginx&#x2F;conf.d里。而nginx.conf 在其上一级目录 12345678910111213141516# blogserver &#123; listen 443 ssl; server_name www.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; # 我这里是oss目录 root /home/data/blog; index index.html index.htm; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 示例图：ps aux | grep nginx","tags":[null,null,null,null,null],"categories":[null]},{"title":"Nginx 反向代理速成教学与泛域名证书的申请","path":"/workflow/nginx.html","content":"摘要本指南介绍了三种 Nginx 安装方法：直接安装、从源码编译安装及 Docker 安装。直接安装最为简便，适合大多数情况；从源码编译安装提供更高灵活性；Docker 安装则便于容器化部署。此外，还介绍了如何配置 Nginx 实现反向代理和 HTTPS 加密访问，例如将所有 sync.exp.com 的请求转发到 http://127.0.0.1:8384。 安装直接安装(建议)sudo apt update sudo apt install nginx-full# 目录在/etc/nginxwhereis nginx 编译安装（可能缺失模块）123456789101112131415161718192021222324cd /home# https://github.com/syncthing/syncthing/releaseswget https://nginx.org/download/nginx-1.26.2.tar.gz# 解压tar -xzvf nginx-1.26.2.tar.gz # 删除压缩包rm -f nginx-1.26.2.tar.gz# 重命名(可选)mv nginx-1.26.2 nginx# 创建日志文件sudo touch /home/logs/nginx.log# 编译sudo apt-get install build-essential libpcre3 libpcre3-dev zlib1g-dev openssl libssl-dev# --prefix：Nginx主要安装路径，后续Nginx子目录依照这个变量展开./configure \\--prefix=/home/nginx/nginxmake &amp;&amp; make install# 创建链接可以在任何地方访问nginxsudo ln -s /home/nginx/nginx/sbin/nginx /usr/local/bin/nginxwhich nginx docker安装目录：&#x2F;home&#x2F;docker&#x2F;nginx mkdir /home/docker/nginxcd /home/docker/nginxvi docker-compose.yml 先注释到nginx的挂载目录 运行容器 执行命令复制配置到主机，建议绝对目录 docker cp nginx:&#x2F;etc&#x2F;nginx &#x2F;home&#x2F;docker&#x2F;nginx 取消注释 重启容器 12345678910111213141516171819202122services: nginx: restart: always container_name: nginx image: nginx:latest # 设置内存限制为120MB mem_limit: 120m memswap_limit: -1 # user: root ports: - 80:80 - 443:443 volumes: - ./nginx:/etc/nginx - ./src:/var/www/html:rw,cached - ./certs:/etc/certs - /home/data:/home/data logging: driver: json-file options: max-size: &quot;3m&quot; max-file: &quot;3&quot; docker-compsoe up -d 进行部署 基础知识基础命令1234567891011# 测试配置文件是否有语法错误 nginx -t # 查看状态sudo systemctl status nginx# 启动sudo systemctl start nginx# 停止sudo systemctl stop nginx# 重新加载sudo systemctl reload nginx 反向代理先看如下代码： 123456789server &#123; listen 8000 ; server_name [服务器的ip地址|域名]; location / &#123; proxy_pass http://127.0.0.1:8080; ##需要代理的服务器地址 index index.html; &#125;&#125; 此代码是nginx配置的一部分，他有如下作用： 用户访问你的公网 ip:8000，该请求端口因为被nginx监听，所以会被nginx发送到地址为http://127.0.0.1:8080 ，也就是把8000端口请求转到了内网8080端口，然后返回root 目录下的index.html信息。 操作示例我们之前已经搭建好了syncthing服务器，假如我们购买的域名为 exp.com ，接下来我们将进行泛域名证书申请和反向代理实现https加密访问也就是 ssl&#x2F;tls。 泛域名证书申请SSL（安全套接字层）及其后继者TLS（传输层安全性）是用于在联网计算机之间建立经过身份验证和加密的链接的协议。尽管随着 1999 年 TLS 1.0 的发布，SSL 协议已被弃用，但仍普遍将这些相关技术称为“SSL”或“SSL&#x2F;TLS”。最新版本是TLS 1.3 ，在RFC 8446 （2018 年 8 月）中定义。 12345678910111213141516# 安装acmecurl https://get.acme.sh | shcd /root/.acme.sh# DNS-API验证## 输入阿里云角色的kye和Secret## 注意！记得授权，在授权页搜索DNS，全选授权export Ali_Key=export Ali_Secret=# 注册账号./acme.sh --register-account -m 12341234@163.com# 解析域名 baidu 为例./acme.sh --issue -d exp.com -d *.exp.com --dns dns_ali# 证书目录/root/.acme.sh/exp.com_ecc 通过一键脚本申请证书# 地址## https://github.com/Missiu/debian-script## 详细说明见sudo wget -O /home/acme.py https://raw.githubusercontent.com/Missiu/debian-script/main/py/acme.py &amp;&amp; pip install termcolor &amp;&amp; sudo chmod 700 /home/acme.py &amp;&amp; sudo python3 /home/acme.py 其中证书目录似乎无法设置成功：可以使用如下命令同步到acme sudo mv /root/.acme.sh /home/acme &amp;&amp; sudo ln -s /home/acme /root/.acme.sh 反向代理并部署到nginx上复制证书cd /root/.acme.shmkdir /etc/nginx/cert# _通过该命令可将_ _`~/.acme.sh/exp.top`_ _内的证书copy到指定位置`acme.sh`签发了新证书后就自动完成该拷贝过程./acme.sh --install-cert -d exp.com --key-file /etc/nginx/cert/exp.com.key --fullchain-file /etc/nginx/cert/exp.com.cer --reloadcmd &#x27;service nginx force-reload&#x27; 最简单的配置监听80端口，把所有请求转到 443 端口，并使用证书加密，这样所有该证书的子域名都可以生效 # 我们在conf.d新建 .conf 文件，因为nginx 默认导入了该文件夹下所有 .conf 文件cd /etc/nginx/conf.dvim exp.com.conf 以下代码，会监听80和443端口，所有exp.com的子域名，和exp.com都会被重定向到https，也就是访问443端口，然后443端口开起了ssl，我们访问exp.com的子域名sync.exp.com的所有请求都会被发送到http://127.0.0.1:8384 123456789101112131415161718# http(80) -&gt; https(443/ssl)server &#123; listen 80; server_name *.exp.top exp.top; return 301 https://$host$request_uri;&#125;# syncthingserver &#123; listen 443 ssl; server_name sync.exp.com; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8384/; &#125;&#125; 教程中所有nginx配置一览12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# http(80) -&gt; https(443/ssl)server &#123; listen 80; server_name *.exp.top exp.top; return 301 https://$host$request_uri;&#125;# syncthingserver &#123; listen 443 ssl; server_name sync.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8384/; &#125;&#125;# blogserver &#123; listen 443 ssl; server_name www.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; # 我这里是oss目录 root /home/data/blog; index index.html index.htm; location / &#123; try_files $uri $uri/ =404; &#125;&#125;# alistserver &#123; listen 443 ssl; server_name alist.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:5244/; &#125; # 处理 /d/ 请求，重写路径并代理到 80 端口 location /d/ &#123; rewrite ^/p/(.*)$ /$1 break; proxy_pass http://127.0.0.1:80/; &#125;&#125;server &#123; listen 80; server_name 127.0.0.1; root /home/data; location / &#123; try_files $uri $uri/ =404; &#125;&#125;#bitwortenserver &#123; listen 443 ssl; server_name bitwt.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8000/; &#125;&#125;#3xuiserver &#123; listen 443 ssl; server_name xui.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:2053/; &#125;&#125;","tags":[null,null,null,null],"categories":[null]},{"title":"基于syncthing+oss+云服务器的文件同步与数据备份教程","path":"/workflow/syncthing.html","content":"摘要从需求分析到具体实现，快速实现基于syncthing+oss+云服务器的文件同步与数据备份，此专栏的目的是充分利用云服务器，所以没有选择CDN，而是通过oss内外访问云服务，以云服务器为出口进行同步。 前言需求 数据安全，最重要的一个需求 备份容量，目前需求100G左右 价格不贵，百度云vip188&#x2F;年，以他为标准，浮动100左右 下载速度快，最起码别是100多kb&#x2F;s 可预览，可以线上看看图片、视频什么的 多端同步：最起码要可以把手机和电脑数据同步起来，最起码要有版本控制，以及多种同步类型 自动备份：要能自动备份多个不同的文件夹，比如图片、文档什么的 思路 Syncthing 是多端同步的工具，其功能类似于微力同步，但是开源，他是P2P的，这样就要求两个设备必须同时在线。 使用云服务器搭建Syncthing作为中转和备份服务器，这样就可以只一个设备在线，因为云服务器是不停机的 如果是需要经常同步的我选择直接存在服务器的云盘里 如果是备份，我在云服务器里挂载OSS为目录，通过内网访问OSS，这样就没有流量费用 使用alist挂载云服务器本地目录+rclone挂载Alist到电脑进行预览（可选） 页面展示Syncthing - 服务器 Syncthing - 电脑 Syncthing - 安卓 效果展示 服务器带宽 30M ，同步和备份时速度可接受，内存占用为100M以内 存储容量：云盘自带60G+OSS的40G &#x3D; 100G 电脑开机自启：Syncthing，完全无感 手机可以后台常驻运行Syncthing，记得开启允许后台高耗电，以及设置息屏联网，实现无感同步。 优点 可以无感备份与同步任何文件！ 速度取决于你的服务器，无限速问题 数据很安全，用的都是开源项目，数据放在阿里云的服务器和OSS里，如果还不放心可以增加容灾设计 可玩性较高，几乎完全满足需求！ 手机可以常驻后台备份！ 缺点 折腾起来比较麻烦 手机常驻后台会增加发热问题 syncthing 同步和冲突处理没有那么细的粒度 拓展 有时间可以整一个一键脚本，直接部署 香港服务器都有了，顺便整点魔法 整一个服务器监控看板 把UI面版都整上Https 如果想可以设计docker进行部署，需要注意容器编排和目录映射问题 准备好了吗！发车！ 核心：Syncthing 需要：云服务器，OSS对象存储，电脑，手机 数据安全：数据为本地存储，云端则为阿里云服务器+OSS，次方案使用的项目均为开源项目 我的配置：阿里云香港轻量服务器（debian11），9元一年OSS标准存储资源包，Win10笔记本，安卓手机 实际花费：阿里云香港轻量服务器 288&#x2F;年就够用了，我买的是408.00一年的那个 建议选择带宽较大的轻量服务器，大可以选择自己觉得便宜和稳定的，注意：服务器和oss存在地域问题！选同一个地域的，不然要nginx代理。 实操安装Syncthing服务器直接安装123456789101112131415161718192021222324252627282930cd /home# https://github.com/syncthing/syncthing/releaseswget https://github.com/syncthing/syncthing/releases/download/v1.27.10/syncthing-linux-amd64-v1.27.10.tar.gz# 解压tar -xzvf syncthing-linux-amd64-v1.27.10.tar.gz# 删除压缩包rm -f syncthing-linux-amd64-v1.27.10.tar.gz# 重命名(可选)mv /home/syncthing-linux-amd64-v1.27.10 /home/syncthing# 创建日志文件mkdir /home/logs/sudo touch /home/logs/syncthing.log# 修改`/home/username/.config/syncthing/config.xml`中的`gui`标签，把`127.0.0.1`改成`0.0.0.0`，开启远程访问# 如果你的usernam为root，那么config.xml在/root/.local/state/syncthing# 可选的！后续会开启反向代理vim /root/.local/state/syncthing/config.xml# 官方文档：https://docs.syncthing.net/users/stdiscosrv.html# 后台运行cd /home/syncthingnohup ./syncthing &gt; /home/logs/syncthing.log 2&gt;&amp;1 &amp;# 使用jobs查看运行情况jobs# 查看日志cat /home/logs/syncthing.log docker-compose 安装# 目录：/home/docker/syncthingmkdir /home/docker/syncthingcd /home/docker/syncthingvi docker-compose.yml 123456789101112131415161718services: syncthing: image: syncthing/syncthing:latest container_name: syncthing hostname: syncthing #optional restart: always mem_limit: 120m memswap_limit: -1 user: root environment: - PUID=1000 - PGID=1000 - TZ=Asia/Shanghai volumes: - ./syncthing:/var/syncthing - /home/data:/home/data # 此次配置额外添加的路径 ports: - &#x27;8384:8384&#x27; # 面版端口 PC访问：Github下载windows版本的Syncthing，直接运行即可 开机自启，后台运行： 创建bat文件写入 start &quot;Syncthing&quot; syncthing.exe -no-console -no-browser 创建快捷方式后，Win+R 输入 shell:startup，把快捷方式拖进去 Android访问：Github下载android版本的Syncthing，直接运行即可，给足权限，让他常驻后台 服务器挂载OSSoss的创建与配置资源包购买：https://oss.console.aliyun.com/packagebucket创建：https://oss.console.aliyun.com/bucket 名称随意 地域选择和自己服务器相同的地方 私有读写即可，因为我们是通过服务器出的公网流量，服务器和oss之间的访问用内网就行了，免费且高速，缺点是oss的访问速度全看服务器的带宽了。 示例：ECS地域OSS地域 挂载OSS到ECS12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 进入目录cd /home# 更新索引sudo apt-get -y update # 安装ossfssudo apt-get install automake autotools-dev g++ git libcurl4-gnutls-dev \\ libfuse-dev libssl-dev libxml2-dev make pkg-config# 克隆编译代码git clone https://github.com/aliyun/ossfs.gitcd ossfs./autogen.sh./configuremakesudo make install# 配置全局密钥，输入OSS对应的key和secret，不知道怎么获取看这个：# https://blog.csdn.net/weixin_45606067/article/details/114292972# my-access-key-id 你的key # my-access-key-secret 你的secret# my-bucket是你的存储空间名称echo my-bucket:my-access-key-id:my-access-key-secret &gt; /etc/passwd-ossfs# 也可以进行编辑vim /etc/passwd-ossfschmod 600 /etc/passwd-ossfs# 挂载oss目录# /path/to/mountpoint是你挂载到的服务器上的目录# my-oss-endpoint是你oss的访问域，一定要选内网的！ossfs my-bucket /path/to/mountpoint -ourl=my-oss-endpoint# 示例mkdir /home/data/blogossfs my-notes-blog /home/data/blog -ourl=oss-cn-hongkong-internal.aliyuncs.com# 查看挂载情况（可选）df | grep ossfs# 详细情况（可选）# /root/Data/OSS 是挂载的路径df -hT /root/Data/OSS# 删除挂载点（可选）sudo umount /root/Data/OSS 123456789101112131415161718192021222324252627282930313233# 项目地址https://github.com/aliyun/ossfs/releases# 安装命令，需要和上面项目地址查询出版本对应mkdir /home/ossfssudo wget -P /home/ossfs https://gosspublic.alicdn.com/ossfs/ossfs_1.91.3_ubuntu16.04_amd64.debsudo apt-get updatesudo apt-get install gdebi-coresudo gdebi ossfs_1.91.3_ubuntu16.04_amd64.deb### 1.将账号信息保存到账号信息配置文件/etc/passwd-ossfs下，并设置文件权限为640echo bucket-test-1:AAAI************:AAA8x************************* &gt; /etc/passwd-ossfsecho bucket-test-2:BBBI************:BBB8x************************* &gt;&gt; /etc/passwd-ossfschmod 640 /etc/passwd-ossfs### 2.创建挂载目录，将杭州地域名称为bucket-test-1、bucket-test-2的bucket分别挂载到/tmp/ossfs-1、/tmp/ossfs-2目录下mkdir /tmp/ossfs-1mkdir /tmp/ossfs-2ossfs bucket-test-1 /tmp/ossfs-1 -ourl=http://oss-cn-hangzhou.aliyuncs.comossfs bucket-test-2 /tmp/ossfs-2 -ourl=http://oss-cn-hangzhou.aliyuncs.com## 将账号信息保存到账号信息配置文件/etc/passwd-ossfs-3下，并设置文件权限为600echo bucket-test-3:CCCIbZcdVCmQ****:CCC8x0y9hxQ31coh7A5e2MZEUz**** &gt; /etc/passwd-ossfs-3chmod 600 /etc/passwd-ossfs-3\t##创建挂载目录，将杭州地域名称为bucket-test-3的bucket挂载到/tmp/ossfs-3目录下 mkdir /tmp/ossfs-3ossfs bucket-test-3 /tmp/ossfs-3 -ourl=http://oss-cn-hangzhou.aliyuncs.com -opasswd_file=/etc/passwd-ossfs-3## 将账号信息保存到账号信息配置文件/etc/passwd-ossfs-4下，并设置文件权限为600echo bucket-test-4:DDDIbZcdVCmQ****:DDD8x0y9hxQ31coh7A5e2MZEUz**** &gt; /etc/passwd-ossfs-4chmod 600 /etc/passwd-ossfs-4##创建挂载目录，将杭州地域名称为bucket-test-4的bucket挂载到/tmp/ossfs-4目录下mkdir /tmp/ossfs-4ossfs bucket-test-4 /tmp/ossfs-4 -ourl=http://oss-cn-hangzhou.aliyuncs.com -opasswd_file=/etc/passwd-ossfs-4 注意我这里挂载了两个目录，syncthing使用的oss和我后续博客上推使用的oss是两个不同的存储空间，但是都是和服务器在同一个地域 配置Syncthing搭建发现服务器先通过发现服务器 (Discosrv)发现和索引用户，当用户设备接入发现服务器后，服务器会进行设备的连接通告，当设备之间同意连接后进行连接；两台设备建立连接后，数据需要通过 NAT 穿透的方式实现交换。 1234567891011121314151617181920212223cd /home/syncthing# 仓库在：https://github.com/syncthing/discosrv/releases，想用新的直接换新链接就行wget https://github.com/syncthing/discosrv/releases/download/v1.23.4/stdiscosrv-linux-amd64-v1.23.4.tar.gz# 解压tar -xzvf stdiscosrv-linux-amd64-v1.23.4.tar.gz# 删除压缩包rm -f stdiscosrv-linux-amd64-v1.23.4.tar.gz# 重命名(可选)mv stdiscosrv-linux-amd64-v1.23.4 stdiscosrv# 创建日志文件sudo touch /home/logs/stdiscosrv.log# 官方文档：https://docs.syncthing.net/users/stdiscosrv.html# 后台运行cd stdiscosrvnohup ./stdiscosrv &gt; /home/logs/stdiscosrv.log 2&gt;&amp;1 &amp;# 使用jobs查看运行情况jobs# 查看日志cat /home/logs/stdiscosrv.log 搭建中继节点如果 NAT 穿透不成功，就需要中继 (Relaysrv)服务器传输数据，假如电脑要和手机进行笔记同步，通信过程就是：电脑-中继-手机，当然Syncthing自带有公共网络服务，但是此文章使用云服务器就是为了搭建一个中继的通信过程 1234567891011121314151617181920212223242526cd /home/syncthing# 仓库在：https://github.com/syncthing/discosrv/releases，想用新的直接换新链接就行wget https://github.com/syncthing/relaysrv/releases/download/v1.22.1/strelaysrv-linux-amd64-v1.22.1.tar.gz# 解压tar -xzvf strelaysrv-linux-amd64-v1.22.1.tar.gz# 删除压缩包rm -f strelaysrv-linux-amd64-v1.22.1.tar.gz# 重命名(可选)mv strelaysrv-linux-amd64-v1.22.1 strelaysrv# 创建日志文件sudo touch /home/logs/strelaysrv.log# 运行 # https://docs.syncthing.net/users/strelaysrv.html# pools为空是不加入公共中继节点，部署为私有cd strelaysrvnohup ./strelaysrv -pools=&quot;&quot; &gt; /home/logs/strelaysrv.log 2&gt;&amp;1 &amp;# 使用jobs查看运行情况jobs# 查看日志cat /home/logs/strelaysrv.log 可以先配置反向代理和泛域名证书，详细见nginx章节，配置文件如下： 123456789101112# syncthingserver &#123; listen 443 ssl; server_name sync.exp.com; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8384/; &#125;&#125; 再回来配置syncthing，记得给电脑、服务器、手机都配置一下，协议监听地址对应中继节点地址，全局发现服务器和全局发现的地址。还有记得开放端口：22067&#x2F;tcp 和 8443&#x2F;tcp 123456789101112# 查看日志cat /home/logs/strelaysrv.logcat /home/logs/stdiscosrv.log# 协议监听地址，中继服务URI relay://公网IP:22067?id=中继服务器device ID relay://0.0.0.0:22067/?id=DGSNZJM-MASJL6U-WJJA2RJ-GDTAALI-JZOF6NS-KPPDNQU-T4TV7OQ-YK6ATAM&amp;networkTimeout=2m0s&amp;pingInterval=1m0s&amp;statusAddr=%3A22070# 全局发现服务器 https://公网IP:8443/?id=发现服务器device ID 记得每个安装了sync的设备都要设置！ 配置说明举个例子：文件夹路径是本地计算机的路径，比如我们现在需要电脑同步到服务器，那么过程就是 打开电脑上的 syncthing http://127.0.0.1:8384/，添加文件夹，路径选择自己电脑本地的要上传的文件路径，如：D:\\My\\Notes，在共享里选择服务器上的 syncthing 打开服务器上的 syncthing ，你会看到发过来的共享请求，那么在接受后的配置里面，选择你需要保存在服务器上的地址，比如挂载后的OSS地址或者服务器的其他地方 现在如果你需要再同步给手机，那么就选择服务器上电脑发过来的共享文件夹，同样的点击共享就可以分享到手机","tags":[null,null,null,null,null,null],"categories":[null]},{"title":"充分利用云服务器！如何围绕云服务器搭建自己的工作流","path":"/workflow/workflow.html","content":"需求 实现笔记和其他文件的同步与备份 实现笔记和博客的融合，可以很方便的进行编辑、修改、发布 实现博客和个人简历的融合 科学上网 密码管理 思路围绕云服务器进行多端同步的思路展开与工作流构建。包含大致功能如下： 同步与备份：通过搭建Syncthing的中继服务器和发现服务器，把手机、电脑、pad、服务器联系起来，其中云服务器不但可以中转、存储还能通过内网访问挂载到服务器的oss，以增加存储空间实现备份效果 预览与下载：通过Alist挂载服务器目录，配合重定向实现在浏览器上预览的图床功能，当然下载功能也不在话下。 笔记：通过Obsidian写笔记，因为笔记数据按照文件夹的形式进行本地存储，所以可以通过相对链接渲染图片、视频等，如果要放其他格式文档，比如pdf、xmind文档等，则可以从alist上获取下载链接。 博客：使用hexo静态博客，主题为Stellar。本地编译，通过同步可以把实现在Obsidian的笔记目录下写完文章自动同步到博客的目录下，再配合脚本与插件实现一件编写、发布、修改、推送一条路服务，真正把博客和笔记相互交融！ 密码管理：使用Bitwardn 自建后台服务，把密码放在自己的服务上。 科学上网：使用3-xui搭建节点，配合v2rayN实现科学上网。其中整理了部分节点种类，实现链式代理。 服务器安全与运维：因为我搭建没有采用docker进行搭建，搭建完些占用也才30%左右，而docker虽然更好管理但是占用更高。其中安全需要尽量被攻击，一般就是ddos攻击，然后对运行的服务进行监控、日志的处理、数据的备份、服务器碎片文件的处理等（待更新） SEO：搜索优化，博客都搭起来了怎么能不让别人看到，除了在csdn、掘金等其他博文聚集地发送博客引流，也需要让搜索引擎收录并放在前面。（待更新） 准备 服务器：我的是阿里云香港轻量服务器2H2G，34&#x2F;月。 oss：阿里云标准存储数据包，9&#x2F;年 知道怎么获得阿里云子用户的ccessKey ID 和 AccessKey Secret，以及对其进行授权 vscode或者webstorm，以及本地node环境，在hexo编译的时候可以用 遇到问题可以在博客评论，也可以直接发邮件问，建议先搜一下 常见问题使用密码无法远程链接登录服务器原因可能是服务器PasswordAuthentication参数为no 解决123456# 查看`/etc/ssh/sshd_config`的参数`PasswordAuthentication`配置是否有误。cat /etc/ssh/sshd_config# 将`PasswordAuthentication no`修改为`PasswordAuthentication yes`。sudo vim /etc/ssh/sshd_config# 重启SSHD服务使配置生效。sudo systemctl restart sshd.service 同步到oss目录失败，无法访问、未找到目录原因可能是用户权限不够，可以看看访问oss的应用，比如nginx，运行时的角色是什么，一般root角色才能访问访问挂载的oss目录 解决123456# 使用root用户启动应用，可以使用下面命令查看# 很详细sudo apt install htop# 看自己无法访问oss的服务是不是root用户htop nginx 出现 502错误一般是服务器网络问题，请求走不通。 先使用：curl http://127.0.0.1:端口查看服务是否运行 在确认自己的服务是docker部署还是直接安装，如果docker部署是需要使用 ip addr 命令查看docker0的ip地址，不能用127.0.0.1","tags":[null,null,null,null,null,null,null,null,null,null],"categories":[null]}]
[{"title":"云上温室接口","path":"/zqt-gh.html","content":"基础请求登录云上温室系统（弃用） 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;login 请求参数：无 响应： 1234567891011121314151617&#123; &quot;requestId&quot;: &quot;b15220b8-d13d-44bf-a2e0-4a1a1e81f75b&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;customerId&quot;: 1722487870, &quot;username&quot;: &quot;ybgxqnyyq&quot;, &quot;userId&quot;: 1252, &quot;authorities&quot;: [], &quot;token&quot;: &quot;eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIxMjUyIiwiY3VzdG9tZXJJZCI6IjE3MjI0ODc4NzAiLCJ1c2VybmFtZSI6InliZ3hxbnl5cSIsInJvbGVzIjoiUFJPSkVDVF9BRE1JTiIsImF1dGhvcml0aWVzIjoiIiwiZXhwIjoxNzI0NzQyNjUxfQ.wklW7Ui8f0xzhFLh_f71YmsZ2avUZovL6djfZTIUHzLAvlg6ttYylbQRTb0M47NTkVKaFXgUJ-fH2c4rqRP-Uw&quot;, &quot;tokenType&quot;: &quot;Bearer&quot;, &quot;roles&quot;: &quot;PROJECT_ADMIN&quot;, &quot;expert&quot;: &quot;&quot; &#125;, &quot;timestamp&quot;: 1724137850984, &quot;success&quot;: true, &quot;errorDetail&quot;: &quot;null&quot;&#125; 登录云上温室系统(需要账号)（弃用） 请求类型：POST 请求地址：&#x2F;cloudGreenhouses&#x2F;userLogin 请求参数： &#123;\t&quot;username&quot;:&quot;&quot;,\t&quot;password&quot;:&quot;&quot;&#125; 响应： 1234567891011121314151617&#123; &quot;requestId&quot;: &quot;b15220b8-d13d-44bf-a2e0-4a1a1e81f75b&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;customerId&quot;: 1722487870, &quot;username&quot;: &quot;ybgxqnyyq&quot;, &quot;userId&quot;: 1252, &quot;authorities&quot;: [], &quot;token&quot;: &quot;eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIxMjUyIiwiY3VzdG9tZXJJZCI6IjE3MjI0ODc4NzAiLCJ1c2VybmFtZSI6InliZ3hxbnl5cSIsInJvbGVzIjoiUFJPSkVDVF9BRE1JTiIsImF1dGhvcml0aWVzIjoiIiwiZXhwIjoxNzI0NzQyNjUxfQ.wklW7Ui8f0xzhFLh_f71YmsZ2avUZovL6djfZTIUHzLAvlg6ttYylbQRTb0M47NTkVKaFXgUJ-fH2c4rqRP-Uw&quot;, &quot;tokenType&quot;: &quot;Bearer&quot;, &quot;roles&quot;: &quot;PROJECT_ADMIN&quot;, &quot;expert&quot;: &quot;&quot; &#125;, &quot;timestamp&quot;: 1724137850984, &quot;success&quot;: true, &quot;errorDetail&quot;: &quot;null&quot;&#125; 查询所有大棚信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;station 请求参数：无 响应： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&#123; &quot;requestId&quot;: &quot;e5d3a5f8-152b-429b-9111-bffd88801b7f&quot;, &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;id&quot;: 8865, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;customerId&quot;: 1722487870, &quot;name&quot;: &quot;测试基地&quot;, &quot;parentId&quot;: 0, &quot;images&quot;: [], &quot;description&quot;: &quot;&quot;, &quot;deviceCount&quot;: 0, &quot;displayName&quot;: &quot;&quot;, &quot;sortOrder&quot;: 0, &quot;children&quot;: [ &#123; &quot;id&quot;: 8866, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-01 18:26:08&quot;, &quot;customerId&quot;: 1722487870, &quot;name&quot;: &quot;温室#1&quot;, &quot;parentId&quot;: 8865, &quot;images&quot;: [], &quot;description&quot;: &quot;温室#1 描述信息&quot;, &quot;deviceCount&quot;: 1, &quot;displayName&quot;: &quot;&quot;, &quot;sortOrder&quot;: 1, &quot;children&quot;: [], &quot;area&quot;: &quot;&quot;, &quot;kind&quot;: &quot;&quot;, &quot;growthCycle&quot;: &quot;&quot;, &quot;statistic&quot;: &quot;&quot;, &quot;suffixTitle&quot;: &quot;&quot;, &quot;x&quot;: &quot;&quot;, &quot;y&quot;: &quot;&quot;, &quot;plantQuantity&quot;: &quot;&quot;, &quot;cycleInterval&quot;: 3, &quot;regionPic&quot;: &quot;&quot;, &quot;projectTitle&quot;: &quot;&quot;, &quot;projectDescription&quot;: &quot;&quot;, &quot;showLogo&quot;: 1, &quot;logo&quot;: &quot;&quot;, &quot;fontColor&quot;: &quot;&quot;, &quot;bold&quot;: 0, &quot;italic&quot;: 0, &quot;shadow&quot;: 0, &quot;shadowColor&quot;: &quot;&quot;, &quot;devices&quot;: &quot;[&#123;\\&quot;id\\&quot;:54811,\\&quot;deviceTypeId\\&quot;:54811,\\&quot;name\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;sortOrder\\&quot;:1&#125;,&#123;\\&quot;id\\&quot;:54814,\\&quot;deviceTypeId\\&quot;:54814,\\&quot;name\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:5&#125;,&#123;\\&quot;id\\&quot;:54816,\\&quot;deviceTypeId\\&quot;:54816,\\&quot;name\\&quot;:\\&quot;东侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#补光灯升降\\&quot;,\\&quot;sortOrder\\&quot;:7&#125;,&#123;\\&quot;id\\&quot;:54817,\\&quot;deviceTypeId\\&quot;:54817,\\&quot;name\\&quot;:\\&quot;南侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;2#补光灯升降\\&quot;,\\&quot;sortOrder\\&quot;:8&#125;,&#123;\\&quot;id\\&quot;:54818,\\&quot;deviceTypeId\\&quot;:54818,\\&quot;name\\&quot;:\\&quot;西侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;3#补光灯升降\\&quot;,\\&quot;sortOrder\\&quot;:9&#125;,&#123;\\&quot;id\\&quot;:54820,\\&quot;deviceTypeId\\&quot;:54820,\\&quot;name\\&quot;:\\&quot;北侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;4#补光灯升降\\&quot;,\\&quot;sortOrder\\&quot;:10&#125;,&#123;\\&quot;id\\&quot;:54819,\\&quot;deviceTypeId\\&quot;:54819,\\&quot;name\\&quot;:\\&quot;内遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;内遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:11&#125;,&#123;\\&quot;id\\&quot;:54824,\\&quot;deviceTypeId\\&quot;:54824,\\&quot;name\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;sortOrder\\&quot;:16&#125;,&#123;\\&quot;id\\&quot;:54826,\\&quot;deviceTypeId\\&quot;:54826,\\&quot;name\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;alias\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;sortOrder\\&quot;:18&#125;,&#123;\\&quot;id\\&quot;:54828,\\&quot;deviceTypeId\\&quot;:54828,\\&quot;name\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;alias\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;sortOrder\\&quot;:20&#125;,&#123;\\&quot;id\\&quot;:54829,\\&quot;deviceTypeId\\&quot;:54829,\\&quot;name\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;alias\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;sortOrder\\&quot;:21&#125;,&#123;\\&quot;id\\&quot;:54835,\\&quot;deviceTypeId\\&quot;:54835,\\&quot;name\\&quot;:\\&quot;热风机\\&quot;,\\&quot;alias\\&quot;:\\&quot;热风机\\&quot;,\\&quot;sortOrder\\&quot;:27&#125;,&#123;\\&quot;id\\&quot;:54841,\\&quot;deviceTypeId\\&quot;:54841,\\&quot;name\\&quot;:\\&quot;1#灌溉计划\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#灌溉计划\\&quot;,\\&quot;sortOrder\\&quot;:34&#125;]&quot;, &quot;setValue&quot;: &quot;96237,96243,96236,96247,96248,96246,96250,96249,96253,96255,96265,96282,96259,96257,96267&quot;, &quot;stationType&quot;: &quot;1&quot;, &quot;leadTitle&quot;: &quot;&quot;, &quot;showLead&quot;: 1, &quot;leadTitle1&quot;: &quot;&quot; &#125;, ... &#123; &quot;id&quot;: 8868, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-12 18:22:45&quot;, &quot;customerId&quot;: 1722487870, &quot;name&quot;: &quot;温室#3&quot;, &quot;parentId&quot;: 8865, &quot;images&quot;: [], &quot;description&quot;: &quot;温室#3 描述信息&quot;, &quot;deviceCount&quot;: 1, &quot;displayName&quot;: &quot;&quot;, &quot;sortOrder&quot;: 3, &quot;children&quot;: [], &quot;area&quot;: &quot;&quot;, &quot;kind&quot;: &quot;&quot;, &quot;growthCycle&quot;: &quot;&quot;, &quot;statistic&quot;: &quot;&quot;, &quot;suffixTitle&quot;: &quot;&quot;, &quot;x&quot;: &quot;&quot;, &quot;y&quot;: &quot;&quot;, &quot;plantQuantity&quot;: &quot;&quot;, &quot;cycleInterval&quot;: 3, &quot;regionPic&quot;: &quot;&quot;, &quot;projectTitle&quot;: &quot;&quot;, &quot;projectDescription&quot;: &quot;&quot;, &quot;showLogo&quot;: 1, &quot;logo&quot;: &quot;&quot;, &quot;fontColor&quot;: &quot;&quot;, &quot;bold&quot;: 0, &quot;italic&quot;: 0, &quot;shadow&quot;: 0, &quot;shadowColor&quot;: &quot;&quot;, &quot;devices&quot;: &quot;[&#123;\\&quot;id\\&quot;:54935,\\&quot;deviceTypeId\\&quot;:54935,\\&quot;name\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;sortOrder\\&quot;:1&#125;,&#123;\\&quot;id\\&quot;:54939,\\&quot;deviceTypeId\\&quot;:54939,\\&quot;name\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:5&#125;,&#123;\\&quot;id\\&quot;:54940,\\&quot;deviceTypeId\\&quot;:54940,\\&quot;name\\&quot;:\\&quot;东侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;C区内遮阳\\&quot;,\\&quot;sortOrder\\&quot;:7&#125;,&#123;\\&quot;id\\&quot;:54941,\\&quot;deviceTypeId\\&quot;:54941,\\&quot;name\\&quot;:\\&quot;南侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;E区内遮阳\\&quot;,\\&quot;sortOrder\\&quot;:8&#125;,&#123;\\&quot;id\\&quot;:54944,\\&quot;deviceTypeId\\&quot;:54944,\\&quot;name\\&quot;:\\&quot;内遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;D区内遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:11&#125;,&#123;\\&quot;id\\&quot;:54948,\\&quot;deviceTypeId\\&quot;:54948,\\&quot;name\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;sortOrder\\&quot;:16&#125;,&#123;\\&quot;id\\&quot;:54950,\\&quot;deviceTypeId\\&quot;:54950,\\&quot;name\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;alias\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;sortOrder\\&quot;:18&#125;,&#123;\\&quot;id\\&quot;:54952,\\&quot;deviceTypeId\\&quot;:54952,\\&quot;name\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;alias\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;sortOrder\\&quot;:20&#125;,&#123;\\&quot;id\\&quot;:54953,\\&quot;deviceTypeId\\&quot;:54953,\\&quot;name\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;alias\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;sortOrder\\&quot;:21&#125;,&#123;\\&quot;id\\&quot;:54955,\\&quot;deviceTypeId\\&quot;:54955,\\&quot;name\\&quot;:\\&quot;高压雾降温\\&quot;,\\&quot;alias\\&quot;:\\&quot;高压雾降温\\&quot;,\\&quot;sortOrder\\&quot;:23&#125;,&#123;\\&quot;id\\&quot;:54959,\\&quot;deviceTypeId\\&quot;:54959,\\&quot;name\\&quot;:\\&quot;热风机\\&quot;,\\&quot;alias\\&quot;:\\&quot;热风机\\&quot;,\\&quot;sortOrder\\&quot;:27&#125;,&#123;\\&quot;id\\&quot;:54964,\\&quot;deviceTypeId\\&quot;:54964,\\&quot;name\\&quot;:\\&quot;1#空调\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#空调\\&quot;,\\&quot;sortOrder\\&quot;:32&#125;]&quot;, &quot;setValue&quot;: &quot;96342,96344,96359,96347,96364,96357,96362,96370,96391,96352,96354,96371&quot;, &quot;stationType&quot;: &quot;1&quot;, &quot;leadTitle&quot;: &quot;&quot;, &quot;showLead&quot;: 1, &quot;leadTitle1&quot;: &quot;&quot; &#125; ], &quot;area&quot;: &quot;&quot;, &quot;kind&quot;: &quot;&quot;, &quot;growthCycle&quot;: &quot;&quot;, &quot;statistic&quot;: &quot;&quot;, &quot;suffixTitle&quot;: &quot;&quot;, &quot;x&quot;: &quot;&quot;, &quot;y&quot;: &quot;&quot;, &quot;plantQuantity&quot;: &quot;&quot;, &quot;cycleInterval&quot;: 3, &quot;regionPic&quot;: &quot;&quot;, &quot;projectTitle&quot;: &quot;&quot;, &quot;projectDescription&quot;: &quot;&quot;, &quot;showLogo&quot;: 1, &quot;logo&quot;: &quot;&quot;, &quot;fontColor&quot;: &quot;&quot;, &quot;bold&quot;: 0, &quot;italic&quot;: 0, &quot;shadow&quot;: 0, &quot;shadowColor&quot;: &quot;&quot;, &quot;devices&quot;: &quot;&quot;, &quot;setValue&quot;: &quot;&quot;, &quot;stationType&quot;: &quot;&quot;, &quot;leadTitle&quot;: &quot;&quot;, &quot;showLead&quot;: 1, &quot;leadTitle1&quot;: &quot;&quot; &#125; ], &quot;timestamp&quot;: 1724138025034, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 通过站点id查询大棚信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getStationById?id&#x3D;8868 请求参数：String id 响应： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;requestId&quot;: &quot;8c46356e-de11-4960-92b9-c2a41288e1b5&quot;, &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;id&quot;: 8868, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-12 18:22:45&quot;, &quot;customerId&quot;: 1722487870, &quot;name&quot;: &quot;温室#3&quot;, &quot;parentId&quot;: 8865, &quot;images&quot;: [], &quot;description&quot;: &quot;温室#3 描述信息&quot;, &quot;deviceCount&quot;: 1, &quot;displayName&quot;: &quot;&quot;, &quot;sortOrder&quot;: 3, &quot;children&quot;: [], &quot;area&quot;: &quot;&quot;, &quot;kind&quot;: &quot;&quot;, &quot;growthCycle&quot;: &quot;&quot;, &quot;statistic&quot;: &quot;&quot;, &quot;suffixTitle&quot;: &quot;&quot;, &quot;x&quot;: &quot;&quot;, &quot;y&quot;: &quot;&quot;, &quot;plantQuantity&quot;: &quot;&quot;, &quot;cycleInterval&quot;: 3, &quot;regionPic&quot;: &quot;&quot;, &quot;projectTitle&quot;: &quot;&quot;, &quot;projectDescription&quot;: &quot;&quot;, &quot;showLogo&quot;: 1, &quot;logo&quot;: &quot;&quot;, &quot;fontColor&quot;: &quot;&quot;, &quot;bold&quot;: 0, &quot;italic&quot;: 0, &quot;shadow&quot;: 0, &quot;shadowColor&quot;: &quot;&quot;, &quot;devices&quot;: &quot;[&#123;\\&quot;id\\&quot;:54935,\\&quot;deviceTypeId\\&quot;:54935,\\&quot;name\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;左向天窗\\&quot;,\\&quot;sortOrder\\&quot;:1&#125;,&#123;\\&quot;id\\&quot;:54939,\\&quot;deviceTypeId\\&quot;:54939,\\&quot;name\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#外遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:5&#125;,&#123;\\&quot;id\\&quot;:54940,\\&quot;deviceTypeId\\&quot;:54940,\\&quot;name\\&quot;:\\&quot;东侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;C区内遮阳\\&quot;,\\&quot;sortOrder\\&quot;:7&#125;,&#123;\\&quot;id\\&quot;:54941,\\&quot;deviceTypeId\\&quot;:54941,\\&quot;name\\&quot;:\\&quot;南侧遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;E区内遮阳\\&quot;,\\&quot;sortOrder\\&quot;:8&#125;,&#123;\\&quot;id\\&quot;:54944,\\&quot;deviceTypeId\\&quot;:54944,\\&quot;name\\&quot;:\\&quot;内遮阳幕\\&quot;,\\&quot;alias\\&quot;:\\&quot;D区内遮阳幕\\&quot;,\\&quot;sortOrder\\&quot;:11&#125;,&#123;\\&quot;id\\&quot;:54948,\\&quot;deviceTypeId\\&quot;:54948,\\&quot;name\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;alias\\&quot;:\\&quot;湿帘外翻窗\\&quot;,\\&quot;sortOrder\\&quot;:16&#125;,&#123;\\&quot;id\\&quot;:54950,\\&quot;deviceTypeId\\&quot;:54950,\\&quot;name\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;alias\\&quot;:\\&quot;风机湿帘\\&quot;,\\&quot;sortOrder\\&quot;:18&#125;,&#123;\\&quot;id\\&quot;:54952,\\&quot;deviceTypeId\\&quot;:54952,\\&quot;name\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;alias\\&quot;:\\&quot;环流风扇\\&quot;,\\&quot;sortOrder\\&quot;:20&#125;,&#123;\\&quot;id\\&quot;:54953,\\&quot;deviceTypeId\\&quot;:54953,\\&quot;name\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;alias\\&quot;:\\&quot;补光灯\\&quot;,\\&quot;sortOrder\\&quot;:21&#125;,&#123;\\&quot;id\\&quot;:54955,\\&quot;deviceTypeId\\&quot;:54955,\\&quot;name\\&quot;:\\&quot;高压雾降温\\&quot;,\\&quot;alias\\&quot;:\\&quot;高压雾降温\\&quot;,\\&quot;sortOrder\\&quot;:23&#125;,&#123;\\&quot;id\\&quot;:54959,\\&quot;deviceTypeId\\&quot;:54959,\\&quot;name\\&quot;:\\&quot;热风机\\&quot;,\\&quot;alias\\&quot;:\\&quot;热风机\\&quot;,\\&quot;sortOrder\\&quot;:27&#125;,&#123;\\&quot;id\\&quot;:54964,\\&quot;deviceTypeId\\&quot;:54964,\\&quot;name\\&quot;:\\&quot;1#空调\\&quot;,\\&quot;alias\\&quot;:\\&quot;1#空调\\&quot;,\\&quot;sortOrder\\&quot;:32&#125;]&quot;, &quot;setValue&quot;: &quot;96342,96344,96359,96347,96364,96357,96362,96370,96391,96352,96354,96371&quot;, &quot;stationType&quot;: &quot;1&quot;, &quot;leadTitle&quot;: &quot;&quot;, &quot;showLead&quot;: 1, &quot;leadTitle1&quot;: &quot;&quot; &#125; ], &quot;timestamp&quot;: 1724138067686, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 通过站点id设备类型和查询设备信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getDeviceByStationIdAndDataType?stationId&#x3D;8870&amp;dataType&#x3D;STREAM 请求参数： String stationId String dataType：是设备类型而且是字典值，其中STREAM表示摄像机，CTL或者TEXT表示控制器 响应： 1234567891011121314151617181920212223242526&#123; &quot;requestId&quot;: &quot;cda4a403-6bc2-4981-ad75-77a50ce30946&quot;, &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;id&quot;: 15332, &quot;customerId&quot;: 1722487870, &quot;sortOrder&quot;: 3, &quot;code&quot;: &quot;2024010215280076&quot;, &quot;name&quot;: &quot;控制器#3&quot;, &quot;deviceTypeId&quot;: &quot;C001&quot;, &quot;deviceTypeName&quot;: &quot;日光温室控制器&quot;, &quot;stationId&quot;: 8868, &quot;stationName&quot;: &quot;温室#3&quot;, &quot;deviceBrand&quot;: &quot;&quot;, &quot;hls&quot;: &quot;&quot;, &quot;tag&quot;: &quot;0010202407270005&quot;, &quot;number&quot;: 0, &quot;channel&quot;: 1, &quot;prefix&quot;: &quot;&quot; &#125; ], &quot;timestamp&quot;: 1724225228081, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 仅通过站点id查询设备信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getDeviceByStationIdAndDataType?stationId&#x3D;8870 请求参数： String stationId 响应： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;requestId&quot;: &quot;51bfdfa3-af3b-4d46-a033-fc167e877349&quot;, &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;id&quot;: 15335, &quot;customerId&quot;: 1722487870, &quot;sortOrder&quot;: 5, &quot;code&quot;: &quot;camera-ybgxqnyyq-5&quot;, &quot;name&quot;: &quot;摄像机#5&quot;, &quot;deviceTypeId&quot;: &quot;V001&quot;, &quot;deviceTypeName&quot;: &quot;网络摄像机(海康)&quot;, &quot;stationId&quot;: 8870, &quot;stationName&quot;: &quot;温室#5&quot;, &quot;deviceBrand&quot;: &quot;&quot;, &quot;hls&quot;: &quot;&quot;, &quot;tag&quot;: &quot;&quot;, &quot;number&quot;: 0, &quot;channel&quot;: 1, &quot;prefix&quot;: &quot;&quot; &#125;, &#123; &quot;id&quot;: 15336, &quot;customerId&quot;: 1722487870, &quot;sortOrder&quot;: 5, &quot;code&quot;: &quot;0010202407270005&quot;, &quot;name&quot;: &quot;气象站&quot;, &quot;deviceTypeId&quot;: &quot;W001&quot;, &quot;deviceTypeName&quot;: &quot;数据采集器&quot;, &quot;stationId&quot;: 8870, &quot;stationName&quot;: &quot;气象站&quot;, &quot;deviceBrand&quot;: &quot;&quot;, &quot;hls&quot;: &quot;&quot;, &quot;tag&quot;: &quot;2024010215280090,2024010215280091&quot;, &quot;number&quot;: 0, &quot;channel&quot;: 1, &quot;prefix&quot;: &quot;&quot; &#125; ], &quot;timestamp&quot;: 1724225835463, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 监控相关请求根据站点id和设备id监控视频列表 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getVideoList?stationId&#x3D;8868&amp;deviceId&#x3D;15331 请求参数： String stationId String deviceId：在查询的设备信息中可以找到，主要包含该设备记录的监控视频列表 响应： 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;requestId&quot;: &quot;de7642e2-2b98-4980-9e3d-a3645ee33b82&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;data&quot;: [ [ &#123; &quot;id&quot;: 6930, &quot;customerId&quot;: 1722487870, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-01 19:00:25&quot;, &quot;deviceId&quot;: 15331, &quot;deviceCode&quot;: &quot;9L0D98FPHA16795&quot;, &quot;deviceName&quot;: &quot;摄像机#3&quot;, &quot;deviceTypeId&quot;: &quot;V006&quot;, &quot;deviceTypeName&quot;: &quot;网络摄像机(海康)&quot;, &quot;stationId&quot;: 8868, &quot;stationName&quot;: &quot;温室#3&quot;, &quot;sortOrder&quot;: 1, &quot;name&quot;: &quot;&quot;, &quot;channel&quot;: 0, &quot;rtmpUrl&quot;: &quot;&quot;, &quot;hlsUrl&quot;: &quot;http://cmgw-vpc.lechange.com:8888/LCO/9L0D98FPHA16795/0/1/20240801T071757/72b4abc424b4cfa599170b8ffa88c01d.m3u8&quot;, &quot;hasPtz&quot;: true, &quot;poster&quot;: &quot;http://iot-pictures.oss-cn-beijing.aliyuncs.com/202408/9L0D98FPHA16795/e8f5c840b0f9cafcfcc818d3cb1afdc0.jpg?Expires=1724207025&amp;OSSAccessKeyId=LTAI4G6tKEtDrgfKK3hrvFoe&amp;Signature=79wm5zvDTYTAbEe7Pxj912tt4nU%3D&quot;, &quot;description&quot;: &quot;&quot;, &quot;primary&quot;: true, &quot;online&quot;: true &#125; ] ], &quot;pageNumber&quot;: 1, &quot;pageSize&quot;: 20, &quot;totalCount&quot;: 1 &#125;, &quot;timestamp&quot;: 1724138667432, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 仅通过站点id查监控视频列表 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getMonitorByStationId?stationId&#x3D;8865 请求参数： String stationId 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;requestId&quot;: &quot;47318cee-b940-4f75-8c4e-d28a1e9a0115&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;data&quot;: [ [ &#123; &quot;id&quot;: 6930, &quot;customerId&quot;: 1722487870, &quot;createDate&quot;: &quot;2024-08-01 12:51:11&quot;, &quot;modifiedDate&quot;: &quot;2024-08-01 19:00:25&quot;, &quot;deviceId&quot;: 15331, &quot;deviceCode&quot;: &quot;9L0D98FPHA16795&quot;, &quot;deviceName&quot;: &quot;摄像机#3&quot;, &quot;deviceTypeId&quot;: &quot;V006&quot;, &quot;deviceTypeName&quot;: &quot;网络摄像机(海康)&quot;, &quot;stationId&quot;: 8868, &quot;stationName&quot;: &quot;温室#3&quot;, &quot;sortOrder&quot;: 1, &quot;name&quot;: &quot;&quot;, &quot;channel&quot;: 0, &quot;rtmpUrl&quot;: &quot;&quot;, &quot;hlsUrl&quot;: &quot;http://cmgw-vpc.lechange.com:8888/LCO/9L0D98FPHA16795/0/1/20240801T071757/72b4abc424b4cfa599170b8ffa88c01d.m3u8&quot;, &quot;hasPtz&quot;: true, &quot;poster&quot;: &quot;http://iot-pictures.oss-cn-beijing.aliyuncs.com/202408/9L0D98FPHA16795/e8f5c840b0f9cafcfcc818d3cb1afdc0.jpg?Expires=1724297190&amp;OSSAccessKeyId=LTAI4G6tKEtDrgfKK3hrvFoe&amp;Signature=q4sf09V%2BNQoj6gkHFlsUIr%2FB3rM%3D&quot;, &quot;description&quot;: &quot;&quot;, &quot;primary&quot;: true, &quot;online&quot;: true &#125; ] ], &quot;pageNumber&quot;: 1, &quot;pageSize&quot;: 20, &quot;totalCount&quot;: 1 &#125;, &quot;timestamp&quot;: 1724226228816, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 获取kit_token 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getKitToke?deviceCode&#x3D;9L0D98FPHA16795&amp;channelId&#x3D;0 请求参数： String deviceCode：在查询出的监控视频列表里有 String channelId：在查询出的监控视频列表里有 channel响应： 12345678&#123; &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;kit_token&quot;: &quot;Kt_hzb416177422044de980f9f8357b619f&quot;, &quot;token&quot;: &quot;At_0000hz288c970032294eb6b0f979e53e&quot; &#125;, &quot;message&quot;: &quot;SuccessCode&quot;&#125; 获取监控视频流地址这个请求可以不带请求头！带了也没关系 请求类型：POST 请求地址：&#x2F;cloudGreenhouses&#x2F;getEncryptKitStreamUrl 请求参数： String id ：&#x2F;&#x2F; todo 暂未发现 ParamsDTO params String kitToken；在kit_token里 String deviceId; 在查询出的监控视频列表里有 String channelId; 和kit_token的channelId对应 String beginTime; String endTime; String businessType; &#x2F;&#x2F; todo 暂未发现 请求体： 123456789101112&#123;\t&quot;id&quot;:&quot;SJLS0N8JER2EDX7HR6AJZE7A9HED0TNP&quot;,\t&quot;params&quot;:&#123; &quot;beginTime&quot;:&quot;2024-08-20 00:00:00&quot;, &quot;businessType&quot;:&quot;real&quot;, &quot;channelId&quot;:&quot;0&quot;, &quot;deviceId&quot;:&quot;9L0D98FPHA16795&quot;, &quot;endTime&quot;:&quot;2024-08-20 23:59:59&quot;, &quot;kitToken&quot;:&quot;Kt_hzb416177422044de980f9f8357b619f&quot;, &quot;streamId&quot;:&quot;0&quot;\t&#125;&#125; 响应： &#123;&quot;result&quot;:&#123;&quot;msg&quot;:&quot;设备离线。&quot;,&quot;code&quot;:&quot;DV1007&quot;&#125;,&quot;id&quot;:&quot;SJLS0N8JER2EDX7HR6AJZE7A9HED0TNP&quot;&#125; 天气数据相关请求获取气象站传感器当前数据 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getSensorData?deviceCode&#x3D;2024010215280076 请求参数：String deviceCode; 对应通过站点id查询设备信息里的tag中的数据 响应： 1234567891011121314151617181920212223242526272829303132333435&#123; &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;name&quot;: &quot;空气温度&quot;, &quot;order&quot;: 0, &quot;isBreakdown&quot;: &quot;0&quot;, &quot;isTarget&quot;: &quot;0&quot;, &quot;isValid&quot;: &quot;1&quot;, &quot;isWeatherStation&quot;: &quot;1&quot;, &quot;originValue&quot;: 773, &quot;value&quot;: 37.3, &quot;unit&quot;: &quot;℃&quot;, &quot;factor&quot;: &quot;atc&quot;, &quot;dateTime&quot;: &quot;2024-08-20 17:01:42&quot;, &quot;sensorType&quot;: &quot;1&quot; &#125;,\t... &#123; &quot;name&quot;: &quot;土壤湿度&quot;, &quot;order&quot;: 0, &quot;isBreakdown&quot;: &quot;0&quot;, &quot;isTarget&quot;: &quot;0&quot;, &quot;isValid&quot;: &quot;1&quot;, &quot;isWeatherStation&quot;: &quot;0&quot;, &quot;originValue&quot;: 0, &quot;value&quot;: 0, &quot;unit&quot;: &quot;%&quot;, &quot;factor&quot;: &quot;swc&quot;, &quot;dateTime&quot;: &quot;2024-08-20 17:01:42&quot;, &quot;sensorType&quot;: &quot;7&quot; &#125; ], &quot;message&quot;: &quot;SuccessCode&quot;&#125; 字段名 类型 描述 name String 传感器类型名称 order String 传感器类型序号 isBreakdown String 是否故障 isTarget String 是否是⽬标值 isValid String 是否有效 isWeatherStation String 是否是⽓象站 originValue String 原始值 value String 转换后数值 unit String 单位 factor String 传感器类型英⽂缩写 dateTime String 时间 获取气象站传感器时间段的数据 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getSensorDataAvg?deviceId&#x3D;15332&amp;groupType&#x3D;HOUR&amp;startTimestamp&#x3D;1724083200000&amp;endTimestamp&#x3D;1724169599000&amp;fields&#x3D;atc,ahc,light,co2,stc,swc 请求参数： String deviceId, 对应站点id查询设备信息里的id String groupType, 分组类型，HOUR&#x2F;DAY&#x2F;MONTH String startTimestamp, 开始时间戳(默认当天0点 String endTimestamp, 结束时间戳(默认当前时间戳 String fields; 数据类型(从getSensorData接⼝中获取)atc,ahc,light,co2,stc,swc 响应： 12345678910111213141516171819202122232425262728&#123; &quot;requestId&quot;: &quot;c548298e-f723-4d72-add0-0dc65dbda77b&quot;, &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;airTemperature&quot;: 28.6, &quot;soilTemperature&quot;: 28, &quot;brightness&quot;: 0, &quot;carbonDioxide&quot;: 457.5, &quot;airHumidity&quot;: 72.7, &quot;soilHumidity&quot;: 0, &quot;createDate&quot;: &quot;00&quot; &#125;,\t... &#123; &quot;airTemperature&quot;: 37.9, &quot;soilTemperature&quot;: 37.5, &quot;brightness&quot;: 1, &quot;carbonDioxide&quot;: 428.4, &quot;airHumidity&quot;: 41.9, &quot;soilHumidity&quot;: 0, &quot;createDate&quot;: &quot;17&quot; &#125; ], &quot;timestamp&quot;: 1724146892409, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 获取气象站传感器历史数据 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getSensorHistoryData?deviceId&#x3D;15332&amp;stationId&#x3D;8868&amp;startTimestamp&#x3D;1724083200000&amp;endTimestamp&#x3D;1724169599000 请求参数： String deviceId, 对应站点id查询设备信息里的id String stationId, String startTimestamp, 开始时间戳(默认当天0点 String endTimestamp, 结束时间戳(默认当前时间戳 响应： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&#123; &quot;requestId&quot;: &quot;1c29e09c-7bed-4a6d-9ecf-662ee0a05ec7&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;data&quot;: [ &#123; &quot;data&quot;: [ &#123; &quot;name&quot;: &quot;stc&quot;, &quot;value&quot;: 32.6, &quot;displayName&quot;: &quot;土壤温度&quot;, &quot;unit&quot;: &quot;℃&quot;, &quot;icon&quot;: &quot;stc&quot;, &quot;alarm&quot;: false, &quot;number&quot;: &quot;0&quot; &#125;, ... &#123; &quot;name&quot;: &quot;swc&quot;, &quot;value&quot;: 9.8, &quot;displayName&quot;: &quot;土壤湿度&quot;, &quot;unit&quot;: &quot;%&quot;, &quot;icon&quot;: &quot;swc&quot;, &quot;alarm&quot;: false, &quot;number&quot;: &quot;0&quot; &#125; ], &quot;deviceTypeId&quot;: &quot;C001&quot;, &quot;deviceTypeName&quot;: &quot;日光温室控制器&quot;, &quot;deviceCode&quot;: &quot;2024010215280091&quot;, &quot;deviceId&quot;: &quot;15330&quot;, &quot;deviceName&quot;: &quot;B&quot;, &quot;customerId&quot;: &quot;1722487870&quot;, &quot;stationName&quot;: &quot;B&quot;, &quot;stationId&quot;: &quot;8867&quot;, &quot;createDate&quot;: &quot;2024-09-02 09:25:20&quot; &#125;, ... &#123; &quot;data&quot;: [ &#123; &quot;name&quot;: &quot;stc&quot;, &quot;value&quot;: 32.4, &quot;displayName&quot;: &quot;土壤温度&quot;, &quot;unit&quot;: &quot;℃&quot;, &quot;icon&quot;: &quot;stc&quot;, &quot;alarm&quot;: false, &quot;number&quot;: &quot;0&quot; &#125;, ... &#123; &quot;name&quot;: &quot;swc&quot;, &quot;value&quot;: 9.9, &quot;displayName&quot;: &quot;土壤湿度&quot;, &quot;unit&quot;: &quot;%&quot;, &quot;icon&quot;: &quot;swc&quot;, &quot;alarm&quot;: false, &quot;number&quot;: &quot;0&quot; &#125; ], &quot;deviceTypeId&quot;: &quot;C001&quot;, &quot;deviceTypeName&quot;: &quot;日光温室控制器&quot;, &quot;deviceCode&quot;: &quot;2024010215280091&quot;, &quot;deviceId&quot;: &quot;15330&quot;, &quot;deviceName&quot;: &quot;B&quot;, &quot;customerId&quot;: &quot;1722487870&quot;, &quot;stationName&quot;: &quot;B&quot;, &quot;stationId&quot;: &quot;8867&quot;, &quot;createDate&quot;: &quot;2024-09-02 06:51:59&quot; &#125; ], &quot;pageNumber&quot;: 1, &quot;pageSize&quot;: 30, &quot;totalCount&quot;: 107 &#125;, &quot;timestamp&quot;: 1725240381499, &quot;success&quot;: true&#125; 获取气象站平均数据 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getSensorDataTimeAvg?deviceId&#x3D;15332&amp;groupType&#x3D;HOUR&amp;startTimestamp&#x3D;1724083200000&amp;endTimestamp&#x3D;1724169599000&amp;fields&#x3D;atc,ahc,light,co2,stc,swc 请求参数： String deviceId, 对应站点id查询设备信息里的id String groupType, 分组类型，HOUR&#x2F;DAY&#x2F;MONTH String startTimestamp, 开始时间戳(默认当天0点 String endTimestamp, 结束时间戳(默认当前时间戳 String fields; 数据类型(从getSensorData接⼝中获取)atc,ahc,light,co2,stc,swc 相应： 12345678910111213141516&#123; &quot;requestId&quot;: &quot;3d412250-1d07-4409-acb4-ac13262ca09b&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;airTemperature&quot;: 32.1, &quot;soilTemperature&quot;: 31.7, &quot;brightness&quot;: 1.2, &quot;carbonDioxide&quot;: 444.5, &quot;airHumidity&quot;: 61.7, &quot;soilHumidity&quot;: 0, &quot;createDate&quot;: null &#125;, &quot;timestamp&quot;: 1724812023647, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 设备信息相关请求获取设备状态信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getDeviceStatus?deviceCode&#x3D;2022070314150044 请求参数： String deviceCode, 在查询出的设备信息里有 响应： 1234567891011121314151617181920212223242526272829&#123; &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;name&quot;: &quot;左向天窗&quot;, &quot;status&quot;: &quot;00000010&quot;, &quot;order&quot;: 0, &quot;position&quot;: &quot;0&quot;, &quot;deviceTypeNumber&quot;: 1, &quot;isBit&quot;: 1, &quot;suffix&quot;: &quot;&quot;, &quot;deviceType&quot;: &quot;自动&quot;, &quot;deviceStatus&quot;: &quot;关&quot; &#125;,\t... &#123; &quot;name&quot;: &quot;输出通道&quot;, &quot;status&quot;: &quot;00000001&quot;, &quot;order&quot;: 4, &quot;position&quot;: &quot;&quot;, &quot;deviceTypeNumber&quot;: 55, &quot;isBit&quot;: 1, &quot;suffix&quot;: &quot;&quot;, &quot;deviceType&quot;: &quot;自动&quot;, &quot;deviceStatus&quot;: &quot;开&quot; &#125; ], &quot;message&quot;: &quot;SuccessCode&quot;&#125; 原理讲解： 1bit有8位：00000000 bit0 ~ bit7：表示从高位到低位，也就是从右到左 为 bit0、bit2 … bit7 设备类型：开-关-停 三个状态、 开-关 二个状态 开-关-停：bit0 &#x3D; 1: 开、bit1 &#x3D; 1: 关（在 bit0 不为 1 的情况下）、bit0 和 bit1 均不为 1: 停 开-关： bit0 &#x3D; 1: 开、bit0 &#x3D; 0: 关 自动&#x2F;手动状态：bit2 &#x3D; 0 且 bit3 &#x3D; 0: 自动、其他情况: 手动 举例子： 00000100：bit0&#x3D;、bit1&#x3D;0，无论他是开关停类型还是开关类型都是停止或者关闭的；bit3&#x3D;1说明他是手动的 00000000：状态关、自动 00000001：状态开、自动 字段名 类型 描述 status String 如果status &#x3D; 00000100，如果设备为 ‘开关停’ 设备：先从bit0开始解析，如果 bit0 &#x3D; 1即为开，bit0 如果不等于0，那就看bit1，bit1 &#x3D; 1 即为关，如果bit1 不等于 1，状态即为 ‘停’；如果设备是 ‘开关型’ 设备，那么只关注bit0，bit0&#x3D;1为开，bit0&#x3D;0 为关; ⾃动⼿动判断： bit2 &#x3D;0 bit3&#x3D;0 即为⾃动状态，其他情况为⼿动状态 positon String ‘开关停’ 型的设备当前开合的位置 Order Int 序号 数据映射： 名称 字节类型 描述 左向天窗 位 00000110 ⼿动关闭 00000101 ⼿动打开 00000100 ⼿动静⽌ 00000000 ⾃动静⽌ 00000001 ⾃动开 00000010 ⾃动关 右向天窗 位 0000110 ⼿动关闭 00000101 ⼿动打开 00000100 ⼿动静⽌ 00000000 ⾃动静⽌ 00000001 ⾃动开 00000010 ⾃动关 补光灯 位 00000101⼿动开 00000100⼿动关 00000000 关 “开关停设备” 状态列表： 状态码 (二进制) bit0 bit1 bit2 bit3 设备状态 操作模式 0000 0 0 0 0 停 自动 0001 1 0 0 0 开 自动 0010 0 1 0 0 关 自动 0011 1 1 0 0 开 自动 0100 0 0 1 0 停 手动 0101 1 0 1 0 开 手动 0110 0 1 1 0 关 手动 0111 1 1 1 0 开 手动 1000 0 0 0 1 停 手动 1001 1 0 0 1 开 手动 1010 0 1 0 1 关 手动 1011 1 1 0 1 开 手动 1100 0 0 1 1 停 手动 1101 1 0 1 1 开 手动 1110 0 1 1 1 关 手动 1111 1 1 1 1 开 手动 “开关型设备” 状态列表： 状态码 (二进制) bit0 bit1 bit2 bit3 设备状态 操作模式 0000 0 0 0 0 关 自动 0001 1 0 0 0 开 自动 0010 0 1 0 0 关 自动 0011 1 1 0 0 开 自动 0100 0 0 1 0 关 手动 0101 1 0 1 0 开 手动 0110 0 1 1 0 关 手动 0111 1 1 1 0 开 手动 1000 0 0 0 1 关 手动 1001 1 0 0 1 开 手动 1010 0 1 0 1 关 手动 1011 1 1 0 1 开 手动 1100 0 0 1 1 关 手动 1101 1 0 1 1 开 手动 1110 0 1 1 1 关 手动 1111 1 1 1 1 开 手动 获取设备映射列表信息 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getDeviceMapInfo?customerId&#x3D;1722487870&amp;deviceId&#x3D;15332&amp;deviceType&#x3D;C001 请求参数： String customerId, 在用户登陆的时候有这个值 String deviceType, &#x2F;&#x2F; todo 设备类型，我没有在他的接口文档里找到对应的映射 String deviceId, 在查询的设备信息中可以找到 响应： 12345678910111213141516171819202122232425&#123; &quot;code&quot;: 200, &quot;data&quot;: [ &#123; &quot;id&quot;: 54935, &quot;name&quot;: &quot;左向天窗&quot;, &quot;alias&quot;: &quot;左向天窗&quot;, &quot;order&quot;: 1, &quot;deviceType&quot;: &quot;C001&quot;, &quot;deviceId&quot;: 15332, &quot;customerId&quot;: 1722487870\t&#125;,\t... &#123; &quot;id&quot;: 54979, &quot;name&quot;: &quot;全自动紫外线消毒机&quot;, &quot;alias&quot;: &quot;全自动紫外线消毒机&quot;, &quot;order&quot;: 47, &quot;deviceType&quot;: &quot;C001&quot;, &quot;deviceId&quot;: 15332, &quot;customerId&quot;: 1722487870 &#125; ], &quot;message&quot;: &quot;SuccessCode&quot;&#125; 获取施肥机运行状态 请求类型：GET 请求地址：&#x2F;cloudGreenhouses&#x2F;getFertilizerStatus?deviceCode&#x3D;2024041011580004 请求参数： String deviceCode, 在查询出的设备信息里有 响应： 123456789101112131415161718192021222324252627&#123; &quot;requestId&quot;: &quot;2262ee08-671e-4033-a92b-4dd2b8831435&quot;, &quot;code&quot;: 200, &quot;data&quot;: &#123; &quot;deviceName&quot;: &quot;施肥机&quot;, &quot;deviceCode&quot;: &quot;2024041011580004&quot;, &quot;online&quot;: false, &quot;statuses&quot;: [ &#123; &quot;name&quot;: &quot;手机强制手动&quot;, &quot;status&quot;: false, &quot;type&quot;: &quot;switch&quot;, &quot;channel&quot;: 1 &#125;, ... &#123; &quot;name&quot;: &quot;北侧遮阳收拢&quot;, &quot;status&quot;: false, &quot;type&quot;: &quot;switch&quot;, &quot;channel&quot;: 48 &#125; ] &#125;, &quot;timestamp&quot;: 1724225191317, &quot;success&quot;: true, &quot;errorDetail&quot;: null&#125; 后管接口获取大棚种植信息 请求类型：GET 请求地址：smartagriculturebasic&#x2F;greenhouse&#x2F;list 请求参数（可选）： pageNum&#x3D;1 pageSize&#x3D;12 响应： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223&#123; &quot;total&quot;: 2, &quot;rows&quot;: [ &#123; &quot;id&quot;: &quot;Gre202310090005&quot;, &quot;greenhouseCode&quot;: &quot;G0002&quot;, &quot;greenhouseAlias&quot;: &quot;1号大棚&quot;, &quot;area&quot;: 5.90, &quot;temperature&quot;: 12.00, &quot;humidity&quot;: 12.00, &quot;managerName&quot;: &quot;李湘&quot;, &quot;phone&quot;: &quot;15817584870&quot;, &quot;gis&quot;: &quot;[&#123;\\&quot;lat\\&quot;:28.802028179168637,\\&quot;lng\\&quot;:104.70356490074549&#125;,&#123;\\&quot;lat\\&quot;:28.801309347152646,\\&quot;lng\\&quot;:104.70555922849772&#125;,&#123;\\&quot;lat\\&quot;:28.802285671234067,\\&quot;lng\\&quot;:104.70523755956751&#125;,&#123;\\&quot;lat\\&quot;:28.802274942398007,\\&quot;lng\\&quot;:104.70403666222802&#125;]&quot;, &quot;createTime&quot;: &quot;2023-10-09 14:04:13&quot;, &quot;devNum&quot;: 0, &quot;devicesInfo&quot;: null, &quot;plantsInfo&quot;: [], &quot;breedsInfo&quot;: null &#125;, ... &#123; &quot;id&quot;: &quot;Fie202403200005&quot;, &quot;fieldCode&quot;: &quot;T221&quot;, &quot;fieldAlias&quot;: &quot;中药种植区&quot;, &quot;area&quot;: 18.00, &quot;managerName&quot;: null, &quot;phone&quot;: null, &quot;gis&quot;: &quot;[&#123;\\&quot;lat\\&quot;:28.78277957501306,\\&quot;lng\\&quot;:104.43081021443015&#125;,&#123;\\&quot;lat\\&quot;:28.783155102014994,\\&quot;lng\\&quot;:104.43098725542525&#125;,&#123;\\&quot;lat\\&quot;:28.782060742997068,\\&quot;lng\\&quot;:104.43171142682382&#125;,&#123;\\&quot;lat\\&quot;:28.78180861483397,\\&quot;lng\\&quot;:104.43148611992537&#125;,&#123;\\&quot;lat\\&quot;:28.781583309482997,\\&quot;lng\\&quot;:104.43124472558465&#125;,&#123;\\&quot;lat\\&quot;:28.781658409582054,\\&quot;lng\\&quot;:104.43099260777262&#125;,&#123;\\&quot;lat\\&quot;:28.781883715242444,\\&quot;lng\\&quot;:104.43084240585604&#125;,&#123;\\&quot;lat\\&quot;:28.7823396910844,\\&quot;lng\\&quot;:104.43066000088999&#125;]&quot;, &quot;createTime&quot;: &quot;2024-03-20 15:41:40&quot;, &quot;devNum&quot;: 5, &quot;onlineDevices&quot;: null, &quot;offlineDevices&quot;: null, &quot;unSynDevices&quot;: null, &quot;otherDevicesStatus&quot;: null, &quot;devicesInfo&quot;: [ &#123; &quot;searchValue&quot;: null, &quot;createBy&quot;: null, &quot;createTime&quot;: null, &quot;updateBy&quot;: null, &quot;updateTime&quot;: null, &quot;remark&quot;: null, &quot;params&quot;: &#123;&#125;, &quot;beginTime&quot;: null, &quot;endTime&quot;: null, &quot;id&quot;: null, &quot;deviceCode&quot;: null, &quot;type&quot;: &quot;100601&quot;, &quot;devTypeClass&quot;: null, &quot;name&quot;: &quot;太阳能杀虫灯&quot;, &quot;lon&quot;: null, &quot;lat&quot;: null, &quot;icon&quot;: null, &quot;sortOrder&quot;: null, &quot;status&quot;: null, &quot;installDate&quot;: null, &quot;powerModel&quot;: null, &quot;netModel&quot;: null, &quot;onlineStatus&quot;: 3, &quot;modelNo&quot;: null, &quot;workVoltage&quot;: null, &quot;power&quot;: null, &quot;deviceSerialNum&quot;: &quot;865328061472766&quot;, &quot;devManufacturer&quot;: null, &quot;location&quot;: null &#125;, &#123; &quot;searchValue&quot;: null, &quot;createBy&quot;: null, &quot;createTime&quot;: null, &quot;updateBy&quot;: null, &quot;updateTime&quot;: null, &quot;remark&quot;: null, &quot;params&quot;: &#123;&#125;, &quot;beginTime&quot;: null, &quot;endTime&quot;: null, &quot;id&quot;: null, &quot;deviceCode&quot;: null, &quot;type&quot;: &quot;100401&quot;, &quot;devTypeClass&quot;: null, &quot;name&quot;: &quot;海康监控摄像头&quot;, &quot;lon&quot;: null, &quot;lat&quot;: null, &quot;icon&quot;: null, &quot;sortOrder&quot;: null, &quot;status&quot;: null, &quot;installDate&quot;: null, &quot;powerModel&quot;: null, &quot;netModel&quot;: null, &quot;onlineStatus&quot;: 3, &quot;modelNo&quot;: null, &quot;workVoltage&quot;: null, &quot;power&quot;: null, &quot;deviceSerialNum&quot;: &quot;fdccc9dc47e744a4b452d55312fb4b7e&quot;, &quot;devManufacturer&quot;: null, &quot;location&quot;: null &#125;, &#123; &quot;searchValue&quot;: null, &quot;createBy&quot;: null, &quot;createTime&quot;: null, &quot;updateBy&quot;: null, &quot;updateTime&quot;: null, &quot;remark&quot;: null, &quot;params&quot;: &#123;&#125;, &quot;beginTime&quot;: null, &quot;endTime&quot;: null, &quot;id&quot;: null, &quot;deviceCode&quot;: null, &quot;type&quot;: &quot;100101&quot;, &quot;devTypeClass&quot;: null, &quot;name&quot;: &quot;中全通墒情监测站0001&quot;, &quot;lon&quot;: null, &quot;lat&quot;: null, &quot;icon&quot;: null, &quot;sortOrder&quot;: null, &quot;status&quot;: null, &quot;installDate&quot;: null, &quot;powerModel&quot;: null, &quot;netModel&quot;: null, &quot;onlineStatus&quot;: 9, &quot;modelNo&quot;: null, &quot;workVoltage&quot;: null, &quot;power&quot;: null, &quot;deviceSerialNum&quot;: &quot;C0110200102309200001&quot;, &quot;devManufacturer&quot;: null, &quot;location&quot;: null &#125;, &#123; &quot;searchValue&quot;: null, &quot;createBy&quot;: null, &quot;createTime&quot;: null, &quot;updateBy&quot;: null, &quot;updateTime&quot;: null, &quot;remark&quot;: null, &quot;params&quot;: &#123;&#125;, &quot;beginTime&quot;: null, &quot;endTime&quot;: null, &quot;id&quot;: null, &quot;deviceCode&quot;: null, &quot;type&quot;: &quot;100102&quot;, &quot;devTypeClass&quot;: null, &quot;name&quot;: &quot;气象监测站1&quot;, &quot;lon&quot;: null, &quot;lat&quot;: null, &quot;icon&quot;: null, &quot;sortOrder&quot;: null, &quot;status&quot;: null, &quot;installDate&quot;: null, &quot;powerModel&quot;: null, &quot;netModel&quot;: null, &quot;onlineStatus&quot;: 9, &quot;modelNo&quot;: null, &quot;workVoltage&quot;: null, &quot;power&quot;: null, &quot;deviceSerialNum&quot;: &quot;A0110600102303140011&quot;, &quot;devManufacturer&quot;: null, &quot;location&quot;: null &#125;, &#123; &quot;searchValue&quot;: null, &quot;createBy&quot;: null, &quot;createTime&quot;: null, &quot;updateBy&quot;: null, &quot;updateTime&quot;: null, &quot;remark&quot;: null, &quot;params&quot;: &#123;&#125;, &quot;beginTime&quot;: null, &quot;endTime&quot;: null, &quot;id&quot;: null, &quot;deviceCode&quot;: null, &quot;type&quot;: &quot;100101&quot;, &quot;devTypeClass&quot;: null, &quot;name&quot;: &quot;情墒情站&quot;, &quot;lon&quot;: null, &quot;lat&quot;: null, &quot;icon&quot;: null, &quot;sortOrder&quot;: null, &quot;status&quot;: null, &quot;installDate&quot;: null, &quot;powerModel&quot;: null, &quot;netModel&quot;: null, &quot;onlineStatus&quot;: 3, &quot;modelNo&quot;: null, &quot;workVoltage&quot;: null, &quot;power&quot;: null, &quot;deviceSerialNum&quot;: &quot;C0110300102204180002&quot;, &quot;devManufacturer&quot;: null, &quot;location&quot;: null &#125; ], &quot;plantsInfo&quot;: [ &#123; &quot;id&quot;: 167, &quot;plantId&quot;: &quot;202408070002&quot;, &quot;cropId&quot;: null, &quot;cropName&quot;: &quot;1&quot;, &quot;cycleType&quot;: &quot;土豆&quot;, &quot;plantTime&quot;: &quot;2024-08-07 10:33:33&quot;, &quot;expectHarvestTime&quot;: &quot;2024-08-07 10:33:36&quot;, &quot;estimatedOutput&quot;: 1.00, &quot;landInfo&quot;: null, &quot;landId&quot;: &quot;Fie202403200005&quot;, &quot;landName&quot;: &quot;中药种植区&quot;, &quot;landArea&quot;: 18.00, &quot;growthCycle&quot;: &quot;[&#123;\\&quot;beginTime\\&quot;:\\&quot;\\&quot;,\\&quot;createBy\\&quot;:\\&quot;\\&quot;,\\&quot;cycleDays\\&quot;:20,\\&quot;cycleDescription\\&quot;:\\&quot;费乌瑞它，播种期拥有以下特征。。。\\&quot;,\\&quot;cycleImageUrl\\&quot;:\\&quot;http://zhny.zqtjs.com.cn/business-image/2024/06/25/feiwuruit_20240625142834A027.png\\&quot;,\\&quot;endTime\\&quot;:\\&quot;\\&quot;,\\&quot;growthCycle\\&quot;:\\&quot;播种期\\&quot;,\\&quot;params\\&quot;:&#123;&#125;,\\&quot;remark\\&quot;:\\&quot;\\&quot;,\\&quot;searchValue\\&quot;:\\&quot;\\&quot;,\\&quot;updateBy\\&quot;:\\&quot;\\&quot;&#125;,&#123;\\&quot;beginTime\\&quot;:\\&quot;\\&quot;,\\&quot;createBy\\&quot;:\\&quot;\\&quot;,\\&quot;cycleDays\\&quot;:40,\\&quot;cycleDescription\\&quot;:\\&quot;费乌瑞它，生长期拥有以下特征。。。\\&quot;,\\&quot;cycleImageUrl\\&quot;:\\&quot;http://zhny.zqtjs.com.cn/business-image/2024/06/25/feiwuruit_20240625142836A028.png\\&quot;,\\&quot;endTime\\&quot;:\\&quot;\\&quot;,\\&quot;growthCycle\\&quot;:\\&quot;生长期\\&quot;,\\&quot;params\\&quot;:&#123;&#125;,\\&quot;remark\\&quot;:\\&quot;\\&quot;,\\&quot;searchValue\\&quot;:\\&quot;\\&quot;,\\&quot;updateBy\\&quot;:\\&quot;\\&quot;&#125;,&#123;\\&quot;beginTime\\&quot;:\\&quot;\\&quot;,\\&quot;createBy\\&quot;:\\&quot;\\&quot;,\\&quot;cycleDays\\&quot;:50,\\&quot;cycleDescription\\&quot;:\\&quot;费乌瑞它，成熟期拥有以下特征。。。\\&quot;,\\&quot;cycleImageUrl\\&quot;:\\&quot;http://zhny.zqtjs.com.cn/business-image/2024/06/25/feiwuruit_20240625142838A029.png\\&quot;,\\&quot;endTime\\&quot;:\\&quot;\\&quot;,\\&quot;growthCycle\\&quot;:\\&quot;成熟期\\&quot;,\\&quot;params\\&quot;:&#123;&#125;,\\&quot;remark\\&quot;:\\&quot;\\&quot;,\\&quot;searchValue\\&quot;:\\&quot;\\&quot;,\\&quot;updateBy\\&quot;:\\&quot;\\&quot;&#125;]&quot;, &quot;currentCycleImageUrl&quot;: null, &quot;discard&quot;: 1, &quot;landType&quot;: null, &quot;startTime&quot;: null, &quot;endTime&quot;: null &#125; ], &quot;breedsInfo&quot;: null, &quot;soilInfo&quot;: null &#125; ], &quot;code&quot;: 200, &quot;msg&quot;: &quot;查询成功&quot;&#125; 过程整理 点击大棚请求数据（这个渲染哪些大棚）-&gt;确定大棚得到大棚id值查询 大棚基础数据 设备信息 监控视频列表 监控部分：获取kit_token-&gt;获取监控视频流地址（缺少参数 &#x2F;&#x2F; todo） 天气数据：获取时间段数据–平均数据–当前数据（参数问题 ） 设备信息：整个设备部分存在问题 对应： 大棚列表： 视频实时监控 监控视频 气象站当前数据 气象站平均数据 气象站时间段数据 气象站历史数据 设备信息"},{"title":"leetcode 题解","path":"/algo-leetcode.html","content":"数组704. 二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 定义左右索引，确定数组范围 确定循环条件 计算中间索引 与目标值比较，跟新索引 27.移除元素给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。 遍历数组，获取到每一个元素 数组是连续的，则需要把每个不等于val的元素连续存放再数组里 返回val元素数量 977.有序数组的平方给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 思路1： 求出平方后未排序的数组 对数组进行排序 思路2： 构建左右索引，从两边开始判断其绝对值或者平方谁更大 更大的从后往前赋值给新数组 209.长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度 。如果不存在符合条件的子数组，返回 0 。 滑动窗口，初始化窗口最左边界为0，右边界随意，也可为0 初始化返回值，根据题目确定是最大还是最小值，求最大就是0，求最小为Integer.MAX_VALUE 确定窗口大小，根据题目进行调整，还需要确定窗口大小对应的计算值 随着窗口扩张，结合循环条件，与返回值进行比较 59. 螺旋矩阵 II给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 确认矩阵大小为 n*n 第一行肯定为 1 到 n，第 n 列为 n 到 2n-1 ，倒数第一行为 3n-2 到 2n-1 这些都是最外层的 尝试把他做成一条直线，其中，在n处开始折 直接模拟，难点在代码编写上 2706. 购买两块巧克力给你一个整数数组 prices ，它表示一个商店里若干巧克力的价格。同时给你一个整数 money ，表示你一开始拥有的钱数。 你必须购买 恰好 两块巧克力，而且剩余的钱数必须是 非负数 。同时你想最小化购买两块巧克力的总花费。 请你返回在购买两块巧克力后，最多能剩下多少钱。如果购买任意两块巧克力都超过了你拥有的钱，请你返回 money 。注意剩余钱数必须是非负数。 遍历数组，排序 求出最小两个数的和 和money比较，如果更大返回money更小则返回相减的值 1480. 一维数组的动态和给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。请返回 nums 的动态和。 需要新数组来放值，并且第一个值相等 第n个值等于 之前求和的值 sum(0~n-1) + nums[n] 小结 二分法 双指针法 滑动窗口 模拟行为 前缀和 链表203. 移除链表元素给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 思路 遍历链表，找到val对应值 更新引用 如果头借点也是满足的点，把头节点引用跟新成下一个节点的 237. 删除链表中的节点21. 合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的 思路 定义一个虚拟头节点，使用双指针 pre 和 cur 开始的时候让pre &#x3D; cur，初始化头节点值为0 循环遍历两个链表都不为空的部分，把值小的给到cur.next 剩余部分责判断两个链表谁不为空，把不为空的节点给到 cur.next 返回pre.next 206. 反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 思路： 双指针，让定义pre 和 cur，让pre 指向头节点，cur指向null 再重构之后是pre指向尾节点，所有我们写完代码需要返回cur 开始遍历链表，这里用3个节点演示，分表为 n1,n2,n3 第一次遍历：pre -&gt; n1 cur -&gt;null ; tmp &#x3D; pre.next &#x3D; n1, pre.next &#x3D; cur &#x3D;null ,cur &#x3D; pre &#x3D; n1 , pre &#x3D; tmp &#x3D; n2 第二次遍历：条件pre -&gt; n2 cur-&gt;n1;tem &#x3D; pre.next &#x3D; n2, pre.next &#x3D;cur &#x3D;null, cur &#x3D;pre &#x3D; n2, pre &#x3D; tmp &#x3D; n3; 86. 分隔链表给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。 你应当 保留 两个分区中每个节点的初始相对位置。 思路 拆分成两个，定义两个虚拟头节点，然后遍历链表，把大的放在链表2，小的放在链表1 合并两个链表，把链表1尾部节点的下一个指向链表2头部节点，链表2尾节点指向空 返回链表1头节点 面试题 02.07. 链表相交给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 思路 创建两个节点，作为headA（别名 a）和headB（别名b） a和b的相同部分c，a到c经过n个节点，b到c经过m个节点 第一次走：a长度：n+c，b长度：m+c 第二次换路径走：a长度：m+c，b长度：n+c 这样他们无论怎么怎么走都是a：n-&gt;c-&gt;m-&gt;c，b：m-&gt;c-&gt;n-&gt;c 终点都是c，如果有交点无论如何都是会在c相遇，如果没有交点，就是n-&gt;m和m-&gt;n也就不会相遇。 栈与队列20. 有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 思路 左括号入站，遇到右括号就出站 直接遇到右括号返回false 232. 用栈实现队列请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 思路 设计栈 A 用于加入队尾操作，栈 B 用于将元素倒序，从而实现删除队首元素。 155. 最小栈设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 思路： 定义静态内部类Node节点，存放最小值、平常值、地址 在push元素的时候，地址指向上一个节点，也就在栈里体现的是链表是头节点在前，指向下面的节点 那么后续的pop等操作就直接围绕头节点地址进行操作即可 哈希表242. 有效的字母异位词给定两个字符串 _s_ 和 _t_ ，编写一个函数来判断 _t_ 是否是 _s_ 的字母异位词。 注意：若 _s_ 和 _t_ 中每个字符出现的次数都相同，则称 _s_ 和 _t_ 互为字母异位词 思路： 两个字符串中字符出现的种类和次数均相等则符合题意 维护一个hash表，让字符串s按顺序填充，其中字符为key，第一次val为1，后续添加val++ 再次遍历判断是否含有key，有key则val– 最后hash表里面有非0数则返回false。 387. 字符串中的第一个唯一字符给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。 思路： 双指针，一旦遇到相同值则进入下一个循环，如果没有遇到则返回索引 哈希表，第一次遍历保存k，后续v取第一次遇到的索引 和 次数 1.1 ，1.2，如果v为1那么 205. 同构字符串给定两个字符串 s 和 t ，判断它们是否是同构的。 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。 双指针392. 判断子序列给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。 进阶： 如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？"},{"title":"algo","path":"/algo-Algo.html","content":"复杂度分析算法效率评估复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。 时间复杂度、空间复杂度 运行效率和数据体量的关系 时间或者空间的增长快慢 迭代与递归迭代在满足一定的条件下重复执行某段代码，直到这个条件不再满足 for循环：适合在预先知道迭代次数时使用 while循环：while 循环比 for 循环的自由度更高 嵌套循环：循环次数呈几何增长 递归程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”，触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果 三要素终止条件、递归调用、返回结果 递归求1加到n系统需要保存上下文，以维持从入到出的过程 12345678910/* 递归 */int recur(int n) &#123; // 终止条件 if (n == 1) return 1; // 递：递归调用 int res = recur(n - 1); // 归：返回结果 return n + res;&#125; 尾递归求1加到n系统无需维持上下文，因为尾递归调用函数返回前的最后一个操作，在入的时候就已经实现了操作，只需要到达终止条件层层返回结果即可。 12345678/* 尾递归 */int tailRecur(int n, int res) &#123; // 终止条件 if (n == 0) return res; // 尾递归调用 return tailRecur(n - 1, res + n);&#125; 递归树求斐波那契数列的第 𝑛 个数字已经知道求斐波那契数列的第 𝑛 个数字为 𝑛 的前两个数字的和，即 𝑛 &#x3D; 𝑛1 + 𝑛2。同理可求 𝑛1 和 𝑛2 的前两个数字，所有入时候存在分支，即树形递归。 12345678910/* 斐波那契数列：递归 */int fib(int n) &#123; // 终止条件 f(1) = 0, f(2) = 1 if (n == 1 || n == 2) return n - 1; // 递归调用 f(n) = f(n-1) + f(n-2) int res = fib(n - 1) + fib(n - 2); // 返回结果 f(n) return res;&#125; 提升：尾递归+递归树求斐波那契数列的第 𝑛 个数字1234567/* 斐波那契数列：递归 */int fib(int n, int a, int b) &#123; // 基础情况，如果 𝑛 == 1作为条件则可以作为第 𝑛 个数字的值 if (n == 1) return a; // 将计算结果和下一个状态通过参数传递给下一次递归调用，形成尾递归 return fib(n - 1, b, a + b); &#125; 这里尾递归需要注意的是：n是计算次数，而不是第 𝑛 个数字，比如获取第5个数，实际上只需要计算4次，因为最终次是不需要计算的，是直接return值的。所以会发现尾递归的结果其实是第 𝑛 +1个数字的值 迭代和递归的区别 迭代自下而上、递归自上而下 递归通常比迭代更加耗费内存空间。 递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。 时间复杂度不依赖于环境因素，单看这个算法的执行，抓住主要矛盾进行表示，是算法运行时间随着数据量变大时的增长趋势 复杂度分类 差时间复杂度 𝑂(𝑛) 最佳时间复杂度 Ω(1) 平均时间复杂度为 Θ(𝑛&#x2F;2)&#x3D;Θ(𝑛) 很多时候管 𝑂(𝑛)叫也叫平均时间复杂度 渐进上界线性阶的时间复杂度记为 𝑂(𝑛) ，表示函数 𝑇(𝑛) 的渐近上界，也就可以看作数据量无限多的时候 计算方法 忽略 𝑇(𝑛) 中的常数项 省略所有系数 循环嵌套时使用乘法 时间复杂度由 𝑇(𝑛) 中最高阶的项来决定 常见类型 对数阶 𝑂(log⁡𝑛)：每轮缩减到一半 线性对数阶 𝑂(𝑛log⁡𝑛)：常出现于嵌套循环中，两层循环的时间复杂度分别为 𝑂(log⁡𝑛) 和 𝑂(𝑛) 指数阶 𝑂(2𝑛)：生物学的“细胞分裂” 阶乘阶𝑂(𝑛!)：对应数学上的“全排列”问题 空间复杂度占用的额外空间成本，用于衡量算法占用内存空间随着数据量变大时的增长趋势，我们通常只关注最差空间复杂度 算法相关空间 1234567int algorithm(int n) &#123; // 输入数据 final int a = 0; // 暂存数据（常量） int b = 0; // 暂存数据（变量） Node node = new Node(0); // 暂存数据（对象） int c = function(); // 栈帧空间（调用函数） return a + b + c; // 输出数据&#125; 常见类型 常数阶𝑂(1)：循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 𝑂(1) 对数阶 𝑂(log⁡𝑛)：对数阶常见于分治算法。例如归并排序，输入长度为 𝑛 的数组，每轮递归将数组从中点处划分为两半，形成高度为 log⁡𝑛 的递归树，使用 𝑂(log⁡𝑛) 栈帧空间。 线性阶 𝑂(𝑛)：线性阶常见于元素数量与 𝑛 成正比的数组、链表、栈、队列等 平方阶 𝑂(𝑛2)：平方阶常见于矩阵和图，元素数量与 𝑛 成平方关系 指数阶 𝑂(2𝑛)：指数阶常见于二叉树。层数为 𝑛 的“满二叉树”的节点数量为 2𝑛−1 ，占用 𝑂(2𝑛) 空间 数据结构常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类 逻辑结构线性线性数据结构：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系 非线性非线性数据结构：树、堆、图、哈希表 可以进一步划分为树形结构和网状结构。 树形结构：树、堆、哈希表，元素之间是一对多的关系。 网状结构：图，元素之间是多对多的关系 物理结构连续 基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 ≥3 的数组）等。 离散 基于链表可实现：栈、队列、哈希表、树、堆、图等。 基本数据类型 数组与链表数组是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中 初始化/* 初始化数组 */int[] arr = new int[5]; // &#123; 0, 0, 0, 0, 0 &#125;，不带初始值int[] nums = &#123; 1, 3, 2, 5, 4 &#125;; 访问与查找 索引本质上是内存地址的偏移量。 数组中访问元素非常高效，我们可以在 𝑂(1) 时间内随机访问数组中的任意一个元素。 数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引，也就是“线性查找” 插入删除 数组元素在内存中是“紧挨着的”，所以插入的时候会把该元素之后的所有元素都向后移动一位，同理删除也会把该元素之后的所有元素都想前移动一位 需要注意插入时，如果数组没有扩容机制可能导致数据丢失，删除时则会把原先末尾的元素变得“无意义” 遍历扩容 既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素 在Java中数组的长度是不可变的，如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。 动态数组扩容机制： 初始容量：选取一个合理的数组初始容量，比如 10 数量记录：声明一个变量 size ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。 扩容机制：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。比如每次把数组扩容到原来的2倍大小 优缺点优点： 连续存储，空间效率高 支持在 𝑂(1) 时间随机访问 访问数组元素，会缓存他和周围的元素，也就是局部缓存性 缺点： 插入与删除要移动大量元素，效率低，可能造成数据丢失或者内存浪费 长度不可变，扩容开销大（动态数组则长度可变） 可能造成空间浪费 链表是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接 初始化123456/* 链表节点类 */class ListNode &#123; int val; // 节点值 ListNode next; // 指向下一节点的引用 ListNode(int x) &#123; val = x; &#125; // 构造函数&#125; 插入删除假设我们想在相邻的两个节点 n0 和 n1 之间插入一个新节点 P ，则只需改变两个节点引用（指针）即可，时间复杂度为 𝑂(1) 。 12345678910111213/* 在链表的节点 n0 之后插入节点 P */void insert(ListNode n0, ListNode P) &#123;\tn0.next = P; P.next = n0.next;&#125;/* 删除链表的节点 n0 之后的首个节点 */void remove(ListNode n0) &#123; if (n0.next == null) return; // n0 -&gt; P -&gt; n1 n0.next = P.next;&#125; 访问查找 访问链表的第 𝑖 个节点需要循环 𝑖−1 轮，时间复杂度为 𝑂(𝑛) 遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引 优缺点 分散存储 可灵活拓展 占用内存更多 常见类型 栈是一种遵循先入后出逻辑的线性数据结构 栈的实现 方法 描述 时间复杂度 push() 元素入栈（添加至栈顶） 𝑂(1) pop() 栈顶元素出栈 𝑂(1) peek() 访问栈顶元素 𝑂(1) 基于链表的实现 基本结构：从上到下，头节点-&gt;尾节点 push()：头插法实现 pop()：删除头节点即可 基于数组的实现 基本结构：动态数组尾部作为栈顶 push()： 在尾部添加 pop()：删除最后一个元素 两种实现对比 基于链表实现的栈可以提供更加稳定的效率表现 基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高 基于数组实现的栈可能造成一定的空间浪费、链表节点占用的空间相对较大，不能简单地确定哪种实现更加节省内存 队列是一种遵循先入先出规则的线性数据结构。 队列常用操作 方法名 描述 时间复杂度 push() 元素入队，即将元素添加至队尾 𝑂(1) pop() 队首元素出队 𝑂(1) peek() 访问队首元素 𝑂(1) 队列实现基于链表的实现 可以将链表的“头节点”和“尾节点”分别视为“队首”和“队尾” 队尾仅可添加节点 队首仅可删除节点 基于数组的实现 使用可变长环形数组 维护一个变量 size 用于记录队列长度、维护一个变量front指向队首元素的索引、维护一个变量rear指向队尾元素的索引 使用 front = (front+1) % size 计算索引，删除元素、使用 rear = (rear+1) % size 计算索引，添加元素 使用front == rear作为队空条件，使用rear = (rear+1) == front作为队满条件 双向队列允许在头部和尾部执行元素的添加或删除操作 哈希表又称散列表，它通过建立键 key 与值 value 之间的映射，实现高效的元素查询。 原理通过数组配合链表实现， 占用空间增大：链表包含节点指针，它相比数组更加耗费内存空间。 查询效率降低：因为需要线性遍历链表来查找对应元素。 开放寻址","tags":["算法","数据结构"],"categories":["笔记"]},{"title":"Docker笔记","path":"/tool-Docker.html","content":"基本概念和原理 镜像：类似Java中的类，或者说是一个软件，只读 容器：类似Java中类的对象实例，运行中的软件，可读可写 仓库：docker镜像分享合集，docker pull ；先找本地再找远程，dockerhub docker daemon：服务端守护进程，管理docker的各种资源 docker client：客户端发送命令和docker daemon进行交互 安装docker 在官网选择对应的操作系统，选择教程进行安装：链接 可以使用官方脚本自动安装：curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 检查是否安装成功 开机自启动：sudo systemctl enable docker 启动docker：sudo systemctl start docker （stop停止） 查看docker版本：docker version 查看状态：sudo systemctl status docker 下载测试映像并在容器中运行hello word测试：sudo docker run hello-world 镜像加速：阿里云镜像加速器 更新：2024年7月11日21:01:30国内的机器docker 安装： 1234567891011121314151617sudo apt-get -y update sudo apt-get -y install vim apt-transport-https ca-certificates curl software-properties-common gpg-agentcurl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo apt-key add -sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/debian $(lsb_release -cs) stable&quot;sudo apt-get -y update# 可选查看可安装版本apt policy docker-ce# 比如sudo apt install -y docker-ce=5:20.10.6~3-0~debian-bullseye docker-ce-cli=5:20.10.6~3-0~debian-bullseye containerd.io docker-buildx-plugin docker-compose-pluginsudo apt-get -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugindocker version 容器化 创建Dockerfile 使用Dockerfile构建镜像 使用镜像创建和运行容器 基本操作镜像docker version | docker引擎信息docker info | docker引擎详细信息docker images | 查看当前有哪些镜像docker image -q 名称 | 查看指定镜像iddocker image rm 名称（id） | 删除镜像（未运行过的镜像）docker image rm -f 名称（id） | 强制删除镜像docker pull 名称 版本 | 远程拉取镜像docker search 名称 | 查看镜像是否存在docker images rm -f $(docker images -q 名称) | 删除所有指定名称的镜像docker tag 旧镜像名 新镜像名 | 镜像改名 容器docker ps | 查看当前docker引擎正在运行的容器 ，加-a 查看所有的容器docker run 镜像名称|镜像id | 运行容器，未映射docker run -p8080(宿主机的端口):8080(容器的端口) 镜像名称|镜像id 建立映射 -p 运行（需要防火墙，映射后就进入白名单了），注意容器间端口的操作系统隔离，可以映射多个端口 添加-d 是后台（守护进程启动） 添加–name 名称 ，容器启动的唯一名称 不管顺序 跟着docker重启docker容器 --restart=always 数据卷：容器和主机的数据映射，容器首次启动时设置docker run -v 宿主机目录:容器内目录 | 数据卷映射，始终与宿主机为主（会清空容器 ），:ro容器只读只能宿主机影响docker run -v 别名:容器内目录 | 如果别名里没有内容则不清空容器，目录默认在/var/lib/docker/volumes/里面 docker stop 容器id|名称 | 停止docker restart 容器id|名称 | 重启docker start 容器id|名称 | 启动容器docker pause 容器id|名称 | 暂停运行docker unpause 容器id|名称 | 恢复运行docker kill 容器id|名称 | 杀死容器docker rm 容器id|名称 | 删除容器（已经 停止）-f强制删除，可以组合删除docker logs 容器id|名称 | 容器日志 -f 实时监控容器，-t 展示时间docker exec -it 容器id|名称 bash | 交互模式进入容器，会切换成容器的bash终端exit 退出容器docker cp 容器id:容器中文件或目录主机那个目录 | 将容器中指定文件和目录拷贝到宿主机docker cp主机文件和目录 容器id:容器中目录 | 将主机中指定文件和目录拷贝到容器内 如何部署一个web项目war包项 目 a. 将test.war 上传到linxu服务器b. 通过docker cp命令将test.war复制到tomcat的webapps目录中即可c. ip端口测试访问 docker top 容器id|名称 | 查看容器进程docker inspect 容器id|名称 | 查看容器内部细节打包容器：docker commit -m &quot;提交信息&quot; -a &quot;作者&quot; 容器id|name 镜像名:版本镜像的备份和恢复:docker save 镜像名 -o 名称（名称-版本）.tar | 打包镜像docker load -i 名称.tar | 载入镜像 高级网络通信docker容器间的通信，在创建docker容器的时候会有一对接口 一个叫eth0在容器内部, 一个以 veth开头被挂载到 docker0网桥（一个内一个外），一个接口接受数据时，另一个也会接受相同的数据，虚拟共享网络 所以，默认容器间就可以通信！ docker inspect 容器id|名称 | 查看容器内部细节 获得ip，进行通信，也可以使用容器名称进行通信（必须自定义网桥，不能再用docker0） 一般都是自定义，如果都走docker0一个网桥会影响通信 docker network create 网络名称 | 创建网桥docker network ls | 查看网络docker inspect network 网络名称 | 查看网络内部细节docker network rm 网络名称 | 删除指定网络docker network prune | 删除所有未被用到的网络 对于容器启动前（后）都可以修改网络运行前：--network 网络名称运行时：docker network connect 网络名称 容器id|name DockerfileDockerfile可以认为是Docker镜像的描述文件,是由一系列命令和参数构成的脚本。主要作用是用来构建docker镜像的构建文件。 docker build -t 名称:版本 .（dockerfile所在位置，就一个点就是当前目录） 一行一个保留字 保留字 作用 FROM 当前镜像是基于哪个镜像的，第一个指令必须是FROM MAINTAINER 镜像维护者的姓名和邮箱地址（废弃） RUN 构建镜像时需要运行的指令，基于FROM的指定镜像 EXPOSE 当前容器对外暴露出的端口号，仅做声明作用 WORKDIR 指定在创建容器后,终端默认登录进来的工作目录, 一个落脚点 ENV 用来在构建镜像过程中设置环境变量，key&#x3D;value 引用$key ADD 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包 COPY 类似于ADD ,拷贝文件和目录到镜像中将从构建上下文目录中&lt;原路径&gt;的文件&#x2F;目录复制到新的一层的镜像内的&lt;目标路径&gt;位置 VOLUME 容器数据卷,用于数据保存和持久化工作,仅做声明作用 CMD 指定一个容器启动时要运行的命令，Dockerfile中可以有多个CMD指令,但只有最后一个生效，CMD会被docker run之后的参数替换 ENTRYPOINT 指定-一个容器启动时要运行的命令ENTRYPOINT的目的和CMD一样,都是在指定容器启动程序及其参数 ## Docker-compose 引入 容器启动顺序至关重要 多服务器部署变得困难 docker-compose 实现docker容器集群的快速编排，docker-compose.yml就是应用（project，完整的业务单元），service，一个项目中的某一个容器，称为一个服务 安装123456789101112131415161718192021# 下载sudo curl -L https://github.com/docker/compose/releases/download/v2.24.6/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose# 权限sudo chmod +x /usr/local/bin/docker-compose# 下配置会增加一段自定义内网 IPv6 地址，开启容器的 IPv6 功能，以及限制日志文件大小，防止 Docker 日志塞满硬盘cat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123; &quot;log-driver&quot;: &quot;json-file&quot;, &quot;log-opts&quot;: &#123; &quot;max-size&quot;: &quot;20m&quot;, &quot;max-file&quot;: &quot;3&quot; &#125;, &quot;ipv6&quot;: true, &quot;fixed-cidr-v6&quot;: &quot;fd00:dead:beef:c0::/80&quot;, &quot;experimental&quot;:true, &quot;ip6tables&quot;:true&#125;EOF 使用docker-compose up [options] [SERVICE. ..] | 在docker-compose.yml配置文件目录启动docker-compose，该命令十分强大，它将尝试自动完成包括构建镜像，( 重新)创建服务，启动服务,并关联服务相关容器的一系列操作。链接的服务都将会被自动启动，除非已经处于运行状态。-d 将会在后台启动并运行所有的容器，默认情况，如果服务容器已经存在，会尝试停止容器,然后重新创建(保持使用volumes -from挂载的卷) ,以保证新启动的服务匹配docker-compose.yml文件的最新内容 docker-compose down | 关闭所有容器,并移除网络 1234567891011121314151617# docker-compose版本version:&quot;3.0&quot;services:\t# 服务名称\ttomcat:\t# 服务镜像\timages: tomcat8.0 # 镜像名称\tports: # 端口映射 - 8080:8080 environment: # 指定启动环境 - volumens: # 指定数据卷,路径必须存在 - /root/data:/var/libvolumens: # 声明data卷\tdata： build 指令通过docker-compose在启动容器之前现根据Dockerfile构建镜像,然后根据构建镜像启动容器 comnand 指令覆盖容器启动后默认执行的命令 container_name指令用来指定docker-compose启动容器名称注意:不推荐指定容器名称 depends_ on指令解决容器的依赖、启动先后的问题注意:当前服务不会等待被依赖服务「 完全启动」之后才启动 environment 指令用来给容器启动指定环境变量相当于docker run -e选项 env_ file 指令用来给容器启动指定环境变量文件相当于docker run -e选项 expose 指令用来指定构建镜像过程中容器暴露的端口号 image 指令用来指定启动容 器使用镜像是谁相当于docker run image(镜 像名) networks 指令用来指定 启动容器使用网桥相当于 docker run –network ports 指令用来指 定宿主机和容器端口映射相当于docker run -p volunes 指令用来指定宿主机中容器目录目录映射 docker run -v restart指令用来指定docker容器(服务)总是运行 docker run – rest art&#x3D; always . 来源Docker 1小时快速上手教程，无废话纯干货【编程不良人】Docker&amp;Docker-Compose 实战!","tags":["docker","容器","笔记"],"categories":["项目部署","笔记"]},{"title":"(九). 登堂入室 - JDK8","path":"/JavaSE-JDK8.html","content":"JDK8新特性方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。 方法引用使用一对冒号 :: 。 下面，我们在 Car 类中定义了 4 个方法作为例子来区分 Java 中 4 种不同方法的引用。 1234567891011121314151617public static class Car &#123; public static Car create( final Supplier&lt; Car &gt; supplier ) &#123; return supplier.get(); &#125; public static void collide( final Car car ) &#123; System.out.println( &quot;Collided &quot; + car.toString() ); &#125; public void follow( final Car another ) &#123; System.out.println( &quot;Following the &quot; + another.toString() ); &#125; public void repair() &#123; System.out.println( &quot;Repaired &quot; + this.toString() ); &#125;&#125; 第一种方法引用的类型是构造器引用，语法是Class::new，或者更一般的形式： Class&lt;T&gt;::new 。注意：这个构造器没有参数。 final Car car = Car.create( Car::new );final List&lt; Car &gt; cars = Arrays.asList( car ); 第二种方法引用的类型是静态方法引用，语法是Class::static_method。注意：这个方法接受一个Car类型的参数。 cars.forEach( Car::collide ); 第三种方法引用的类型是某个类的成员方法的引用，语法是Class::method，注意，这个方法没有定义入参： cars.forEach( Car::repair ); 第四种方法引用的类型是某个实例对象的成员方法的引用，语法是instance::method。注意：这个方法接受一个Car类型的参数： final Car police = Car.create( Car::new );cars.forEach( police::follow ); Lambda表达式函数式编程思想概述在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。 做什么，而不是怎么做 我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而不得不创建一个对象。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。 传递一段代码——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。 Lambda的优化当需要启动一个线程去完成任务时，通常会通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。 传统写法,代码如下： 12345678910public class Demo01ThreadNameless &#123;\tpublic static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;多线程任务执行！&quot;); &#125; &#125;).start();\t&#125;&#125; 本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个Runnable接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。 代码分析: 对于Runnable的匿名内部类用法，可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要Runnable接口的实现类； 为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 Lambda表达式写法,代码如下： 借助Java 8的全新语法，上述Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效： public class Demo02LambdaRunnable &#123;\tpublic static void main(String[] args) &#123; new Thread(() -&gt; System.out.println(&quot;多线程任务执行！&quot;)).start(); // 启动线程\t&#125;&#125; 这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。 不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！ Lambda的格式标准格式:Lambda省去面向对象的条条框框，格式由3个部分组成： 一些参数 一个箭头 一段代码 Lambda表达式的标准格式为： (参数类型 参数名称) -&gt; &#123; 代码语句 &#125; 格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt;是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 匿名内部类与lambda对比: 123456new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;多线程任务执行！&quot;); &#125;&#125;).start(); 仔细分析该代码中，Runnable接口只有一个run方法的定义： public abstract void run(); 即制定了一种做事情的方案（其实就是一个方法）： 无参数：不需要任何条件即可执行该方案。 无返回值：该方案不产生任何结果。 代码块（方法体）：该方案的具体执行步骤。 同样的语义体现在Lambda语法中，要更加简单： () -&gt; System.out.println(&quot;多线程任务执行！&quot;) 前面的一对小括号即run方法的参数（无），代表不需要任何条件； 中间的一个箭头代表将前面的参数传递给后面的代码； 后面的输出语句即业务逻辑代码。 参数和返回值下面举例演示java.util.Comparator&lt;T&gt;接口的使用场景代码，其中的抽象方法定义为： public abstract int compare(T o1, T o2); 当需要对一个对象数组进行排序时，Arrays.sort方法需要一个Comparator接口实例来指定排序的规则。假设有一个Person类，含有String name和int age两个成员变量： 123456public class Person &#123; private String name; private int age; // 省略构造器、toString方法与Getter Setter &#125; 传统写法 如果使用传统的代码对Person[]数组进行排序，写法如下： 12345678910111213141516171819public class Demo06Comparator &#123; public static void main(String[] args) &#123; // 本来年龄乱序的对象数组 Person[] array = &#123; new Person(&quot;古力娜扎&quot;, 19), new Person(&quot;迪丽热巴&quot;, 18), new Person(&quot;马尔扎哈&quot;, 20) &#125;; // 匿名内部类 Comparator&lt;Person&gt; comp = new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; return o1.getAge() - o2.getAge(); &#125; &#125;; Arrays.sort(array, comp); // 第二个参数为排序规则，即Comparator接口实例 for (Person person : array) &#123; System.out.println(person); &#125; &#125;&#125; 这种做法在面向对象的思想中，似乎也是“理所当然”的。其中Comparator接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。 代码分析 下面我们来搞清楚上述代码真正要做什么事情。 为了排序，Arrays.sort方法需要排序规则，即Comparator接口的实例，抽象方法compare是关键； 为了指定compare的方法体，不得不需要Comparator接口的实现类； 为了省去定义一个ComparatorImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象compare方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 实际上，只有参数和方法体才是关键。 Lambda写法 12345678910111213141516public class Demo07ComparatorLambda &#123; public static void main(String[] args) &#123; Person[] array = &#123; new Person(&quot;古力娜扎&quot;, 19), new Person(&quot;迪丽热巴&quot;, 18), new Person(&quot;马尔扎哈&quot;, 20) &#125;; Arrays.sort(array, (Person a, Person b) -&gt; &#123; return a.getAge() - b.getAge(); &#125;); for (Person person : array) &#123; System.out.println(person); &#125; &#125;&#125; 省略格式在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。 可推导即可省略 Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法： Runnable接口简化:1. () -&gt; System.out.println(&quot;多线程任务执行！&quot;)Comparator接口简化:2. Arrays.sort(array, (a, b) -&gt; a.getAge() - b.getAge()); Lambda的前提条件Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。 Stream在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决已有集合类库既有的弊端。 传统集合的多步遍历代码 几乎所有的集合（如Collection接口或Map接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。 循环遍历的弊端 Java 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行了对比说明。现在，我们仔细体会一下上例代码，可以发现： for循环的语法就是“怎么做” for循环的循环体才是“做什么” 为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从第一个到最后一个顺次处理的循环。前者是目的，后者是方式。 试想一下，如果希望对集合中的元素进行筛选过滤： 将集合A根据条件一过滤为子集B； 然后再根据条件二过滤为子集C。 每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？不是。循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。 那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？ Stream的更优写法 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤、逐一打印。代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。 流式思想概述注意：请暂时忘记对传统IO流的固有印象！ 整体来看，流式思想类似于工厂车间的“生产流水线”。 当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤方案，然后再按照方案去执行它。 “Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。 获取流方式java.util.stream.Stream&lt;T&gt;是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。） 获取一个流非常简单，有以下几种常用的方式： 所有的Collection集合都可以通过stream默认方法获取流； Stream接口的静态方法of可以获取数组对应的流。 方式1 : 根据Collection获取流 首先，java.util.Collection接口中加入了default方法stream用来获取流，所以其所有实现类均可获取流。 123456789101112131415161718import java.util.*;import java.util.stream.Stream;public class Demo04GetStream &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); // ... Stream&lt;String&gt; stream1 = list.stream(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); // ... Stream&lt;String&gt; stream2 = set.stream(); Vector&lt;String&gt; vector = new Vector&lt;&gt;(); // ... Stream&lt;String&gt; stream3 = vector.stream(); &#125;&#125; 方式2 : 根据Map获取流 java.util.Map接口不是Collection的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况： 12345678910111213import java.util.HashMap;import java.util.Map;import java.util.stream.Stream;public class Demo05GetStream &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // ... Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;String&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream(); &#125;&#125; 方式3 : 根据数组获取流 如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以Stream接口中提供了静态方法of，使用很简单： 12345678import java.util.stream.Stream;public class Demo06GetStream &#123; public static void main(String[] args) &#123; String[] array = &#123; &quot;张无忌&quot;, &quot;张翠山&quot;, &quot;张三丰&quot;, &quot;张一元&quot; &#125;; Stream&lt;String&gt; stream = Stream.of(array); &#125;&#125; 备注：of方法的参数其实是一个可变参数，所以支持数组。 常用方法流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种： 终结方法：返回值类型不再是Stream接口自身类型的方法，因此不再支持类似StringBuilder那样的链式调用。本小节中，终结方法包括count和forEach方法。 非终结方法：返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为非终结方法。） 函数拼接与终结方法在上述介绍的各种方法中，凡是返回值仍然为Stream接口的为函数拼接方法，它们支持链式调用；而返回值不再为Stream接口的为终结方法，不再支持链式调用。如下表所示： 方法名 方法作用 方法种类 是否支持链式调用 count 统计个数 终结 否 forEach 逐一处理 终结 否 filter 过滤 函数拼接 是 limit 取用前几个 函数拼接 是 skip 跳过前几个 函数拼接 是 map 映射 函数拼接 是 concat 组合 函数拼接 是 备注：本小节之外的更多方法，请自行参考API文档。 forEach : 逐一处理虽然方法名字叫forEach，但是与for循环中的“for-each”昵称不同，该方法并不保证元素的逐一消费动作在流中是被有序执行的。 void forEach(Consumer&lt;? super T&gt; action); 该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理。例如： 12345678import java.util.stream.Stream;public class Demo12StreamForEach &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); stream.forEach(s-&gt;System.out.println(s)); &#125;&#125; count：统计个数正如旧集合Collection当中的size方法一样，流提供count方法来数一数其中的元素个数： long count(); 该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用： 1234567public class Demo09StreamCount &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.filter(s -&gt; s.startsWith(&quot;张&quot;)); System.out.println(result.count()); // 2 &#125;&#125; filter：过滤可以通过filter方法将一个流转换成另一个子集流。方法声明： Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 该接口接收一个Predicate函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。 基本使用 Stream流中的filter方法基本使用的代码如： 123456public class Demo07StreamFilter &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.filter(s -&gt; s.startsWith(&quot;张&quot;)); &#125;&#125; 在这里通过Lambda表达式来指定了筛选的条件：必须姓张。 limit：取用前几个limit方法可以对流进行截取，只取用前n个。方法签名： Stream&lt;T&gt; limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用： 123456789import java.util.stream.Stream;public class Demo10StreamLimit &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.limit(2); System.out.println(result.count()); // 2 &#125;&#125; skip：跳过前几个如果希望跳过前几个元素，可以使用skip方法获取一个截取之后的新流： Stream&lt;T&gt; skip(long n); 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用： 12345678910import java.util.stream.Stream;public class Demo11StreamSkip &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;); Stream&lt;String&gt; result = original.skip(2); System.out.println(result.count()); // 1 &#125;&#125; map：映射如果需要将流中的元素映射到另一个流中，可以使用map方法。方法签名： &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。 基本使用 Stream流中的map方法基本使用的代码如： 12345678import java.util.stream.Stream;public class Demo08StreamMap &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; original = Stream.of(&quot;10&quot;, &quot;12&quot;, &quot;18&quot;); Stream&lt;Integer&gt; result = original.map(s-&gt;Integer.parseInt(s)); &#125;&#125; 这段代码中，map方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为Integer类对象）。 concat：组合如果有两个流，希望合并成为一个流，那么可以使用Stream接口的静态方法concat： static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 备注：这是一个静态方法，与java.lang.String当中的concat方法是不同的。 该方法的基本使用代码如： 123456789import java.util.stream.Stream;public class Demo12StreamConcat &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; streamA = Stream.of(&quot;张无忌&quot;); Stream&lt;String&gt; streamB = Stream.of(&quot;张翠山&quot;); Stream&lt;String&gt; result = Stream.concat(streamA, streamB); &#125;&#125; 收集Stream结果对流操作完成之后，如果需要将其结果进行收集，例如获取对应的集合、数组等，如何操作？ 收集到集合中Stream流提供collect方法，其参数需要一个java.util.stream.Collector&lt;T,A, R&gt;接口对象来指定收集到哪种集合中。幸运的是，java.util.stream.Collectors类提供一些方法，可以作为Collector接口的实例： public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()：转换为List集合。 public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()：转换为Set集合。 下面是这两个方法的基本使用代码： 123456789101112import java.util.List;import java.util.Set;import java.util.stream.Collectors;import java.util.stream.Stream;public class Demo15StreamCollect &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(&quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;, &quot;50&quot;); List&lt;String&gt; list = stream.collect(Collectors.toList()); Set&lt;String&gt; set = stream.collect(Collectors.toSet()); &#125;&#125; 收集到数组中Stream提供toArray方法来将结果放到一个数组中，由于泛型擦除的原因，返回值类型是Object[]的： Object[] toArray(); 其使用场景如： 12345678import java.util.stream.Stream;public class Demo16StreamArray &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(&quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;, &quot;50&quot;); Object[] objArray = stream.toArray(); &#125;&#125;","tags":["Java","JDK8"],"categories":["JavaSE"]},{"title":"(八). 登堂入室 - I/O流","path":"/JavaSE-IO.html","content":"File类java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 构造举例，代码如下： 1234567891011121314151617// 文件路径名String pathname = &quot;D:\\\\aaa.txt&quot;;File file1 = new File(pathname); // 文件路径名String pathname2 = &quot;D:\\\\aaa\\\\bbb.txt&quot;;File file2 = new File(pathname2); // 通过父路径和子路径字符串 String parent = &quot;d:\\\\aaa&quot;; String child = &quot;bbb.txt&quot;; File file3 = new File(parent, child);// 通过父级File对象和子路径字符串File parentDir = new File(&quot;d:\\\\aaa&quot;);String child = &quot;bbb.txt&quot;;File file4 = new File(parentDir, child); 小贴士： 一个File对象代表硬盘中实际存在的一个文件或者目录。 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 常用方法获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。 方法演示，代码如下： 12345678910111213141516171819202122232425public class FileGet &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/aaa/bbb.java&quot;); System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath()); System.out.println(&quot;文件构造路径:&quot;+f.getPath()); System.out.println(&quot;文件名称:&quot;+f.getName()); System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;); File f2 = new File(&quot;d:/aaa&quot;); System.out.println(&quot;目录绝对路径:&quot;+f2.getAbsolutePath()); System.out.println(&quot;目录构造路径:&quot;+f2.getPath()); System.out.println(&quot;目录名称:&quot;+f2.getName()); System.out.println(&quot;目录长度:&quot;+f2.length()); &#125;&#125;输出结果：文件绝对路径:d:\\aaa\\bbb.java文件构造路径:d:\\aaa\\bbb.java文件名称:bbb.java文件长度:636字节目录绝对路径:d:\\aaa目录构造路径:d:\\aaa目录名称:aaa目录长度:4096 API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。 绝对路径和相对路径 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 1234567891011121314public class FilePath &#123; public static void main(String[] args) &#123; // D盘下的bbb.java文件 File f = new File(&quot;D:\\\\bbb.java&quot;); System.out.println(f.getAbsolutePath()); // 项目下的bbb.java文件 File f2 = new File(&quot;bbb.java&quot;); System.out.println(f2.getAbsolutePath()); &#125;&#125;输出结果：D:\\bbb.javaD:\\idea_project_test4\\bbb.java 判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 方法演示，代码如下： 1234567891011121314151617public class FileIs &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:\\\\aaa\\\\bbb.java&quot;); File f2 = new File(&quot;d:\\\\aaa&quot;); // 判断是否存在 System.out.println(&quot;d:\\\\aaa\\\\bbb.java 是否存在:&quot;+f.exists()); System.out.println(&quot;d:\\\\aaa 是否存在:&quot;+f2.exists()); // 判断是文件还是目录 System.out.println(&quot;d:\\\\aaa 文件?:&quot;+f2.isFile()); System.out.println(&quot;d:\\\\aaa 目录?:&quot;+f2.isDirectory()); &#125;&#125;输出结果：d:\\aaa\\bbb.java 是否存在:trued:\\aaa 是否存在:trued:\\aaa 文件?:falsed:\\aaa 目录?:true 创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir() ：创建由此File表示的目录。 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 方法演示，代码如下： 12345678910111213141516171819202122232425262728public class FileCreateDelete &#123; public static void main(String[] args) throws IOException &#123; // 文件的创建 File f = new File(&quot;aaa.txt&quot;); System.out.println(&quot;是否存在:&quot;+f.exists()); // false System.out.println(&quot;是否创建:&quot;+f.createNewFile()); // true System.out.println(&quot;是否存在:&quot;+f.exists()); // true // 目录的创建 File f2= new File(&quot;newDir&quot;); System.out.println(&quot;是否存在:&quot;+f2.exists());// false System.out.println(&quot;是否创建:&quot;+f2.mkdir());\t// true System.out.println(&quot;是否存在:&quot;+f2.exists());// true // 创建多级目录 File f3= new File(&quot;newDira\\ ewDirb&quot;); System.out.println(f3.mkdir());// false File f4= new File(&quot;newDira\\ ewDirb&quot;); System.out.println(f4.mkdirs());// true // 文件的删除 System.out.println(f.delete());// true // 目录的删除 System.out.println(f2.delete());// true System.out.println(f4.delete());// false &#125;&#125; API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 12345678910111213141516public class FileFor &#123; public static void main(String[] args) &#123; File dir = new File(&quot;d:\\\\java_code&quot;); //获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name : names)&#123; System.out.println(name); &#125; //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息 File[] files = dir.listFiles(); for (File file : files) &#123; System.out.println(file); &#125; &#125;&#125; 小贴士： 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 IO概述什么是IO生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了ctrl+s ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。 我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。 Java中I&#x2F;O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。 IO的分类根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 字节流一切皆为字节一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 字节输出流OutputStreamjava.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileOutputStream类OutputStream有很多子类，我们从最简单的一个子类开始。java.io.FileOutputStream 类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 构造举例，代码如下： 12345678910public class FileOutputStreamConstructor throws IOException &#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(&quot;a.txt&quot;); FileOutputStream fos = new FileOutputStream(file); // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;b.txt&quot;); &#125;&#125; 写出字节数据 写出字节：write(int b) 方法，每次可以写出一个字节数据，代码使用演示： 123456789101112131415public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); // 写出数据 fos.write(97); // 写出第1个字节 fos.write(98); // 写出第2个字节 fos.write(99); // 写出第3个字节 // 关闭资源 fos.close(); &#125;&#125;输出结果：abc 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); // 字符串转换为字节数组 byte[] b = &quot;一个程序员&quot;.getBytes(); // 写出字节数组数据 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;输出结果：一个程序员 写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); // 字符串转换为字节数组 byte[] b = &quot;abcde&quot;.getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b,2,2); // 关闭资源 fos.close(); &#125;&#125;输出结果：cd 数据追加续写经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？ public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;，true); // 字符串转换为字节数组 byte[] b = &quot;abcde&quot;.getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;文件操作前：cd文件操作后：cdabcde 写出换行Windows系统里，换行符号是\\r 。把 以指定是否追加续写了，代码使用演示： 123456789101112131415161718192021222324public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); // 定义字节数组 byte[] words = &#123;97,98,99,100,101&#125;; // 遍历数组 for (int i = 0; i &lt; words.length; i++) &#123; // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write(&quot;\\r &quot;.getBytes()); &#125; // 关闭资源 fos.close(); &#125;&#125;输出结果：abcde 回车符\\r和换行符 ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\\r ； Unix系统里，每行结尾只有 换行 ，即 ； Mac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。 字节输入流InputStreamjava.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileInputStream类java.io.FileInputStream 类是文件输入流，从文件中读取字节。 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 构造举例，代码如下： 12345678910public class FileInputStreamConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(&quot;a.txt&quot;); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream(&quot;b.txt&quot;); &#125;&#125; 读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码使用演示： 1234567891011121314151617181920212223242526272829public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 读取数据，返回一个字节 int read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); // 读取到末尾,返回-1 read = fis.read(); System.out.println( read); // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde-1 循环改进读取方式，代码使用演示： 1234567891011121314151617181920public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示： 12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组变成字符串打印 System.out.println(new String(b)); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcded 错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换，所以要通过len ，获取有效的字节，代码使用演示： 12345678910111213141516171819202122public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b，0，len));// len 每次读取的有效字节个数 &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 小贴士： 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 字符输入流Readerjava.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 FileReader类java.io.FileReader 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 构造举例，代码如下： 12345678910public class FileReaderConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File(&quot;a.txt&quot;); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader(&quot;b.txt&quot;); &#125;&#125; 读取字符数据 读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示： 1234567891011121314public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(&quot;read.txt&quot;); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fr.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fr.close(); &#125;&#125; 小贴士：虽然读取了一个字符，但是会自动提升为int类型。 使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示： 12345678910111213141516public class FRRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(&quot;read.txt&quot;); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf)); &#125; // 关闭资源 fr.close(); &#125;&#125; 获取有效的字符改进，代码使用演示： 12345678910111213141516public class FISRead &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileReader fr = new FileReader(&quot;read.txt&quot;); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf,0,len)); &#125; // 关闭资源 fr.close(); &#125;&#125; 字符输出流Writerjava.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public abstract void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public abstract void flush() ：刷新此输出流并强制任何缓冲的输出字符被写出。 public void write(int c) ：写出一个字符。 public void write(char[] cbuf)：将 b.length字符从指定的字符数组写出此输出流。 public abstract void write(char[] b, int off, int len) ：从指定的字符数组写出 len字符，从偏移量 off开始输出到此输出流。 public void write(String str) ：写出一个字符串。 FileWriter类java.io.FileWriter 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。 FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。 构造举例，代码如下： 12345678910public class FileWriterConstructor &#123; public static void main(String[] args) throws IOException &#123; // 使用File对象创建流对象 File file = new File(&quot;a.txt&quot;); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;b.txt&quot;); &#125;&#125; 基本写出数据写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示： 12345678910111213141516171819public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;fw.txt&quot;); // 写出数据 fw.write(97); // 写出第1个字符 fw.write(&#x27;b&#x27;); // 写出第2个字符 fw.write(&#x27;C&#x27;); // 写出第3个字符 fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。 /* 【注意】关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。 */ // fw.close(); &#125;&#125;输出结果：abC田 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。 close ：关闭流，释放系统资源。关闭前会刷新缓冲区。 代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;fw.txt&quot;); // 写出数据，通过flush fw.write(&#x27;刷&#x27;); // 写出第1个字符 fw.flush(); fw.write(&#x27;新&#x27;); // 继续写出第2个字符，写出成功 fw.flush(); // 写出数据，通过close fw.write(&#x27;关&#x27;); // 写出第1个字符 fw.close(); fw.write(&#x27;闭&#x27;); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed fw.close(); &#125;&#125; 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。 写出其他数据 写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;fw.txt&quot;); // 字符串转换为字节数组 char[] chars = &quot;一个程序员&quot;.toCharArray(); // 写出字符数组 fw.write(chars); // 一个程序员 // 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。 fw.write(b,2,2); // 程序 // 关闭资源 fos.close(); &#125;&#125; 写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，代码使用演示： 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;fw.txt&quot;); // 字符串 String msg = &quot;一个程序员&quot;; // 写出字符数组 fw.write(msg); //一个程序员 // 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。 fw.write(msg,2,2);\t// 程序 // 关闭资源 fos.close(); &#125;&#125; 续写和换行：操作类似于FileOutputStream。 1234567891011121314151617public class FWWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象，可以续写数据 FileWriter fw = new FileWriter(&quot;fw.txt&quot;，true); // 写出字符串 fw.write(&quot;一个&quot;); // 写出换行 fw.write(&quot;\\r &quot;); // 写出字符串 fw.write(&quot;程序员&quot;); // 关闭资源 fw.close(); &#125;&#125;输出结果:一个程序员 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流 IO资源的处理JDK7前处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用try...catch...finally 代码块，处理异常部分，代码使用演示： 12345678910111213141516171819202122public class HandleException1 &#123; public static void main(String[] args) &#123; // 声明变量 FileWriter fw = null; try &#123; //创建流对象 fw = new FileWriter(&quot;fw.txt&quot;); // 写出数据 fw.write(&quot;一个程序员&quot;); //一个程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fw != null) &#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDK7的处理还可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。 格式： try (创建流对象语句，如果多个,使用&#x27;;&#x27;隔开) &#123;\t// 读写数据&#125; catch (IOException e) &#123;\te.printStackTrace();&#125; 代码使用演示： 1234567891011public class HandleException2 &#123; public static void main(String[] args) &#123; // 创建流对象 try ( FileWriter fw = new FileWriter(&quot;fw.txt&quot;); ) &#123; // 写出数据 fw.write(&quot;一个程序员&quot;); //一个程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 属性集概述java.util.Properties 继承于 Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 Properties类构造方法 public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 12345678910111213141516171819202122232425262728293031public class ProDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties properties = new Properties(); // 添加键值对元素 properties.setProperty(&quot;filename&quot;, &quot;a.txt&quot;); properties.setProperty(&quot;length&quot;, &quot;209385038&quot;); properties.setProperty(&quot;location&quot;, &quot;D:\\\\a.txt&quot;); // 打印属性集对象 System.out.println(properties); // 通过键,获取属性值 System.out.println(properties.getProperty(&quot;filename&quot;)); System.out.println(properties.getProperty(&quot;length&quot;)); System.out.println(properties.getProperty(&quot;location&quot;)); // 遍历属性集,获取所有键的集合 Set&lt;String&gt; strings = properties.stringPropertyNames(); // 打印键值对 for (String key : strings ) &#123; System.out.println(key+&quot; -- &quot;+properties.getProperty(key)); &#125; &#125;&#125;输出结果：&#123;filename=a.txt, length=209385038, location=D:\\a.txt&#125;a.txt209385038D:\\a.txtfilename -- a.txtlength -- 209385038location -- D:\\a.txt 与流相关的方法 public void load(InputStream inStream)： 从字节输入流中读取键值对。 参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式: filename=a.txtlength=209385038location=D:\\a.txt 加载代码演示： 1234567891011121314151617public class ProDemo2 &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 创建属性集对象 Properties pro = new Properties(); // 加载文本中信息到属性集 pro.load(new FileInputStream(&quot;read.txt&quot;)); // 遍历集合并打印 Set&lt;String&gt; strings = pro.stringPropertyNames(); for (String key : strings ) &#123; System.out.println(key+&quot; -- &quot;+pro.getProperty(key)); &#125; &#125;&#125;输出结果：filename -- a.txtlength -- 209385038location -- D:\\a.txt 小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。 缓冲流昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。 概述缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类： 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。 字节缓冲流构造方法 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 构造举例，代码如下： // 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;bis.txt&quot;));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;)); 效率测试查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。 基本流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( FileInputStream fis = new FileInputStream(&quot;jdk8.exe&quot;); FileOutputStream fos = new FileOutputStream(&quot;copy.exe&quot;) )&#123; // 读写数据 int b; while ((b = fis.read()) != -1) &#123; fos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;十几分钟过去了... 缓冲流，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk8.exe&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;)); )&#123; // 读写数据 int b; while ((b = bis.read()) != -1) &#123; bos.write(b); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;缓冲流复制时间:8016 毫秒 如何更快呢？ 使用数组的方式，代码如下： 123456789101112131415161718192021222324public class BufferedDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;jdk8.exe&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;copy.exe&quot;)); )&#123; // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;); &#125;&#125;缓冲流使用数组复制时间:666 毫秒 字符缓冲流构造方法 public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。 构造举例，代码如下： // 创建字符缓冲输入流BufferedReader br = new BufferedReader(new FileReader(&quot;br.txt&quot;));// 创建字符缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bw.txt&quot;)); 特有方法字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 readLine方法演示，代码如下： 123456789101112131415public class BufferedReaderDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;in.txt&quot;)); // 定义字符串,保存读取的一行文字 String line = null; // 循环读取,读取到最后返回null while ((line = br.readLine())!=null) &#123; System.out.print(line); System.out.println(&quot;------&quot;); &#125; // 释放资源 br.close(); &#125;&#125; newLine方法演示，代码如下： 1234567891011121314151617181920public class BufferedWriterDemo throws IOException &#123; public static void main(String[] args) throws IOException &#123; // 创建流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;out.txt&quot;)); // 写出数据 bw.write(&quot;一个&quot;); // 写出换行 bw.newLine(); bw.write(&quot;程序&quot;); bw.newLine(); bw.write(&quot;员&quot;); bw.newLine(); // 释放资源 bw.close(); &#125;&#125;输出效果:一个程序员 转换流字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本f符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 字符集 **字符集 Charset**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-5559-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 123456789101112public class ReaderDemo &#123; public static void main(String[] args) throws IOException &#123; FileReader fileReader = new FileReader(&quot;E:\\\\File_GBK.txt&quot;); int read; while ((read = fileReader.read()) != -1) &#123; System.out.print((char)read); &#125; fileReader.close(); &#125;&#125;输出结果：��� 那么如何读取GBK编码的文件呢？ InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));InputStreamReader isr2 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;); 指定编码读取12345678910111213141516171819202122232425public class ReaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径,文件为gbk编码 String FileName = &quot;E:\\\\file_gbk.txt&quot;; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , &quot;GBK&quot;); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); &#125;&#125; OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;));OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;out.txt&quot;) , &quot;GBK&quot;); 指定编码写出12345678910111213141516171819public class OutputDemo &#123; public static void main(String[] args) throws IOException &#123; // 定义文件路径 String FileName = &quot;E:\\\\out.txt&quot;; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write(&quot;你好&quot;); // 保存为6个字节 osw.close(); // 定义文件路径 String FileName2 = &quot;E:\\\\out2.txt&quot;; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),&quot;GBK&quot;); // 写出数据 osw2.write(&quot;你好&quot;);// 保存为4个字节 osw2.close(); &#125;&#125; 序列化概述​ Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 ​ 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out) ： 创建一个指定OutputStream的ObjectOutputStream。 构造举例，代码如下： FileOutputStream fileOut = new FileOutputStream(&quot;employee.txt&quot;);ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 12345678public class Employee implements java.io.Serializable &#123; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() &#123; System.out.println(&quot;Address check : &quot; + name + &quot; -- &quot; + address); &#125;&#125; 2.写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 12345678910111213141516171819202122public class SerializeDemo&#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = &quot;zhangsan&quot;; e.address = &quot;beiqinglu&quot;; e.age = 20; try &#123; // 创建序列化流对象 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;employee.txt&quot;)); // 写出对象 out.writeObject(e); // 释放资源 out.close(); fileOut.close(); System.out.println(&quot;Serialized data is saved&quot;); // 姓名，地址被序列化，年龄没有被序列化。 &#125; catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125;输出结果：Serialized data is saved ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 12345678910111213141516171819202122232425262728public class DeserializeDemo &#123; public static void main(String [] args) &#123; Employee e = null; try &#123; // 创建反序列化流 FileInputStream fileIn = new FileInputStream(&quot;employee.txt&quot;); ObjectInputStream in = new ObjectInputStream(fileIn); // 读取一个对象 e = (Employee) in.readObject(); // 释放资源 in.close(); fileIn.close(); &#125;catch(IOException i) &#123; // 捕获其他异常 i.printStackTrace(); return; &#125;catch(ClassNotFoundException c) &#123; // 捕获类找不到异常 System.out.println(&quot;Employee class not found&quot;); c.printStackTrace(); return; &#125; // 无异常,直接打印输出 System.out.println(&quot;Name: &quot; + e.name);\t// zhangsan System.out.println(&quot;Address: &quot; + e.address); // beiqinglu System.out.println(&quot;age: &quot; + e.age); // 0 &#125;&#125; 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 反序列化操作2另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。 发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 123456789101112public class Employee implements java.io.Serializable &#123; // 加入序列版本号 private static final long serialVersionUID = 1L; public String name; public String address; // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值. public int eid; public void addressCheck() &#123; System.out.println(&quot;Address check : &quot; + name + &quot; -- &quot; + address); &#125;&#125; 打印流概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 PrintStream类 public PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。 构造举例，代码如下： PrintStream ps = new PrintStream(&quot;ps.txt&quot;)； System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，将数据输出到指定文本文件中。 1234567891011121314public class PrintDemo &#123; public static void main(String[] args) throws IOException &#123; // 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream(&quot;ps.txt&quot;); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); &#125;&#125;","tags":["Java","I/O流"],"categories":["JavaSE"]},{"title":"(七). 登堂入室- 多线程","path":"/JavaSE-Thread.html","content":"多线程并发与并行 并行：指两个或多个事件在同一时刻发生（同时执行）。 并发：指两个或多个事件在同一个时间段内发生(交替执行)。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 进程与线程的区别 进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。 线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。 因为一个进程中的多个线程是并发运行的，那么从微观角度看也是有先后顺序的，哪个线程执行完全取决于 CPU 的调度，程序员是干涉不了的。而这也就造成的多线程的随机性。 Java 程序的进程里面至少包含两个线程，主进程也就是 main()方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，每一个 JVM 实际上就是在操作系统中启动了一个线程，java 本身具备了垃圾的收集机制，所以在 Java 运行时至少会启动两个线程。 由于创建一个线程的开销比创建一个进程的开销小的多，那么我们在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。 线程调度: 分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 Thread类线程开启我们需要用到了java.lang.Thread类，API中该类中定义了有关线程的一些方法，具体如下： 构造方法： public Thread():分配一个新的线程对象。 public Thread(String name):分配一个指定名字的新的线程对象。 public Thread(Runnable target):分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName():获取当前线程名称。 public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run():此线程要执行的任务在此处定义代码。 public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread() :返回对当前正在执行的线程对象的引用。 翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式 继承方式Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 测试类： 123456789101112public class Demo01 &#123;\tpublic static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread(&quot;新的线程！&quot;); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 200; i++) &#123; System.out.println(&quot;main线程！&quot;+i); &#125;\t&#125;&#125; 自定义线程类： 12345678910111213141516171819public class MyThread extends Thread &#123;\t//定义指定线程名称的构造方法\tpublic MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name);\t&#125; public MyThread() &#123; //不指定线程的名字,线程有默认的名字Thread-0\t&#125;\t/** * 重写run方法，完成该线程执行的逻辑 */\t@Override\tpublic void run() &#123; for (int i = 0; i &lt; 200; i++) &#123; System.out.println(getName()+&quot;：正在执行！&quot;+i); &#125;\t&#125;&#125; 实现方式采用java.lang.Runnable也是非常常见的一种，我们只需要重写run方法即可。 步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动线程。 代码如下： 12345678public class MyRunnable implements Runnable&#123;\t@Override\tpublic void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); &#125;\t&#125;&#125; 123456789101112public class Demo &#123; public static void main(String[] args) &#123; //创建自定义类对象 线程任务对象 MyRunnable mr = new MyRunnable(); //创建线程对象 Thread t = new Thread(mr, &quot;小强&quot;); t.start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;旺财 &quot; + i); &#125; &#125;&#125; 通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程。 匿名内部类方式使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。 使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法： 1234567891011121314151617181920212223public class NoNameInnerClassThread &#123; public static void main(String[] args) &#123; // new Runnable()&#123;// public void run()&#123;// for (int i = 0; i &lt; 20; i++) &#123;// System.out.println(&quot;张宇:&quot;+i);// &#125;// &#125; // &#125;; //---这个整体 相当于new MyRunnable() Runnable r = new Runnable()&#123; public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;张宇:&quot;+i); &#125; &#125; &#125;; new Thread(r).start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;费玉清:&quot;+i); &#125; &#125;&#125; 线程安全线程安全如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 我们通过一个案例，演示线程的安全问题： 电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个(本场电影只能卖100张票)。 我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票) 需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟。 模拟票： 1234567891011121314151617181920212223242526public class Ticket implements Runnable &#123; private int ticket = 100; /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while (true) &#123; if (ticket &gt; 0) &#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name + &quot;正在卖:&quot; + ticket--); &#125; &#125; &#125;&#125; 测试类： 123456789101112131415public class Demo &#123;\tpublic static void main(String[] args) &#123; //创建线程任务对象 Ticket ticket = new Ticket(); //创建三个窗口对象 Thread t1 = new Thread(ticket, &quot;窗口1&quot;); Thread t2 = new Thread(ticket, &quot;窗口2&quot;); Thread t3 = new Thread(ticket, &quot;窗口3&quot;); //同时卖票 t1.start(); t2.start(); t3.start();\t&#125;&#125; 发现程序出现了两个问题： 相同的票数,比如5这张票被卖了两回。 不存在的票，比如0票与-1票，是不存在的。 这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步线程同步是为了解决线程安全问题。当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。 根据案例简述：窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。 为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。 同步代码块。 同步方法。 锁机制。 同步代码块 同步代码块：synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式: synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步锁: 对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 锁对象 可以是任意类型。 多个线程对象 要使用同一把锁。 注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。 使用同步代码块解决代码： 123456789101112131415161718192021222324252627282930public class Ticket implements Runnable&#123;\tprivate int ticket = 100; Object lock = new Object();\t/* * 执行卖票操作 */\t@Override\tpublic void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; synchronized (lock) &#123; if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+&quot;正在卖:&quot;+ticket--); &#125; &#125; &#125;\t&#125;&#125; 当使用了同步代码块后，上述的线程的安全问题，解决了。 同步方法 同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。 格式： public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; 同步锁是谁?​ 对于非static方法,同步锁就是this。​ 对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 使用同步方法代码如下： 1234567891011121314151617181920212223242526272829303132333435public class Ticket implements Runnable&#123;\tprivate int ticket = 100;\t/* * 执行卖票操作 */\t@Override\tpublic void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; sellTicket(); &#125;\t&#125; /* * 锁对象 是 谁调用这个方法 就是谁 * 隐含 锁对象 就是 this * */\tpublic synchronized void sellTicket()&#123; if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+&quot;正在卖:&quot;+ticket--); &#125;\t&#125;&#125; Lock锁java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块&#x2F;同步方法具有的功能Lock都有,除此之外更强大 Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock() :加同步锁。 public void unlock():释放同步锁。 使用如下： 123456789101112131415161718192021222324252627282930public class Ticket implements Runnable&#123;\tprivate int ticket = 100; Lock lock = new ReentrantLock();\t/* * 执行卖票操作 */\t@Override\tpublic void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; lock.lock(); if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+&quot;正在卖:&quot;+ticket--); &#125; lock.unlock(); &#125;\t&#125;&#125; 线程状态线程状态概述当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中java.lang.Thread.State这个枚举中给出了六种线程状态： 这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。MyThread t &#x3D; new MyThread只有线程对象，没有线程特征。 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。调用了t.start()方法 ：就绪（经典教法） Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 ​\t我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题。 睡眠sleep方法我们看到状态中有一个状态叫做计时等待，可以通过Thread类的方法来进行演示.public static void sleep(long time) 让当前线程进入到睡眠状态，到毫秒后自动醒来继续执行 12345678public class Test&#123; public static void main(String[] args)&#123; for(int i = 1;i&lt;=5;i++)&#123; Thread.sleep(1000); System.out.println(i) &#125; &#125;&#125; 这时我们发现主线程执行到sleep方法会休眠1秒后再继续执行。 等待和唤醒Object类的方法 public void wait() : 让当前线程进入到等待状态 此方法必须锁对象调用. 123456789101112131415public class Demo1_wait &#123; public static void main(String[] args) throws InterruptedException &#123; // 步骤1 : 子线程开启,进入无限等待状态, 没有被唤醒,无法继续运行. new Thread(() -&gt; &#123; try &#123; System.out.println(&quot;begin wait ....&quot;); synchronized (&quot;&quot;) &#123; &quot;&quot;.wait(); &#125; System.out.println(&quot;over&quot;); &#125; catch (Exception e) &#123; &#125; &#125;).start(); &#125; public void notify() : 唤醒当前锁对象上等待状态的线程 此方法必须锁对象调用. 12345678910111213141516171819202122232425262728public class Demo2_notify &#123; public static void main(String[] args) throws InterruptedException &#123; // 步骤1 : 子线程开启,进入无限等待状态, 没有被唤醒,无法继续运行. new Thread(() -&gt; &#123; try &#123; System.out.println(&quot;begin wait ....&quot;); synchronized (&quot;&quot;) &#123; &quot;&quot;.wait(); &#125; System.out.println(&quot;over&quot;); &#125; catch (Exception e) &#123; &#125; &#125;).start(); //步骤2: 加入如下代码后, 3秒后,会执行notify方法, 唤醒wait中线程. Thread.sleep(3000); new Thread(() -&gt; &#123; try &#123; synchronized (&quot;&quot;) &#123; System.out.println(&quot;唤醒&quot;); &quot;&quot;.notify(); &#125; &#125; catch (Exception e) &#123; &#125; &#125;).start(); &#125;&#125; volatile关键字看程序说结果1234567891011121314151617181920212223242526272829303132333435363738public class VolatileThread extends Thread &#123; // 定义成员变量 private boolean flag = false ; public boolean isFlag() &#123; return flag;&#125; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 将flag的值更改为true this.flag = true ; System.out.println(&quot;flag=&quot; + flag); &#125;&#125;public class VolatileThreadDemo &#123;// 测试类 public static void main(String[] args) &#123; // 创建VolatileThread线程对象 VolatileThread volatileThread = new VolatileThread() ; volatileThread.start(); // main方法 while(true) &#123; if(volatileThread.isFlag()) &#123; System.out.println(&quot;执行了======&quot;); &#125; &#125; &#125;&#125; VolatileThread线程中已经将flag设置为true，但main()方法中始终没有读到，从而没有打印。 JMM概述：JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。 Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。 所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。每一个线程还存在自己的工作内存，线程 的工作内存，保留了被线程使用的变量的工作副本。线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问 对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。 问题分析 VolatileThread线程从主内存读取到数据放入其对应的工作内存 将flag的值更改为true，但是这个时候flag的值还没有写会主内存 此时main方法读取到了flag的值为false 当VolatileThread线程将flag的值写回去后，但是main函数里面的while(true)调用的是系统比较底层的代码，速度快，快到没有时间再去读取主存中的值， 所以while(true)读取到的值一直是false。(如果有一个时刻main线程从主内存中读取到了主内存中flag的最新值，那么if语句就可以执行，main线程何时从主内存中读取最新的值，我们无法控制) 问题处理加锁12345678// main方法while(true) &#123; synchronized (volatileThread) &#123; if(volatileThread.isFlag()) &#123; System.out.println(&quot;执行了======&quot;); &#125; &#125;&#125; 某一个线程进入synchronized代码块前后，执行过程入如下： 线程获得锁 清空工作内存 从主内存拷贝共享变量最新的值到工作内存成为副本 执行代码 将修改后的副本的值刷新回主内存中 线程释放锁 volatile关键字使用volatile关键字： private volatile boolean flag ; VolatileThread线程从主内存读取到数据放入其对应的工作内存 将flag的值更改为true，但是这个时候flag的值还没有写会主内存 此时main方法main方法读取到了flag的值为false 当VolatileThread线程将flag的值写回去后，失效其他线程对此变量副本 再次对flag进行操作的时候线程会从主内存读取最新的值，放入到工作内存中 总结： volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。但是volatile不保证原子性。 volatile与synchronized volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。 volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他（互斥）的机制， 原子性概述：所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。 看程序说结果12345678910111213141516171819202122232425262728293031public class VolatileAtomicThread implements Runnable &#123; // 定义一个int类型的遍历 private int count = 0 ; @Override public void run() &#123; // 对该变量进行++操作，100次 for(int x = 0 ; x &lt; 100 ; x++) &#123; count++ ; System.out.println(&quot;count =========&gt;&gt;&gt;&gt; &quot; + count); &#125; &#125;&#125;public class VolatileAtomicThreadDemo &#123; public static void main(String[] args) &#123; // 创建VolatileAtomicThread对象 VolatileAtomicThread volatileAtomicThread = new VolatileAtomicThread() ; // 开启100个线程对count进行++操作 for(int x = 0 ; x &lt; 100 ; x++) &#123; new Thread(volatileAtomicThread).start(); &#125; &#125;&#125; 执行结果：不保证一定是10000 问题原理说明以上问题主要是发生在count++操作上： 从主内存中读取数据到工作内存 对工作内存中的数据进行++操作 将工作内存中的数据写回到主内存 count++操作不是一个原子性操作，也就是说在某一个时刻对某一个操作的执行，有可能被其他的线程打断。 假设此时x的值是100，线程A需要对改变量进行自增1的操作，首先它需要从主内存中读取变量x的值。由于CPU的切换关系，此时CPU的执行权被切换到了B线程。A线程就处于就绪状态，B线程处于运行状态 线程B也需要从主内存中读取x变量的值,由于线程A没有对x值做任何修改因此此时B读取到的数据还是100 线程B工作内存中x执行了+1操作，但是未刷新之主内存中 此时CPU的执行权切换到了A线程上，由于此时线程B没有将工作内存中的数据刷新到主内存，因此A线程工作内存中的变量值还是100，没有失效。A线程对工作内存中的数据进行了+1操作 线程B将101写入到主内存 线程A将101写入到主内存，虽然计算了2次，但是只对A进行了1次修改。 volatile原子性测试代码测试// 定义一个int类型的变量private volatile int count = 0 ; 小结：在多线程环境下，volatile关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性（在多线程环境下volatile修饰的变量也是线程不安全的）。 在多线程环境下，要保证数据的安全性，我们还需要使用锁机制。 volatile的使用场景 开关控制：利用可见性特点，控制某一段代码执行或者关闭(比如今天课程的第一个案例)。 多个线程操作共享变量，但是是有一个线程对其进行写操作，其他的线程都是读 问题解决使用锁机制我们可以给count++操作添加锁，那么count++操作就是临界区的代码，临界区只能有一个线程去执行，所以count++就变成了原子操作。 123456789101112131415161718public class VolatileAtomicThread implements Runnable &#123; // 定义一个int类型的变量 private volatile int count = 0 ; private static final Object obj = new Object(); @Override public void run() &#123; // 对该变量进行++操作，100次 for(int x = 0 ; x &lt; 100 ; x++) &#123; synchronized (obj) &#123; count++ ; System.out.println(&quot;count =========&gt;&gt;&gt;&gt; &quot; + count); &#125; &#125; &#125;&#125; 原子类概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。 原子型Integer，可以实现原子更新操作 12345678public AtomicInteger()： 初始化一个默认值为0的原子型Integerpublic AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integerint get(): 获取值int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。int addAndGet(int data): 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 原子类CAS机制实现线程安全。CAS的全成是： Compare And Swap(比较再交换); 是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。CAS可以将read-modify-check-write 转换为原子操作，这个原子操作直接由处理器保证。 CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。 CAS与Synchronized：乐观锁，悲观锁。CAS和Synchronized都可以保证多线程环境下共享数据的安全性。那么他们两者有什么区别？ Synchronized是从悲观的角度出发（悲观锁） 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁 （共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。因此Synchronized我们也将其称之为悲观锁。jdk中的ReentrantLock也是一种悲观锁。性能较差！！ CAS是从乐观的角度出发: 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。 CAS这种机制我们也可以将其称之为乐观锁。综合性能较好！ 并发包在JDK的并发包里提供了几个非常有用的并发容器和并发工具类。供我们在多线程开发中进行使用。 ConcurrentHashMap为什么要使用ConcurrentHashMap： HashMap线程不安全，会导致数据错乱 使用线程安全的Hashtable效率低下 基于以上两个原因，便有了ConcurrentHashMap的登场机会。 HashMap线程不安全演示。 公有、静态的集合： public class Const &#123;\tpublic static HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();&#125; 线程，向map中写入数据： 123456public void run() &#123; for (int i = 0; i &lt; 500000; i++) &#123; Const.map.put(this.getName() + (i + 1), this.getName() + i + 1); &#125; System.out.println(this.getName() + &quot; 结束！&quot;);\t&#125; 测试类： 123456789101112131415public class Demo &#123;\tpublic static void main(String[] args) throws InterruptedException &#123; Thread1A a1 = new Thread1A(); Thread1A a2 = new Thread1A(); a1.setName(&quot;线程1-&quot;); a2.setName(&quot;线程2-&quot;); a1.start(); a2.start(); //休息10秒，确保两个线程执行完毕 Thread.sleep(1000 * 5); //打印集合大小 System.out.println(&quot;Map大小：&quot; + Const.map.size());\t&#125;&#125; 说明：两个线程分别向同一个map中写入50000个键值对，最后map的size应为：100000，但多运行几次会发现有以下几种错误： 假死 异常 错误 为了保证线程安全，可以使用Hashtable。注意：线程中加入了计时 公有、静态的集合： public class Const &#123;\tpublic static Hashtable&lt;String,String&gt; map = new Hashtable&lt;&gt;();&#125; 线程，向map中写入数据： 12345678public void run() &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 500000; i++) &#123; Const.map.put(this.getName() + (i + 1), this.getName() + i + 1); &#125; long end = System.currentTimeMillis(); System.out.println(this.getName() + &quot; 结束！用时：&quot; + (end - start) + &quot; 毫秒&quot;);\t&#125; 测试类： 123456789101112131415public class Demo &#123;\tpublic static void main(String[] args) throws InterruptedException &#123; Thread1A a1 = new Thread1A(); Thread1A a2 = new Thread1A(); a1.setName(&quot;线程1-&quot;); a2.setName(&quot;线程2-&quot;); a1.start(); a2.start(); //休息10秒，确保两个线程执行完毕 Thread.sleep(1000 * 5); //打印集合大小 System.out.println(&quot;Map大小：&quot; + Const.map.size());\t&#125;&#125; Hashtable保证的线程安全，时间是2秒多。 再看ConcurrentHashMap 公有、静态的集合： public class Const &#123;\tpublic static ConcurrentHashMap&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();&#125; 线程，向map中写入数据： 12345678public void run() &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 500000; i++) &#123; Const.map.put(this.getName() + (i + 1), this.getName() + i + 1); &#125; long end = System.currentTimeMillis(); System.out.println(this.getName() + &quot; 结束！用时：&quot; + (end - start) + &quot; 毫秒&quot;);\t&#125; 测试类： 123456789101112131415public class Demo &#123;\tpublic static void main(String[] args) throws InterruptedException &#123; Thread1A a1 = new Thread1A(); Thread1A a2 = new Thread1A(); a1.setName(&quot;线程1-&quot;); a2.setName(&quot;线程2-&quot;); a1.start(); a2.start(); //休息10秒，确保两个线程执行完毕 Thread.sleep(1000 * 5); //打印集合大小 System.out.println(&quot;Map大小：&quot; + Const.map.size());\t&#125;&#125; ConcurrentHashMap仍能保证结果正确，而且提高了效率。 HashTable效率低下原因： public synchronized V put(K key, V value) public synchronized V get(Object key) HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。 ConcurrentHashMap高效的原因：CAS + 局部(synchronized)锁定分段式锁 CountDownLatchCountDownLatch允许一个或多个线程等待其他线程完成操作，再执行自己。 例如：线程1要执行打印：A和C，线程2要执行打印：B，但线程1在打印A后，要线程2打印B之后才能打印C，所以：线程1在打印A后，必须等待线程2打印完B之后才能继续执行。 CountDownLatch构造方法: public CountDownLatch(int count)// 初始化一个指定计数器的CountDownLatch对象 CountDownLatch重要方法: public void await() throws InterruptedException// 让当前线程等待public void countDown()\t// 计数器进行减1 CountDownLatch中count down是倒数的意思，latch则是门闩的含义。整体含义可以理解为倒数的门栓，似乎有一点“三二一，芝麻开门”的感觉。 CountDownLatch是通过一个计数器来实现的，每当一个线程完成了自己的任务后，可以调用countDown()方法让计数器-1，当计数器到达0时，调用CountDownLatch。 await()方法的线程阻塞状态解除，继续执行。 CyclicBarrierCyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 例如：公司召集5名员工开会，等5名员工都到了，会议开始。 我们创建5个员工线程，1个开会线程，几乎同时启动，使用CyclicBarrier保证5名员工线程全部执行后，再执行开会线程。 CyclicBarrier构造方法： public CyclicBarrier(int parties, Runnable barrierAction)// 用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景 CyclicBarrier重要方法： public int await()// 每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞 使用场景：CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。 需求：使用两个线程读取2个文件中的数据，当两个文件中的数据都读取完毕以后，进行数据的汇总操作。 SemaphoreSemaphore（发信号）的主要作用是控制线程的并发数量。synchronized可以起到”锁”的作用，但某个时间段内，只能有一个线程允许执行。Semaphore可以设置同时允许几个线程执行。Semaphore字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目。Semaphore构造方法： public Semaphore(int permits) permits 表示许可线程的数量public Semaphore(int permits, boolean fair) fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线程 Semaphore重要方法： public void acquire() throws InterruptedException\t表示获取许可public void release() release() 表示释放许可 Exchanger概述Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。 这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。 Exchanger构造方法： public Exchanger() Exchanger重要方法： public V exchange(V x) 使用场景：可以做数据校对工作 需求：比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水。为了避免错误，采用AB岗两人进行录入，录入到两个文件中，系统需要加载这两个文件， 并对两个文件数据进行校对，看看是否录入一致， 线程池线程池的思想我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题： 如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间，线程也属于宝贵的系统资源。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。 线程池概念 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理： 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 线程池的使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。 Executors类中有个创建线程池的方法如下： public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量) 获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。 使用线程池中线程对象的步骤： 创建线程池对象。 创建Runnable接口子类对象。(task) 提交Runnable接口子类对象。(take task) 关闭线程池(一般不做)。 Runnable实现类代码： 12345678910111213public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;我要一个教练&quot;); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;教练来了： &quot; + Thread.currentThread().getName()); System.out.println(&quot;教我游泳,交完后，教练回到了游泳池&quot;); &#125;&#125; 线程池测试类： 12345678910111213141516171819202122public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 // 创建Runnable实例对象 MyRunnable r = new MyRunnable(); //自己创建线程对象的方式 // Thread t = new Thread(r); // t.start(); ---&gt; 调用MyRunnable中的run() // 从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(r); // 再获取个线程对象，调用MyRunnable中的run() service.submit(r); service.submit(r); // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。 // 将使用完的线程又归还到了线程池中 // 关闭线程池 //service.shutdown(); &#125;&#125; Callable测试代码: &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) : 获取线程池中的某一个线程对象，并执行.Future : 表示计算的结果. V get() : 获取计算完成的结果。 12345678910111213141516171819202122232425public class ThreadPoolDemo2 &#123; public static void main(String[] args) throws Exception &#123; // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 // 创建Runnable实例对象 Callable&lt;Double&gt; c = new Callable&lt;Double&gt;() &#123; @Override public Double call() throws Exception &#123; return Math.random(); &#125; &#125;; // 从线程池中获取线程对象,然后调用Callable中的call() Future&lt;Double&gt; f1 = service.submit(c); // Futur 调用get() 获取运算结果 System.out.println(f1.get()); Future&lt;Double&gt; f2 = service.submit(c); System.out.println(f2.get()); Future&lt;Double&gt; f3 = service.submit(c); System.out.println(f3.get()); &#125;&#125; 死锁在多线程程序中,使用了多把锁,造成线程之间相互等待.程序不往下走了。 死锁的条件1.有多把锁2.有多个线程3.有同步代码块嵌套 死锁代码123456789101112131415161718192021222324252627282930313233343536public class Demo05 &#123; public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); new Thread(mr).start(); new Thread(mr).start(); &#125;&#125;class MyRunnable implements Runnable &#123; Object objA = new Object(); Object objB = new Object(); /* 嵌套1 objA 嵌套1 objB 嵌套2 objB 嵌套1 objA */ @Override public void run() &#123; synchronized (objA) &#123; System.out.println(&quot;嵌套1 objA&quot;); synchronized (objB) &#123;// t2, objA, 拿不到B锁,等待 System.out.println(&quot;嵌套1 objB&quot;); &#125; &#125; synchronized (objB) &#123; System.out.println(&quot;嵌套2 objB&quot;); synchronized (objA) &#123;// t1 , objB, 拿不到A锁,等待 System.out.println(&quot;嵌套2 objA&quot;); &#125; &#125; &#125;&#125; 注意:我们应该尽量避免死锁","tags":["Java","多线程"],"categories":["JavaSE"]},{"title":"(六). 登堂入室 - 异常处理","path":"/JavaSE-Exception.html","content":"异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 throw new 异常类名(参数); 例如： throw new NullPointerException(&quot;要访问的arr数组不存在&quot;);throw new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;); 演示throw的使用。 123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(&quot;over&quot;); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(&quot;哥们，角标越界了```&quot;); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 Objects非空判断Objects由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，将对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。查看源码发现这里对为null的进行了抛出异常操作： public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read(&quot;a.txt&quot;); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(&quot;b.txt&quot;); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println(&quot;over&quot;); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 在开发中呢也可以在catch将编译期异常转换成运行期异常处理。 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件&#x2F;网络连接&#x2F;数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(&quot;a.txt&quot;); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(&quot;不管程序怎样，这里都将会被执行。&quot;); &#125; System.out.println(&quot;over&quot;); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 异常注意事项 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 当多异常处理时，捕获处理，前边的类不能是后边类的父类 在try&#x2F;catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。 自定义异常为什么需要自定义异常类: Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类.自定义一个业务逻辑异常: LoginException。一个登陆异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。","tags":["Java","异常处理"],"categories":["JavaSE"]},{"title":"(五). 渐入佳境 - 常用集合","path":"/JavaSE-Collections.html","content":"Collection集合概述集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有什么区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储任意类型数据。集合存储的都是引用数据类型。如果想存储基本类型数据需要存储对应的包装类型。 继承体系Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.LinkedHashSet。 常用APICollection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(Object obj): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中 Iterator迭代器 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add(&quot;串串星人&quot;); coll.add(&quot;吐槽星人&quot;); coll.add(&quot;汪星人&quot;); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips: 在进行集合元素获取时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会抛出java.util.NoSuchElementException没有集合元素异常。 在进行集合元素获取时，如果添加或移除集合中的元素 , 将无法继续迭代 , 将会抛出ConcurrentModificationException并发修改异常. 实现原理我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 List接口java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。 LinkedList集合java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。 public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class Demo04LinkedList &#123;\tpublic static void main(String[] args) &#123; method4();\t&#125;\t/* * void push(E e)： 压入。把元素添加到集合的第一个位置。 * E pop()： 弹出。把第一个元素删除，然后返回这个元素。 */\tpublic static void method4() &#123; //创建LinkedList对象 LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加元素 list.add(&quot;达尔文&quot;); list.add(&quot;达芬奇&quot;); list.add(&quot;达尔优&quot;); System.out.println(&quot;list:&quot; + list); //调用push在集合的第一个位置添加元素 //list.push(&quot;爱迪生&quot;); //System.out.println(&quot;list:&quot; + list);//[爱迪生, 达尔文, 达芬奇, 达尔优] //E pop()： 弹出。把第一个元素删除，然后返回这个元素。 String value = list.pop(); System.out.println(&quot;value:&quot; + value);//达尔文 System.out.println(&quot;list:&quot; + list);//[达芬奇，达尔优]\t&#125; /* * E removeFirst()：删除第一个元素 * E removeLast()：删除最后一个元素。 */\tpublic static void method3() &#123; //创建LinkedList对象 LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加元素 list.add(&quot;达尔文&quot;); list.add(&quot;达芬奇&quot;); list.add(&quot;达尔优&quot;); //删除集合的第一个元素// String value = list.removeFirst();// System.out.println(&quot;value:&quot; + value);//达尔文// System.out.println(&quot;list:&quot; + list);//[达芬奇，达尔优] //删除最后一个元素 String value = list.removeLast(); System.out.println(&quot;value:&quot; + value);//达尔优 System.out.println(&quot;list:&quot; + list);//[达尔文， 达芬奇]\t&#125; /* * E getFirst()： 获取集合中的第一个元素 * E getLast()： 获取集合中的最后一个元素 */\tpublic static void method2() &#123; //创建LinkedList对象 LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加元素 list.add(&quot;达尔文&quot;); list.add(&quot;达芬奇&quot;); list.add(&quot;达尔优&quot;); System.out.println(&quot;list:&quot; + list); //获取集合中的第一个元素 System.out.println(&quot;第一个元素是：&quot; + list.getFirst()); //获取集合中的最后一个元素怒 System.out.println(&quot;最后一个元素是：&quot; + list.getLast());\t&#125; /* * void addFirst(E e)： 在集合的开头位置添加元素。 * void addLast(E e)： 在集合的尾部添加元素。 */\tpublic static void method1() &#123; //创建LinkedList对象 LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加元素 list.add(&quot;达尔文&quot;); list.add(&quot;达芬奇&quot;); list.add(&quot;达尔优&quot;); //打印这个集合 System.out.println(&quot;list:&quot; + list);//[达尔文, 达芬奇, 达尔优] //调用addFirst添加元素 list.addFirst(&quot;曹操&quot;); System.out.println(&quot;list:&quot; + list);//[曹操, 达尔文, 达芬奇, 达尔优] //调用addLast方法添加元素 list.addLast(&quot;大乔&quot;); System.out.println(&quot;list:&quot; + list);//[曹操, 达尔文, 达芬奇, 达尔优, 大乔] &#125;&#125; Set接口java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。与List接口不同的是，Set接口都会以某种规则保证存入的元素不出现重复。 Set集合有多个子类，这里我们介绍其中的java.util.HashSet、java.util.LinkedHashSet、java.util.TreeSet这两个集合。 HashSet概述java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不能保证不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持，由于我们暂时还未学习，先做了解。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存储和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 我们先来使用一下Set集合存储，看下现象，再进行原理的讲解: 12345678910111213141516171819202122public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建 Set集合 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(new String(&quot;cba&quot;)); set.add(&quot;abc&quot;); set.add(&quot;bac&quot;); set.add(&quot;cba&quot;); //遍历 for (String name : set) &#123; /* 说明集合中不能存储重复元素 cba abc bac */ System.out.println(name); &#125; &#125;&#125; 哈希表什么是哈希表呢？ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用数组处理冲突，同一hash值的链表都存储在一个数组里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的 JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一. 创建自定义Student类: 123456789101112131415161718192021public class Student &#123; private String name; private int age;\t//get/set @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 创建测试类: 123456789101112131415161718192021public class HashSetDemo2 &#123; public static void main(String[] args) &#123; //创建集合对象 该集合中存储 Student类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); //存储 Student stu = new Student(&quot;于谦&quot;, 43); stuSet.add(stu); stuSet.add(new Student(&quot;郭德纲&quot;, 44)); stuSet.add(new Student(&quot;于谦&quot;, 43)); stuSet.add(new Student(&quot;郭麒麟&quot;, 23)); stuSet.add(stu); for (Student stu2 : stuSet) &#123; System.out.println(stu2); &#125; &#125;&#125;执行结果：Student [name=郭德纲, age=44]Student [name=于谦, age=43]Student [name=郭麒麟, age=23] LinkedHashSet我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？ 在HashSet下面有一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo &#123;\tpublic static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(&quot;bbb&quot;); set.add(&quot;aaa&quot;); set.add(&quot;abc&quot;); set.add(&quot;bbc&quot;); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) &#123; System.out.println(it.next()); &#125;\t&#125;&#125;结果： bbb aaa abc bbc TreeSet集合特点TreeSet集合是Set接口的一个实现类,底层依赖于TreeMap,是一种基于红黑树的实现,其特点为： 元素唯一 元素没有索引 使用元素的自然顺序对元素进行排序，或者根据创建 TreeSet 时提供的 Comparator 比较器进行排序，具体取决于使用的构造方法： public TreeSet()： 根据其元素的自然排序进行排序public TreeSet(Comparator&lt;E&gt; comparator): 根据指定的比较器进行排序 演示演示自然排序(20,18,23,22,17,24,19): 123456789101112131415public static void main(String[] args) &#123;\t//无参构造,默认使用元素的自然顺序进行排序\tTreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;();\tset.add(20);\tset.add(18); set.add(23); set.add(22); set.add(17); set.add(24); set.add(19); System.out.println(set);&#125;控制台的输出结果为:[17, 18, 19, 20, 22, 23, 24] 演示比较器排序(20,18,23,22,17,24,19): 12345678910111213141516171819202122public static void main(String[] args) &#123; //有参构造,传入比较器,使用比较器对元素进行排序 TreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; //元素前 - 元素后 : 升序 //元素后 - 元素前 : 降序 return o2 - o1; &#125; &#125;); set.add(20); set.add(18); set.add(23); set.add(22); set.add(17); set.add(24); set.add(19); System.out.println(set);&#125;控制台的输出结果为:[24, 23, 22, 20, 19, 18, 17] Collections类常用功能 java.utils.Collections是集合工具类，用来对集合进行操作。 常用方法如下： public static void shuffle(List&lt;?&gt; list) :打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 代码演示： 123456789101112131415public class CollectionsDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(100); list.add(300); list.add(200); list.add(50); //排序方法 Collections.sort(list); System.out.println(list); &#125;&#125;结果：[50,100, 200, 300] 我们的集合按照默认的自然顺序进行了排列，如果想要指定顺序那该怎么办呢？ 比较器123456789101112131415161718192021222324public class Demo &#123; public static void main(String[] args) &#123; // 创建四个学生对象 存储到集合中 ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); list.add(new Student(&quot;rose&quot;,18)); list.add(new Student(&quot;jack&quot;,16)); list.add(new Student(&quot;abc&quot;,20)); Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getAge()-o2.getAge();//以学生的年龄升序 &#125; &#125;); for (Student student : list) &#123; System.out.println(student); &#125; &#125;&#125;Student&#123;name=&#x27;jack&#x27;, age=16&#125;Student&#123;name=&#x27;rose&#x27;, age=18&#125;Student&#123;name=&#x27;abc&#x27;, age=20&#125; 可变参数在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化. 格式： 修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 代码演示: 1234567891011121314 public class ChangeArgs &#123; public static void main(String[] args) &#123; int sum = getSum(6, 7, 2, 12, 2121); System.out.println(sum); &#125; public static int getSum(int... arr) &#123; int sum = 0; for (int a : arr) &#123; sum += a; &#125; return sum; &#125;&#125; 注意：​ 一个方法只能有一个可变参数 如果方法中有多个参数，可变参数要放到最后。 Map集合概述现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即java.util.Map接口。 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 常用子类通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 **HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 **LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 TreeMap&lt;K,V&gt;：TreeMap集合和Map相比没有特有的功能，底层的数据结构是红黑树；可以对元素的键进行排序，排序方式有两种:自然排序和比较器排序** tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 public boolean containKey(Object key):判断该集合中是否有此键。 Map接口的方法演示 1234567891011121314151617181920public class MapDemo &#123; public static void main(String[] args) &#123; //创建 map对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素到集合 map.put(&quot;黄晓明&quot;, &quot;杨颖&quot;); map.put(&quot;文章&quot;, &quot;马伊琍&quot;); map.put(&quot;邓超&quot;, &quot;孙俪&quot;); System.out.println(map); //String remove(String key) System.out.println(map.remove(&quot;邓超&quot;)); System.out.println(map); // 想要查看 黄晓明的媳妇 是谁 System.out.println(map.get(&quot;黄晓明&quot;)); System.out.println(map.get(&quot;邓超&quot;)); &#125;&#125; tips: 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 遍历键找值通过元素中的键，获取键所对应的值 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 键值对即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 Entry键值对对象: 我们已经知道，Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 获取了Entry对象 , 表示获取了一对键和值，那么同样Entry中 , 分别提供了获取键和获取值的方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。 自定义类型每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。 注意，学生姓名相同并且年龄相同视为同一名学生。 编写学生类： 123456789101112131415161718192021public class Student &#123; private String name; private int age; //构造方法 //get/set @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125;&#125; 编写测试类： 1234567891011121314151617public class HashMapTest &#123; public static void main(String[] args) &#123; //1,创建Hashmap集合对象。 Map&lt;Student,String&gt; map = new HashMap&lt;Student,String&gt;(); //2,添加元素。 map.put(new Student(&quot;lisi&quot;,28), &quot;上海&quot;); map.put(new Student(&quot;wangwu&quot;,22), &quot;北京&quot;); map.put(new Student(&quot;wangwu&quot;,22), &quot;南京&quot;); //3,取出元素。键找值方式 Set&lt;Student&gt; keySet = map.keySet(); for(Student key: keySet)&#123; String value = map.get(key); System.out.println(key.toString()+&quot;.....&quot;+value); &#125; &#125;&#125; 当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。 如果要保证map中存放的key和取出的顺序一致，可以使用java.util.LinkedHashMap集合来存放。 LinkedHashMap我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。 123456789101112public class LinkedHashMapDemo &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;(); map.put(&quot;邓超&quot;, &quot;孙俪&quot;); map.put(&quot;李晨&quot;, &quot;范冰冰&quot;); map.put(&quot;刘德华&quot;, &quot;朱丽倩&quot;); Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;String, String&gt; entry : entrySet) &#123; System.out.println(entry.getKey() + &quot; &quot; + entry.getValue()); &#125; &#125;&#125; 结果: 邓超 孙俪李晨 范冰冰刘德华 朱丽倩 TreeMapTreeMap集合和Map相比没有特有的功能，底层的数据结构是红黑树；可以对元素的键进行排序，排序方式有两种:自然排序和比较器排序；到时使用的是哪种排序，取决于我们在创建对象的时候所使用的构造方法； public TreeMap() 使用自然排序public TreeMap(Comparator&lt;? super K&gt; comparator) 比较器排","tags":["Java","集合"],"categories":["JavaSE"]},{"title":"一篇6.5k字的CSS总结","path":"/frontend-CSS.html","content":"前言 作为学习笔记，可能存在一些错误，若发现望指正，万分感激 文档编写时间已经比较久，可能存在过时信息 意写成类似 HTML 参考文档的形式，方便以后复习查阅~ 浅品 CSS一、常用语法与基本概念1、CSS 是什么Cascading Style Sheets（层叠样式表）CSS 是一门基于规则的语言 —— 你能定义用于你的网页中特定元素样式的一组规则。让你的网页更加美观。 用来定义页面元素的样式 设置字体和颜色 设置位置和大小 添加动画效果 h1 &#123; color: red; font-size: 5em;&#125; 就像上面的代码一样，CSS 语法由选择器 (selector)+{} ，在大括号内部定义一个或多个形式为 属性 (property):值 (value); 的 声明 (declarations) 。 2、css 的引入 内联样式(行内样式) 要使用内联样式，你需要在相关的标签内使用样式(style) 属性。Style 属性可以包含任何 CSS 属性，缺点是缺乏整体性和规划性，不利于维护，维护成本高 &lt;!--内联--&gt;&lt;p style=&quot;&quot;&gt;example&lt;/p&gt; 内部样式 当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用&lt;style&gt; 标签在文档头部定义内部样式表， 缺点 是单个页面内的 CSS 代码具有统一性和规划性,便于维护，但是在多个页面之间容易混乱 &lt;!--嵌入 --&gt;&lt;style&gt; li&#123;&#125; p&#123;&#125;&lt;style&gt; 外部样式(推荐) 当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用 标签链接到样式表。 标签在(文档的)头部 &lt;!--外链--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; /&gt; 其中外链（推荐)，嵌入（常常用与组件开发），内联（不推荐）就是 CSS 的生效地点不同而产生的不同使用方式 3、选择器3.1、***** 选择器通配选择器 也叫全局选择器 ， 顾名思义，全局选择器可以与任何元素匹配，优先级最低，一般做样式初始化 *&#123; margin：0; padding: 0;&#125; 3.2、 标签 选择器也叫 元素选择器，HTML 文档中的元素，p. b. div、 a. img、 body 等。它选择的是页面上所有这种类型的标签,所以经常描述”共性”，无法描述某一个元素的“个性” h3&#123; color: coral; &#125; 3.3、 id选择器在 HTML 中给组件绑定 id，在 CSS 中以#开头+id 名来达到选择效果，值得注意的是 id 值必须是唯一的，并且 id 不能以数字开头 1234567&lt;p id=&quot;exciting&quot;&gt;这里是id选择器代码展示&lt;/p&gt; #exciting&#123; background: border: &#125; 3.4、合并 选择器可以使用 , 把不同的标签或者不同的类合并到同一个样式，可以减少代码重复； h1,p &#123; color: red;&#125; 3.5、 class 选择器与 id 选择器类似但是是以 class 的属性名来决定，不同的是其中 class 的值可以出现多次， 12345678910111213141516171819&lt;h2 class=&quot;a&quot;&gt; hello &lt;h2&gt; &lt;h3 class=&quot;b c&quot;&gt;hello&lt;/h3&gt; &lt;style&gt; .a &#123; color: red; &#125; /*先执行选择器b 再执行选择器c*/ .b &#123; color: blue; &#125; .c &#123; fount-size: 20px; &#125; &lt;/style&gt; &lt;/h2&gt;&lt;/h2&gt; 5.6、属性 选择器 [attr]表示带有以 attr 命名的属性的元素。 [attr=value]表示带有以 attr 命名的属性，且属性值为_值_ 的元素。 [attr~=value]表示带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为_值_。 [attr|=value]表示带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（“”为连字符，Unicode 编码为 U+002D）开头。典型的应用场景是用来匹配语言简写代码（如 zh-CN，zh-TW 可以用 zh 作为 value）。- [attr^=value]表示带有以 attr 命名的属性，且属性值是以 *value *开头的元素。 [attr$=value]表示带有以 attr 命名的属性，且属性值是以 *value *结尾的元素。 [attr*=value]表示带有以 attr 命名的属性，且属性值至少包含一个 *value *值的元素。 12345678910111213141516171819202122232425/* 存在 title 属性的&lt;a&gt; 元素 */a[title] &#123; color: purple;&#125;/* 存在 href 属性并且属性值匹配&quot;https://example.org&quot;的&lt;a&gt; 元素 */a[href=&quot;https://example.org&quot;]&#123; color: green;&#125;/* 存在 href 属性并且属性值包含&quot;example&quot;的&lt;a&gt; 元素 */a[href*=&quot;example&quot;] &#123; font-size: 2em;&#125;/* 存在 href 属性并且属性值结尾是&quot;.org&quot;的&lt;a&gt; 元素 */a[href$=&quot;.org&quot;] &#123; font-style: italic;&#125;/* 存在 class 属性并且属性值包含以空格分隔的&quot;logo&quot;的&lt;a&gt;元素 */a[class~=&quot;logo&quot;] &#123; padding: 2px;&#125; 5.7、 伪类CSS 伪类 是添加到选择器的关键字，指定要选择的元素的特殊状态。例如，：hover 可被用于在用户将鼠标悬停在按钮上时改变按钮的颜色。 /* 所有用户指针悬停的按钮 */button:hover &#123; color: blue;&#125; 动态伪伪类 :link元素被定义了超链接但并未被访问过 :visited元素被定义了超链接并已被访问过 :active元素被激活 :hover鼠标悬停 :focus元素获取焦点 UI 元素状态伪类 :checked选中的复选按钮或者单选按钮表单元素 :enabled所有启用的表单元素 :disabled所有禁用的表单元素 结构伪类选择器 :fisrt-child父元素的第一个子元素 :last-child父元素的最后一个子元素的元素 5.8、关系选择器 后代选择器 定义：选择所有被 E 元素包含的 F 元素，中间用空格隔开语法：E F&#123;&#125;r 子代选择器 定义：选择所有作为 E 元素的直接子元素F，对更深一层的元素不起作用，用&gt;表示语法： E&gt;F&#123;&#125; 相邻兄弟选择器定义: 选择紧跟 E 元素后的 F 元素，用加号表示，选择相邻的第一个兄弟元素语法： E+F&#123;&#125; 通用兄弟选择器定义 ：选择 E 元素之后的所有兄弟元素F，作用于多个元素，用隔开语法： &#96;EF{}&#96; 4、CSS 如何工作 5、CSS 常用属性5.1、color（颜色属性） rgb（0,0,0） 和十六进制 #000000 （#00 红 00 绿 00 蓝） GRB 以红绿蓝三原色直接组合；缺点：不直接关联所见颜色 ； hsl（0,0%,0%） HSL 通过色相，饱和度和亮度组合； hue（色相），范围：0-360 ； saturation（饱和度），范围：0-100% ； lightness（亮度），范围：0-100% #00000000 Aloha 为颜色透明度类似纯色滤镜，范围0-1从透明到不透明； 可添加在 grb 和 hsl 后变成rgba shla 而新版的浏览器可不写直接加第四位，可直接在后添加两位作为透明 opacity ： 透明度，从不透明到透明 0–&gt;1 (非 color 的属性值，为了分类先放着) 5.2、 fount（字体属性） font-family字体主题（可以有多个属性值，浏览器逐级选设备上有的字体），其中存在sans-serif（通用字体）属性 ，还可以通过下面代码规则来自定义字体主题，但是可能会影响原有字体 @font-face&#123; font-family：&quot;字体名字&quot; src：url（字体所在地址） format（&quot;&quot;）&#125; font-size字体大小 font-style字体样式 属性值为italic时为_斜体_ font-weight字重 ;范围：100-900 ；其中 400 可以用 normal 替代，700 可以用 bold 替代 如果存在无法改变自重的情况时，可能是因为改字体仅有 normal 和 bold 两种属性 line-height行高 ;推荐使用无单位的数字如 1.6 ，其表示为为自身字体大小的 1.6 倍，更明显直观 , 让行高等于高可以达到垂直居中的效果 以上属性都可浓缩为 font 属性，简述时其他值为默认值 ，还有字符间距，首行缩进等 5.3、background（背景属性） background-color 设置元素的背景图像 backcground-image: url(&quot;图片地址&quot;) 设置背景图片 background-repeat ：他有如下属性来设置背景图片 值 属性 repeat 默认值 repeat-x 只向水平方向平铺 repeat-y 只向垂直方向平铺 no-repeat 不平铺 background-size 设置背景大小，他有如下值 值 说明 length 设置背景图片的宽度和高度，第一个值宽度，第二个值高度,如果只是设置-个，第二个值 auto percentage 计算相对位置区域的百分比，第一个值宽度，第二个值高度，如果只是设置-个，第二个值 auto cover 保持图片纵横比并将图片缩放成完全覆盖背景区域的最小大小 contain 保持图片纵横比并将图像缩放成适合背景定位区域的最大大小 background-position该属性设置背景图像的起始位置，其默认值是: 0% 0% 值 说明 left top 左上角. left center 左中 left bottom 左下 … … 5.4、文本属性 text-align: 设置文本位置 值 描述 left 文本居左排列，默认值 right 把文本排列到右边 center 把文本排列到中间 text-decoration 规定添加到文本的修饰，下划线、上划线、 删除线等 值 描述 underline 定义下划线 overline 定义上划线 line-through 定义删除线 ext-indent文本块中首行文本的缩进 p&#123;text-i ndent: 50px;&#125; 5.5、表格属性 表格边框 指定 CSS 表格边框,使用 border 属性,不过都是双边框 table，td &#123; border: 1px solid black;&#125; 折叠边框border-collapse 属性设置表格的边框是否被折叠成一个单一的边框或隔开 table &#123; border-collapse:collapse; &#125;table,td &#123; border: 1px solid black; &#125; 表格宽度和高度width 和 height 属性定义表格的宽度和高度 table &#123; wi dth:100%; &#125;td &#123; hei ght: 50px&#125;; 表格文字对齐 表格中的文本对齐和垂直对齐属性 text- align属性设置水平对齐方式，向左，右,或中心 td &#123; text-align: right;&#125; 垂直对齐属性设置垂直对齐vertical-align属性设置垂直对齐方式，向上，下,或中心 td &#123; vertical-align: bottom;&#125; 表格填充 如果在表的内容中控制空格之间的边框，应使用 td 和 th 元素的填充属性 td &#123; padding: 15px;&#125; 表格颜色下面的例子指定边框的颜色，和 th 元素的文本和背景颜色 123456789tab1e,td,th &#123; border: 1px solid green;&#125;td &#123; background-color: green; color: white;&#125; 深入 CSS二、基础布局和盒模型1.选择器特异度在给 HTML 元素应用样式时，多个选择器指向同一个元素，会应用优先级高的选择器，而选择器优先级高低是通过权重计算得到的 权重由高到低如下（为了更直观行让内样式加入其中）： 权重向量： (0, 0, 0, 0) 行内样式 &gt; ID 选择器 &gt; class&#x2F;属性&#x2F;伪类选择器 &gt; 类型 &#x2F; 伪元素 示例： 1234567891011121314151617181920212223242526272829303132333435&lt;div id=&quot;container&quot;&gt; &lt;ul class=&quot;menu&quot;&gt; &lt;li id=&quot;item1&quot; class=&quot;item1&quot;&gt;项目1&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;项目1&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;项目1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;style&gt; /*权重向量计算示例*/ /* (0, 1, 3, 1) */ #container .menu.menu li.item2 &#123; color: #ff4757; &#125; /* (0, 1, 2, 1) */ #container li:nth-child(2).item2 &#123; color: #7bed9f; &#125; /* (0, 1, 1, 1) */ #container li.item2 &#123; color: #ffa502; &#125; /* (0, 0, 1, 1) */ li.item2 &#123; color: #5352ed; &#125; /* (0, 0, 1, 0) */ .item2 &#123; color: #ff6b81; &#125;&lt;/style&gt; 因为权重的不同，我们可以写一些基础样式在后面的开发中通过覆盖来达到相应效果来提高复用性 2.继承谈到了选择器优先级问题就不得不提继承 继承概念： 一般来说某些属性会自动继承其父元素的计算值，除非显式指定一个值；一般来说与文字，颜色等相关属性可以从父级继承的而盒模型相关的属性不可继承 注意： inherit 关键字允许显式的声明继承性，它对继承和非继承属性都生效；若父级没有某些相关属性值，则在继承中会使用初始值（initial） ， 3.CSS 求值过程 4.什么是布局布局可以确定内容的大小和位置和算法； 三种布局方式： 常规流： 顾名思义计算有一些规则，其中有块级，行级，表格布局，FlexBox，Grid 布局 浮动流： 一些元素可做成浮动，如图片的图文置换 绝对定位： 可以直接任意改变元素位置但且不会对常规流造成影响 5.盒模型CSS盒子模型就是在网页设计中经常用到的 CSS 技术所使用的一种思维模型。 盒子模型（Box Modle）可以用来对元素进行布局，包括外边距(margin) ， 边框(border) ，内边距(padding) ，和实际内容(content)这几个部分。 6.content-box 默认情况下，盒子的 宽度（width） 和 高度（height） 由 容量（content） 决定，如上图。其中宽度 为 content box 宽度，取值有长度、百分数、auto；百分数是相对于 conten box 的宽度，auto 是由浏览器根据其他属性确定，高度 类似，auto 是由内容高度计算得来，值得注意的是：只有当容器取固定值的时候，高度百分比才生效 内边距（Padding）概念 页边距相当于容器宽度；对于固定值， 当其只有一个值时对应每个边； 当其有 2 个值时值对应上下+左右； 有 4 个值时是顺时针对应由 padding-top —&gt; padding-left ；对于百分数，其取值是相对于容器宽度 边框（border） 一般有三种 none不显示、 solid实线、dashed虚线； 可以通过border-方向-宽度/颜色 来组合可以调节粗细颜色等 例如： 1234567891011border ： 1px solid #cccborder—left ：1 px solid #ccc;border—right ：2px dotted red;border—width ： lpx 2px 3px 4PX&#x27;;border—style ： solid;border—color ： green blue ;border—left—width : 3px;border—top—color : #f00; 外边距(margin) margin-auto 相同块级的 margin-left 和 margin-right 都为 auto 时 可实现水平居中 ; margin collapse 不同块级的 margin-top 和 margin-button 为相同值的时候，会使两个块级冲突；实际效果是在垂直方向上有折叠，会取两者中间的较大者，而不是简单加在一块。 7.border-box 提示 不同的 box 可通过 box-sizing：border-box；设置，两者区别在于宽和高取值不同从两图中可以清楚的看到取值区别 对于border-box如果指定了宽和高，可能会导致内容的溢出，可以使用overflow去控制溢出内容，其有的属性值：visible展示、 hidden隐藏、 scroll滚动，等 8.块级盒子（Block box） 和 行级盒子（Inline box）在 CSS 中我们广泛地使用两种“盒子” —— 块级 盒子 (block box) 和 行级盒子 (inline box) 。 这两种盒子会在页面流（page flow）和元素之间的关系方面表现出不同的行为 哪那些是块级盒子那些是内联盒子呢？除非特殊指定，诸如标题 (&lt;h1&gt;等) 和段落 (&lt;p&gt;) 默认情况下都是块级的盒子。 而比如 &lt;a&gt; 元素、 &lt;span&gt;、 &lt;em&gt; 以及 &lt;strong&gt; 和&lt;cite&gt; 、 &lt;code&gt;都是默认处于 inline 状态的。 我们通过对盒子display属性的设置，比如 inline 或者 block 、inline-block、none（忽略）来控制盒子的外部显示类型。 区别： 块级盒子摆放、属性的适用性、和 HTML 的关系 –&gt; 元素生成盒子 等存在不同。 三、常规流1、行级排版上下文在只包含行级盒子的时候会创建行级IFC（lnline Formatting Context）排版规则 盒子在一行内水平摆放 一行放不下时，换行显示 text-align 决定一行内盒子的水平对齐 vertical-align 决定一个盒子在行内的垂直对齐 避开浮动（float） 元素 2、块级排版上下文某些容器会创建一个BFC (Block Formatting Context)比如：根元素 ，浮动、绝对定位、inline-block ，Flex 子项和 Grid 子项 ，overflow 值不是 visible 的块盒 ， display:flow-root； 排版规则 盒子从到下摆放 垂直 margin 合并 BFC 内盒子的 margin 不会与外面的合并 BFC 不会和浮动元素重叠 3、Flex BoxFlex Box 被设计为一维布局模型，并作为一种可以在界面中的项目之间提供空间分布和强大对齐功能的方法， 可使用display:flex开启 flex 布局， 使用时 flex box 可以按行或按列排列，按行排列时分为水平方向的主轴和竖直方向的交叉轴，同理按列排列时与按行排列反之 主轴（main axis） 是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 main start 和 main end。 交叉轴（cross axis） 是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 cross start 和 cross end。 改变主轴方向的布局可用jastify-content: flex-start / flex-end / center / space-between / space-around / space-evenly /如下图： 改变交叉轴方向的布局可用align-items: flex-strat &#x2F; flex-end &#x2F; center &#x2F;stretch &#x2F; baseline，相似的改变对应布局只是方向不同，如下图 也可改变主轴与交叉轴位置，flex-direction: column 即主轴变成了交叉轴，交叉轴变成了主轴，其他设置项不变。 非固定尺寸的子元素可以同过调整Flex：的属性调整空间的占比 4、Gridgrid 是一个二维布局模型，通过划分格子（水平线+垂直线）来实现布局，可以同时控制行和列的部局方式 要开启 grid 布局只需要给外层容器设置display：grid即可；可以用 grid-template-columns/rows：（行/列） 指定宽度（fr 为 grid 布局专用单位）或者使用gap属性统一设置 也可以用drid-template-area：进行设置，比如要使一个页面如下：头部和底部宽度占全屏，侧边占 1&#x2F;3，内容占 2&#x2F;3 123456&lt;div class=&quot;layout&quot;&gt; &lt;header&gt; 头 &#123;ß&lt;/header&gt; &lt;aside&gt; 侧边栏 &lt;/aside&gt; &lt;main&gt; 内容 &lt;/main&gt; &lt;footer&gt; 底部 &lt;/footer&gt;&lt;/diV&gt; 我们可以指定区域 1234567891011121314grid—template—areas ： &quot;header header header&quot; &quot;sidebar content content&quot; &quot;footer footer footer&quot;header &#123; grid-area : header; &#125;aside &#123; grid-area : sideber; &#125;main &#123; grid-area : content; &#125;footer &#123;grid—area ：footer; &#125; 和 flex box 类似有水平方向的行轴有竖直方向的块轴可使用align-items: center / end 等（格式同 flex），在对应的格子内实现对齐， 如果行轨道和列轨道小于容器还可以使用align-content: center /等（格式同 flex），对轨道进行对齐 四、文档流文档流是文档中可显示对象在排列时所占用的位置&#x2F;空间 ，例如:块元素自上而下摆放，内联元素，从左到右摆放 标准流里面的限制非常多，导致很多页面效果无法实现 高矮不齐，底边对齐 空白折叠现象 无论多少个空格、换行、tab, 都会折叠为一个空格 如果我们想让 img 标签之间没有空隙，必须紧密连接 怎么解决呢？ 五、浮动流（float）主要实现字图环绕，更多的用常规布局替代，可使用float: left/right开启，会脱离文档流，出现覆盖的情况；通俗点说就是浮动流都在新的一层，可以用来左对齐，或者右对齐 六、绝对定位position 属性 static 默认值 ， 非定位元素，参与常规流的布局 relative也会产生占用空间，相对自身原本位置偏移 ，不脱离文档流 absolute 完全脱离，不占空间，绝对定位 ，相对非 static 祖先元素定位 fixed相对于视囗绝对定位 温馨提示 设置定位之后，相对定位和绝对定位他是相对于具有定位的父级元素进行位置调整，如果父级元素不存在定位，则继续向上逐级寻找，直到顶层文档 说人话就是：如果含有 position 属性的大盒子里面有一个也含有 position 属性的小盒子，那么小盒子会跟着大盒子一起移动 那么就引出了一个小知识： Z-index zindex 属性设置元素的堆叠顺序，属性值为 number（1、2、3…）。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面，那么谁上谁下就不一定了（doge） 七、CSS3 新特性1、圆角效果使用border-radius属性即可，属性值可以调节圆角度数 四个值:第一个值为左上角，第二个值为右上角,第三个值为右下角，第四个值为左下角（左上——&gt;左下，顺时针） 三个值:第一个值为左上角,第二个值为右上角和左下角,第三个值为右下角（不建议使用） 两个值:第一个值为左上角与右下角，第二个值为右上角与左下角（对角） 一个值:四个圆角值相同 2、阴影box-shadow向框添加一个或多个阴影。 box-shadow: h-shadow v-shadow b1ur color; 值 说明 h-shadow 必选，水平阴影的位置 v-shadow 必选，垂直阴影的位置 blur 可选，模糊距离 color 可选，阴影的颜色 3、@keyframes创建动画动画是使元素从一种样式逐渐变化为另一种样式的效果 可以改变任意多的样式任意多的次数，用百分比来规定变化发生的时间，或用关键词”from”和”to”，等同于 0%（开始）和 100%（完成） 使用@keyframes规则,你可以创建动画 1234567891011@keyframes name &#123;from |0%&#123; css样式&#125;percent&#123; css样式&#125;to|100%&#123; css样式&#125; name:动画名称,开发人员自己命名; percent:为百分比值,可以添加多个百分比值; 4、animation执行动画animation: name duration timi ng-function delay iteration-count di recti on; 值 描述 name 设置动画的名称 duration 设置动画的持续时间 timing-function 设置动画效果的速率 delay 设置动画的开始时间(延时执行) iteration-count 设置动画循环的次数，infinite 为无限次数的循环 direction 设置动画播放的方向： normal（正向） 和 alternate（反向） animation-play-state 控制动画的播放状态: running 代表播放， 而 paused 代表停 止播放 timing-function 的值为： ease 逐渐变慢(默认) linear 匀速 ease-in 加速 ease-out 减速 ease-in-out 先加速后减速 例子： &lt;div class=&quot;animation&quot;&gt;&lt;/div&gt; 1234567891011121314151617181920.animation &#123;\twidth: 300px;\theight: 300px;\tbackground-coor: red;\tanimation: anima 5s linear 5s infinite;&#125;.animation: hover &#123;\tanimation-play- state: paused;&#125;@keyframes anima &#123;0% &#123;background-color: red;&#125;50% &#123;background-color: green;&#125;100% &#123;background-color: b1ueviolet;&#125; 5、媒体查询 媒体查询能使页面在不同在终端设备下达到不同的效果 媒体查询会根据设备的大小自动识别加载不同的样式 设置 meta 标签 使用设备的宽度作为视图宽度并禁止初始的缩放。在&lt;head&gt;标签里加入这个 meta 标签。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width， initial-scale=1, maxi mum-scale=1，user-scalab1e=no&quot;&gt; 语法max-width最大宽度 min-width最小宽度 12345678910111213141516171819202122.box &#123; width: 300px; height: 300px;&#125;/* 可视为手机端 */@media screen and (max-width: 768px) &#123; .box &#123; background-color: aqua; &#125;&#125;/* 可视为iPad端*/@media screen and (min-width: 768px) and (max -width: 996px) &#123; .box &#123; background-color: chartreuse; &#125;&#125;/*可视为电脑端*/@media screen and (min-width: 996px) &#123; .box &#123; background-color: red; &#125;&#125; 以上只是控制背景颜色，还可以更改标签是否显示等 6、 雪碧图CSS Sprite 也叫 CSS 精灵图、CSS 雪碧图，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去 最常见于表情，比如： 优点 减少图片的字节 减少网页的 http 请求,从而大大的提高页面的性能 原理 通过 background-image 引入背景图片 通过 background-position 把背景图片移动到自己需要的位置 示例： &lt;i class=&quot;icon1&quot;&gt;&lt;/i&gt; &lt;i class=&quot;icon2&quot;&gt;&lt;/i&gt; 12345678910111213141516.icon1 &#123; // 改变 i 标签为块级元素 display: b1ock; //引入有很多标签的大图片 background- image: ur1(1. png); //调整大图片的位置，直到得到完整的所需表情 background-position: -20px 0; // i 组件的宽高 width: 45px; height: 70px;.icon2&#123; display: b1ock; background-image: ur1(1. png); background-position: -93px -84px; width: 45px; height: 70px; 7、字体图标我们会经常用到一些图标。但是我们在使用这些图标时，往往会遇到失真的情况,而且图片数量很多的话，页面加载就越慢。所以,我们可以使用字体图标的方式来显示图标，既解决了失真的问题，也解决了图片占用资源的问题 优点 轻量性:加载速度快,减少 http 请求 灵活性:可以利用 CSS 设置大小颜色等 兼容性:网页字体支持所有现代浏览器，包括 IE 低版本 使用字体图标 进入阿里巴巴矢量图标库注册账号并登录 选取图标或搜索图标 添加购物车 下载代码 添加到项目里 选择 font-class 引用 &lt;link rel=&quot;stylesheet&quot; href=&quot;./font/iconfont.css&quot; /&gt; 7.挑选相应图标并获取类名，应用于页面: &lt;span class=&quot;iconfont icon-xxx(地址) xxx(使用时大小默认) &quot;&gt;&lt;/span&gt; 总结CSS 目前已经大致更新完善了，但是还是会更新以后遇到的新知识，也有在 b 站学习知识，感谢您的阅读和赞赏~! 本文如有错误欢迎纠正指正! 😊 补充：选择器——知识充电 CSS 属性——知识充电 CSS 如何工作——知识充电 CSS 文档——知识充电","tags":["CSS"],"categories":["前端"]},{"title":"和HTML相识的那一次","path":"/frontend-HTML.html","content":"前言 作为学习笔记，可能存在一些错误，若发现望指正，万分感激 文档编写时间已经比较久，可能存在过时信息 意写成类似 HTML 参考文档的形式，方便以后复习查阅~ 快速入门标签&lt;!--这是一段注释。注释不会在浏览器中显示。--&gt; 可以使用 Ctrl+&#x2F; 快捷键来快速注释代码 &lt;!DOCTYPE&gt;&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于&lt;html&gt;标签之前。标记当前 HTML 文件是什么样的 HTML 版本，浏览器根据此决定页面的渲染 &lt;html&gt;根标签,&lt;html&gt; 与 &lt;/html&gt; 标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。 &lt;head&gt;&lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容；下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;。 &lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。 &lt;body&gt;body 元素包含文档的所有内容（比如文本、超链接、图像、表格和列表等等。） &lt;h1&gt; - &lt;h6&gt;（块级）为标题字体大小，&lt;h1&gt; 定义最大的标题。&lt;h6&gt; 定义最小的标题。 123456&lt;h1&gt;A&lt;/h1&gt;&lt;h2&gt;A&lt;/h2&gt;&lt;h3&gt;A&lt;/h3&gt;&lt;h4&gt;A&lt;/h4&gt;&lt;h5&gt;A&lt;/h5&gt;&lt;h6&gt;A&lt;/h6&gt; 效果如下：\\ &lt;p&gt; （块级）定义段落 ; p 元素会自动在其前后创建一些空白。浏览器会自动添加这些空间，您也可以在样式表中规定。 &lt;hr/&gt;（块级）横线单标签，有以下属性： color:设置水平线的颜色 width:设置水平线的宽度 size:设置水平线的高度 align:设置水平线的对齐方式(默认居中)，可取值left|right &lt;hr color=&quot;red&quot; width=&quot;20%&quot; size=&quot;2px&quot; align=&quot;left&quot; /&gt; 效果入下： 当然后面建议使用 css 写样式 &lt;br/&gt;换行单标签，可以插入文章描述里实现换行 &lt;img&gt;（行内块级）图片组件，有以下属性： src: 路径(图片地址与名字) alt：alt 为图片未被加载的替代性文本 width: 规定图像的宽度 height:规定图像的高度 title:鼠标悬停在图片上给予提示 &lt;img src=&quot;/image/0.jpg&quot; alt=&quot;图片暂未加载&quot; width=&quot;50%&quot; title=&quot;我是提示&quot; /&gt; &lt;a&gt;（内联）超链接标签，需要添加href属性来实现跳转功能，可以在标签里添加文本，图片等也能实现跳转 href 属性来描述链接的地址 默认情况下个未访问过的链接显示为蓝色字体并带有下划线。 我们可以通过 css 来修改默认情况下的样式，并且还可以修改访问前，访问后，鼠标悬停在链接上时等样式 &lt;a href=&quot;https://w.wallhaven.cc/full/k7/wallhaven-k7o551.jpg&quot;&gt;我是文本&lt;/a&gt;&lt;a href=&quot;https://w.wallhaven.cc/full/k7/wallhaven-k7o551.jpg&quot;&gt; &lt;img src=&quot;/image/1.jpg&quot; width=&quot;100px&quot; title=&quot;我是提示&quot; /&gt;&lt;/a&gt; 块元素和内联元素虽然到了 HTML5 的版本，元素分类更细致了,但是这对初学者并不友好,所以我们仍然按照块元素和内联元素做区分，这对我们的布局起到了至关重要的作用 行内块级元素(特点:不换行、能够识别宽高)1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置 常见块级元素&lt;hr&gt;、&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;…… 常见内联元素&lt;b&gt;、&lt;a&gt;、&lt;span&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;…… 行内块级元素&lt;button&gt;、&lt;img&gt;、 &lt;input&gt;…… 格式化文本格式都是内联元素 123456789101112&lt;!--着重--&gt;&lt;em&gt;文本&lt;/em&gt;&lt;!--粗体--&gt;&lt;b&gt;文本&lt;/b&gt;&lt;!--斜体--&gt;&lt;i&gt;文本&lt;/i&gt;&lt;!--加重--&gt;&lt;strong&gt;文本&lt;/strong&gt;&lt;!--删除字--&gt;&lt;del&gt;文本&lt;/del&gt;&lt;!--无特殊含义--&gt;&lt;span&gt;文本&lt;/span&gt; 引用标签&lt;blockquote&gt;标记长的引用 &lt;q&gt;用来定义短的引用 &lt;code&gt;定义计算机代码文本 属性： cite属性用来规定引用的来源 &lt;q cite=&quot;URL&quot;&gt;&lt;/q&gt; 列表定义列表&lt;dl&gt; 、&lt;dt&gt; 、&lt;dd&gt; 都是块级元素 一般在展示的列表形式包括标题和描述两部分时，使用定义列表&lt;dl&gt;&lt;/dl&gt;：定义列表；&lt;dt&gt;&lt;/dt&gt;:标题；&lt;dd&gt;&lt;/dd&gt;:分支描述（多对多） 1234567&lt;dl&gt; &lt;dt&gt;标题&lt;/dt&gt; &lt;dd&gt;描述&lt;/dd&gt; &lt;dt&gt;标题&lt;/dt&gt; &lt;dd&gt;描述&lt;/dd&gt; &lt;dd&gt;描述&lt;/dd&gt;&lt;/dl&gt; 效果如下：\\ 有序列表&lt;ol&gt; 和 &lt;li&gt;标签都是块级元素 有序列表是一列项目，列表项目使用数字进行标记。有序列表始于&lt;ol&gt;标签。每个列表项始于&lt;i&gt; 标签。 可嵌套 &lt;ol&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ol&gt; 效果如下：\\ &lt;b1&gt;的属性type 拥有的选项 1表示列表项目用数字标号(1.23… a表示列表项目用小写字母标号(a,b,c、…) A表示列表项目用大写字母标号(A,B,C、…) i表示列表项目用小写罗马数字标号(i、ii、iii、…) |表示列表项目用大写罗马数字标号(I、II、III、…） &lt;ol&gt;的快捷键： ul&gt;li*n(n 是要生成 li 标签的数量)，同理可以以相同类似推广组合比如：ul&gt;li*3&gt;a 无序列表&lt;ul&gt; 和 &lt;li&gt;标签都是块级元素 无序列表是一个项目的列表，此列项目使用粗体圆点(典型的小黑圆圈)进行标记，无序列表始于&lt;ul&gt;标签；每个列表项始于&lt;li&gt;标签。 可嵌套； 常用于列表导航、无序的列表效果… &lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ul&gt; 效果如下：\\ &lt;ul&gt;的type的属性type 拥有的选项 disc 默认实心圆 circle 空心圆 square 小方块 none 不显示 &lt;ul&gt;的快捷键： ul&gt;li*n(n 是要生成 li 标签的数量) 列表下拉选择&lt;select&gt; &lt;option&gt;a&lt;/option&gt; &lt;option&gt;b&lt;/option&gt; &lt;option&gt;c&lt;/option&gt;&lt;/select&gt; 效果如下： 表格&lt;table&gt;、&lt;tr&gt;和&lt;td&gt;都是块级元素 表格由：行、列、单元格组成；表格标签有 表格:&lt;table&gt; 行:&lt;tr&gt; 单元格(列):&lt;td&gt; 表格属性 border: 设置表格的边框 width: 设置表格的宽度 height: 设置表格的高度 1234567891011121314151617&lt;table border=&quot;1&quot; width=&quot;400&quot; height=&quot;300&quot;&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 快捷键：table&gt;tr*n&gt;td*m&#123;单元格的文本信息&#125;（n：行数量，m：列数量） 单元格合并 水平合并（colpan） : 保留左边，删除右边 垂直合并（rowspan）: 保留上边，删除下边 1234567891011121314151617&lt;table border=&quot;1&quot; width=&quot;400&quot; height=&quot;300&quot;&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!--&lt;td&gt;4&lt;/td&gt;--&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;6&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;7&lt;/td&gt; &lt;!--&lt;td&gt;8&lt;/td&gt;--&gt; &lt;!--&lt;td&gt;9&lt;/td&gt;--&gt; &lt;/tr&gt;&lt;/table&gt; 可见 colspan 和 rowspan 的值对应的是合并单元格的数量，并且要删除对应单元格 ，如果不删除，则会直接生成对应大小的单元格 ，会把部分单元格”顶”出去 那问题来了，如果要合并井字（比如：合并 2 3 5 6）单元格怎么办？ 表单Form 表单(块级)表单是由容器和控件组成的，一个表单一般应该包含用户填写信息的输入框,提交按钮等,这些输入框,按钮叫做控件，表单就是容器，它能够容纳各种各样的控件 属性说明 action 服务器地址 name 表单名称 method 中 Get 和 Post 的区别(目前了解即可)： 数据提交方式，get 把提交的数据 url 可以看到，post 看不到 get- 般用于提交少量数据，post 用来提交大量数据 &lt;form action=&quot;url&quot; name=&quot;myFrom&quot; method=&quot;get/post&quot;&gt;&lt;/form&gt; 表单元素input为行内块级元素 完整的表单包含三个基本组成部分:表单标签、表单域、表单按钮 表单标签:输入框，按钮等 表单域：输入范围 表单按钮：submit &lt;form action=&quot;url&quot; name=&quot;myFrom&quot; method=&quot;get/post&quot;&gt; &lt;!--表单控件--&gt; &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 表单元素 文本框 文本域通过&lt;input tye=&quot;text&quot;&gt;标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域 &lt;form&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot; /&gt;&lt;/form&gt; 密码框 密码字段通过标签&lt;input type=&quot;password&quot;&gt;来定义 &lt;form&gt;Password: &lt;input type=&quot;password&quot; name=&quot; pwd&quot; /&gt;&lt;/form&gt; 提交按钮 输入完信息点击提交，会将信息提交给另一个页面或者服务器，再做相关处理 &lt;form&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot; /&gt; Password: &lt;input type=&quot;password&quot; name=&quot; pwd&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 更多&lt;audio&gt;音频组件，control 表示是否默认播放控件 &lt;audio src=&quot;&quot; controls&gt;&lt;/audio&gt; &lt;video&gt;视频组件 &lt;video src=&quot;&quot; controls&gt;&lt;/video&gt; &lt;input&gt;输入框， &lt;input placehoder=&quot;&quot; type=&quot;&quot; ` /&gt; placehoder 为未输入时的占位符 type 有多种属性值可以调节输入范围 &lt;input type=&quot;range&quot;&gt;&lt;input type=&quot;number&quot; max=&quot;10&quot; min=&quot;1&quot;&gt;&lt;input type=&quot;date&quot; max=&quot;10&quot; min=&quot;1&quot;&gt; 效果如下：\\ 单选框和复选框 chekbox 为复选，radio 为单选互斥关系由 name 相同达到的 &lt;input type=&quot;checkbox&quot; type=&quot;radio&quot; /&gt; 复选： &lt;input type=&quot;checkbox&quot;&gt;a&lt;input type=&quot;checkbox&quot; checked&gt;b 效果如下：\\ 单选： &lt;input type=&quot;radio&quot; name=&quot;c&quot;&gt;a&lt;input type=&quot;radio&quot; name=&quot;c&quot;&gt;b 效果如下： 提示输入 多个标签提示输入,list 来指定用户可以有的提示选项 &lt;ipute list=&quot;&quot;&gt;和&lt;datalist id=&quot;&quot;&gt;&lt;/datalist&gt;&lt;/ipute&gt; 例如： 123456&lt;input lest=&quot;countries&quot;&gt;&lt;select id=&quot;countries&quot;&gt; &lt;option&gt;green&lt;/option&gt; &lt;option&gt;Yellow&lt;/option&gt; &lt;option&gt;Blue&lt;/option&gt;&lt;/select&gt; 效果如下： &lt;textarea&gt;&lt;textarea&gt;&lt;/textarea&gt;:文本域，可多行输入 页面内容划分页面内容一般分为 4 部分：header，main，aside，footer， header中常常含有 log，nav（导航标签）等 main中则是 article 文章部分，main 只有一个为文章主体部分 aside表示与内容相关但不属于文章内容，常常放置广告等， footer位于页未一般放参考链接，版权信息等 刚开始是使用div容器元素，让代码模块化，来实现页面内容划分，但是我们发现效率并不是很高 所以在 HTML5 直接推出了新标签来划分页面内容 两者对比 很明显新标签更容易理解，搜索引擎也会有有相应优化，所以推荐使用新标签来划分页面内容 语义化的理解随着时间的推移，为了可以更清晰的表述出需要的结构和内容，标签会进行迭代更新，会存在新的标签的产生，而 HTML 所有的元素，属性，属性值，都有一些特定的含义，我们应该遵循语义来进行开发 比如在如下应用场景： 开发者-修改、维护页面——-&gt;代码可读性,可维护性 浏览器-展示页面,搜索引擎-提取关键词、排序———-&gt;搜索引擎优化 屏幕阅读器－给盲人读页面内容——&gt;提升无障碍性 总结说了那么多来做个小小的总结：这是一篇小白的笔记，内容不多也不深，我觉得我奶奶来了都能看懂，就提了一些 HTML 的标签以及简单食用方法，加上一点语义化的理解。立意重在建立学习框架，对于做好语义化可以在MDN里面学习更多更深的 HTML 知识，规范书写代码，不使用可视化工具生成代码。 本文如有错误欢迎纠正指正! 😊","tags":["HTML"],"categories":["前端"]},{"title":"初识JavaScript","path":"/frontend-JS.html","content":"前言 作为学习笔记，可能存在一些错误，若发现望指正，万分感激 文档编写时间已经比较久，可能存在过时信息 自己学习学习的 JavaScript 基础，并记录成笔记！ 如何引入 JavaScirptJavaScript 代码可以直接嵌在网页的任何地方 内部引入：是由&lt;script&gt;...&lt;/script&gt;包含的代码就是 JavaScript 代码，它将直接被浏览器执行。 外部引入：是把 JavaScript 代码放到一个单独的.js文件，然后在 HTML 中通过&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;引入这个文件。 代码示例 123456//内部引入&lt; script &gt;&lt; /script&gt;// 外部引入&lt;head&gt; &lt;script src=&quot;/static/js/abc.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 建议： 把 js 放在 html 代码结束处，这样可以让页面先渲染再跑 js，可以避免页面卡住 很多语法和 Java 差不多，比如循环等 一、基本语法123456789101112131415//定义变量var x = 1;let num1 = 10 ;&#x27;Hello, world&#x27;;var x = 1; var y = 2; // 不建议一行写多个语句!//循环if()&#123;&#125;for()&#123;&#125;while()&#123;&#125;do&#123;&#125;while()//常用输出语句alert（）;console.log（）; 1、NumberJavaScript 不区分整数和浮点数，统一用 Number 表示；可以直接做四则运算，规则和数学一致 123456789101112123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示Infinity; /*Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity*/ 2、字符串2.1、转义字符JavaScript 的字符串就是用 &#39;&#39; 或 &quot;&quot; 括起来的字符表示。如果字符串内部既包含 &#39; 又包含 &quot; 怎么办？ 比如： &#x27;I&#x27;m &quot;OK&quot;!&#x27;; 可以使用 转义字符 转义字符可以转义很多字符， 表示换行 \\&#39;表示&#39; \\t表示制表符 \\\\表示的字符就是 \\ ASCII 字符可以以\\x##形式的十六进制表示 \\u####表示一个 Unicode 字符 2.2、多行字符串js 里可以使用单引号表示多行字符串 //单引号在Tab按键的上方`这是一个多行字符串`; 2.3、模板字符串JS 里可以使用$&#123;&#125;快速拼接字符串与变量 123456// 设置变量age//在Java中：&quot;小明&quot; + age + &quot;岁了&quot; // 在JS中也可以这样写，但还可以实现多行字符串编写和模板字符串 `小明$&#123;age&#125;岁了`; 2.4、字符串长度用 .length 来获取字符串长度 var s = &quot;Hello, world!&quot;;s.length; // 13 那我们怎么看字符串长度呢？ 不带转义字符的字符如：abc ,!x=/ ，其长度为 9 (注意有空格) 带转义字符的字符如： abc !, ，其中的 为转义字符（换行符），计算字符串长度时只能计作一个字符，所以该字符串的长度为 7 特殊转义符的字符串如：abcd\\0ef ，其中转义字符 \\0 是字符串结束符，所以在计算长度时为 4 反斜杠如： abc !,\\ ， 因为反斜杠不能作为任何合法的字符，所以是转义符\\\\加上 n 长度为 8 2.5、 不可变性字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果 3、布尔值一个布尔值只有true、false两种值 ； ||运算是或运算 ； !运算是非运算 ；&amp;&amp;运算是与运算 4、比较运算符在 JS 里 不要 使用==比较 ，使用===比较 = //赋值== //类型不一样，值一样，也就是比较类型=== // 和Java的 == 一样 NaN这个特殊的 Number 与所有其他值都不相等 ， 包括它自己;唯一能判断NaN的方法是通过isNaN()判断是否为true NaN === NaN; // falseisNaN(NaN); // true 尽量避免使用浮点数进行运算，存在精度问题 , 只能计算它们之差的绝对值，看是否小于某个阈值 console.log(1 / 3 === 1 - 2 / 3); //false3Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true 5、null 和 undefinednull表示一个 空 的值，它和0以及空字符串&#39;&#39;不同，0是一个数值，&#39;&#39;表示长度为 0 的字符串，而null表示 什么都没有； 而undefined表示值未定义，仅仅在判断函数参数是否传递的情况下有用 6、strict 模式因为 JS 比较随意，容易出现 bug，所以可以在第一行写 &#39;user strict;&#39; ，开启严格检查模式，这样会避免很多问题 二、操作字符串1、返回指定位置的字符charAt() 返回指定位置的字符，参数是从 0 开始编号的 var s = new String( &#x27;litbaizhan&#x27;);s.charAt(1) // &quot;t&quot;s.charAt(s.1ength - 1) // &quot;n&quot;，返回最后一位 如果参数为负数，或大于等于字符串的长度，charAt 返回空字符串 2、连接字符串concat() 用于连接两个字符串，返回一个新字符串，不改变原字符串(其实用+链接更方便) 1234567var s1 = &quot;itbaizhan&quot;;vars2 = &quot;sxt&quot;;s1.concat(s2); // &quot;itbaizhansxt&quot;s1; // &quot;itbaizhan&quot;//该方法可以接受多个参数&quot;sxt&quot;.concat(&quot;itbaizhan&quot;, &quot;bjsxt&quot;); // &quot;sxtitbaizhanbjsxt&quot; 如果参数不是字符串，concat方法会将其先转为字符串,然后再连接 var one = 1;var two = 2;var three = &#x27;3&#x27;;&#x27;&#x27;.concat(one， two， three) // &quot;123&quot; 3、大小写转换.toUpperCase() 全部转化为大写 , .toLowerCase 全部转化为小写 4、索引**.indexOf()**，判断字符串中是否存在某个词汇 var s = &quot;hello, world&quot;;s.indexOf(&quot;world&quot;); // 返回 7s.indexOf(&quot;World&quot;); // 没有找到指定的子串(大写W)，返回-1 indexOf 方法还可以接受第二个参数,表示从该位置开始向后匹配 &quot;he11o world&quot;.indexof(&quot;o&quot;, 6); // 7 也就是跳过了第一个o从6开始到了第二个o的位置 5、返回指定索引区间的子串substring() 返回指定索引区间的子串 ，一定第二个参数大于第一个参数 var s = &#x27;hello, world&#x27;s.substring(0, 5); // 从索引0开始到5（不包括5），返回&#x27;hello&#x27;s.substring(7); // 从索引7开始到结束，返回&#x27;world&#x27; substr() 方法的第一个参数是子字符串的开始位置(从 0 开始计算)，第二个参数是子字符串的长度 &#x27;itbaizhan&#x27;.substr(2，7); // baizhan 如果省略第二个参数,则表示子字符串一直到原字符串的结束 &quot;itbaizhan&quot;.substr(2); // &quot;baizhan&#x27; 如果第一个参数是负数,表示倒数计算的字符位置。如果第二个参数是负数,将被自动转为 0,因此会返回空字符串 &#x27;itbaizhan&#x27;.substr(-7) // &quot;baizhan&quot; &#x27;itbaizhan&#x27;. substr(4， -1) // &quot;&quot; 6、除字符串两端的空格trim用于去除字符串两端(不能去除中间)的空格，返回一个新字符串,不改变原字符串 &quot;he1lo world&quot;.trim(); // &quot;he1loworld&quot; 该方法去除的不仅是空格,还包括制表符(\\t、\\v)、换行符( )和回车符(\\r) &quot;\\r itbaizhan \\t&quot;.trim(); //&#x27;itbaizhan&#x27; ES6 扩展方法，trimEnd()和 trimstar()方法 &quot; itbaizhan &quot;.trimEnd(); //&quot; itbaizhan&quot; 除去头部空格&quot; itbaizhan &quot;.trimStart(); // &quot;itbaizhan &quot;除去尾部空格 7、分割字符串split() 方法按照给定规则分割字符串,返回一个由分割出来的子字符串组成的数组 &#x27;it|sxt |baizhan&#x27;.split(&#x27;I&#x27;) // [&quot;it&quot;， &quot;sxt&quot;， &quot;baizhan&quot;] 如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符。 &#x27;alblc&#x27;.split(&#x27;&#x27;) // [&quot;a&quot;, &quot;I&quot;，&quot;b&quot;,&quot;I&quot;, &quot;c&quot;] 如果省略参数,则返回数组的唯一成员就是原字符串 &#x27;it|sxt|bz&#x27;.sp1it() // [it|sxt|bz] split 方法还可以接受第二个参数,限定返回数组的最大成员数。 &#x27;it|sxt|bz&#x27;.split(&#x27;I&#x27;, 0) // []&#x27;it|sxt|bz&#x27; .split(&#x27;I&#x27;，1) // [&quot;it&quot;]&#x27;itlsxt|bz&#x27;.split(&#x27;l&#x27;， 2) // [&quot;it&quot;， &quot;sxt&#x27;&quot;] 三、数组数组用[]表示，元素之间用,分隔 123456var arr = &#123;1，2，3，4，null，ture，&#x27;hello&#x27;&#125;//推荐new Array = (1，2，3，4，null，ture，&#x27;hello&#x27;)//创建了数组[1，2，3，4，null，ture，&#x27;hello&#x27;]arr[0]; // 返回索引为0的元素，即1arr[5]; // 返回索引为5的元素，即truearr[6]; // 索引超出了范围，返回undefined 1、取得Array的长度.length 可以得到并改变数组长度，变长加空数组，变短会使元素丢失 直接给Array的length赋一个新的值会导致Array大小的变化 1234567var arr = [1, 2, 3.14, &#x27;Hello&#x27;, null, true];arr.length; // 6arr.length = 8;//数组越界arr; // arr变为[1, 2, 3.14, &#x27;Hello&#x27;, null, true， undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] 2、下标索引赋值Array可以通过索引把对应的元素修改为新的值 123456var arr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];arr[1] = 99;arr; // arr现在变为[&#x27;A&#x27;, 99, &#x27;C&#x27;]arr[5] = &#x27;x&#x27;;arr; // arr变为[&#x27;A&#x27;, 99, &#x27;C&#x27;, undefined, undefined, &#x27;x&#x27;] Array也可以通过indexOf()来搜索一个指定的元素的位置 arr.indexOf(99); // 元素99的索引为1arr.indexOf(30); // 元素30没有找到，返回-1 3、截取数组slice()就是对应 String 的substring()版本，它截取Array的部分元素，然后返回一个新的Array： 4、数组增删.push() 数组尾部增加 ， .pop() 数组尾部弹出一个元素 ; .unshift（） 压入头部 ，**.shift（）** 弹出头部的一个元素。加入循环可以清空一个数组。 splice() 方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素 1234567891011121314151617181920212223var arr = [1, 2];arr.push(&quot;A&quot;, &quot;B&quot;); // 返回Array新的长度: 4arr; // [1, 2, &#x27;A&#x27;, &#x27;B&#x27;]arr.pop(); // pop()返回&#x27;B&#x27;arr; // [1, 2, &#x27;A&#x27;]arr.pop();arr.pop();arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // []//splicevar arr = [&quot;Microsoft&quot;, &quot;Apple&quot;, &quot;Yahoo&quot;, &quot;AOL&quot;, &quot;Excite&quot;, &quot;Oracle&quot;];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &quot;Google&quot;, &quot;Facebook&quot;); // 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]arr; // [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]// 只删除,不添加:arr.splice(2, 2); // [&#x27;Google&#x27;, &#x27;Facebook&#x27;]arr; // [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]// 只添加,不删除:arr.splice(2, 0, &quot;Google&quot;, &quot;Facebook&quot;); // 返回[],因为没有删除任何元素arr; // [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;] 5、数组排序它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序，可以在函数里定义排列顺序 .sort() [“c”,”b”,”a”] –&gt; [“a”,”b”,”c”] 6、反转reverse()把整个Array的元素给调个个，也就是反转 .reverse() [“a”,”b”,”c”]–&gt;{[“c”,”b”,”a”] 7、数组拼接.concat() 直接将其拼入数组尾部，但不改变原数组，常用于上拉加载合并数据。 var arr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];var added = arr.concat([1, 2, 3]);added; // [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]arr; // [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] 8、连接符.join() arr&#x3D;[“a”,”b”,”c”] arr.join(-) –&gt; “a-b-c” var arr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3];arr.join(&#x27;-&#x27;); // &#x27;A-B-C-1-2-3&#x27; 9、多维数组如果数组的某个元素又是一个Array，则可以形成多维数组 arr=[[1,2,a],[3,4,b],[5,6,c]] 上述Array包含 3 个元素，其中头两个元素本身也是Array 10、数组组判断AraysAray 方法返回-一个布尔值，表示参数是否为数组。它可以弥补 typeof 运算符的不足 var arr = [&quot;尚学堂&quot;， 100，true];console.1og(typeof arr); // objectvar arr = [&#x27;sxt&#x27;， &#x27;baizhan&#x27;， &#x27;it&#x27;];Array. isArray(arr) // true 四、对象用一个&#123;...&#125;表示一个对象，键值对以xxx: xxx形式申明，用,隔开 ; 属性：属性值，值得注意的是，如果对象里面还有一个对象，那么就形成了链式调用，类似包名 12345678var person = &#123; name: &#x27;Bob&#x27;, age: 20, tags: [&#x27;js&#x27;, &#x27;web&#x27;, &#x27;mobile&#x27;], city: &#x27;Beijing&#x27;, hasCar: true, zipcode: null&#125;; 1、获取属性要获取一个对象的属性，我们用对象变量.属性名的方式 , 也可以用xiaohong[&#39;name&#39;]来访问xiaohong的name属性，不过xiaohong.name的写法更简洁，访问一个不存在的属性会返回undefined 1234567var person = &#123; name: &#x27;Bob&#x27;, age: 20, tags: [&#x27;js&#x27;, &#x27;web&#x27;, &#x27;mobile&#x27;]&#125;;person.name; // &#x27;Bob&#x27;person.city; // undefined 2、属性删减由于 JavaScript 的对象是动态类型，你可以自由地给一个对象添加或删除属性 delete xiaoming.age; // 删除age属性，返回`true` 3、判断属性值是否存在用in操作符：xxx in xxx ，注意！ 如果in判断一个属性存在，这个属性不一定是person的，它可能是person继承得到的 &#x27;name&#x27; in person; // true&#x27;grade&#x27; in person; // false//注意&#x27;toString&#x27; in person; // true 因为toString定义在object对象中，所以person也拥有toString属性 可以用 hasOwnProperty() 判断属性是否自身拥有 person.hasOwnProperty(toString) //返回false 五、条件判断和循环因为和 Java 基本一致就不再赘述，详细见 1、Map 和 SetJavaScript 的对象有个小问题，就是键必须是字符串。但实际上 Number 或者其他数据类型作为键也是非常合理的。为了解决这个问题，最新的 ES6 规范引入了新的数据类型Map 1.1、Map123456789//ES6 Map//学生的成绩，学生的名字// var names = [&quot;tom&quot;，&quot;jack&quot;，&quot;haha&quot;];// var scores = [100,90,80];var map = new Map([[&#x27;tom&#x27; ,100] ,[&#x27;jack&#x27; , 90],[&#x27;haha&#x27;, 80]]);var name = map. get(&#x27;tom&#x27;); //通过key获得va1uemap.set(&#x27;admin&#x27; ,123456); //增加修改map.delete(&quot;tom&quot;) //删除 由于一个 key 只能对应一个 value，所以，多次对一个 key 放入 value，后面的值会把前面的值冲掉 var m = new Map();m.set(&#x27;Adam&#x27;, 67);m.set(&#x27;Adam&#x27;, 88);m.get(&#x27;Adam&#x27;); // 88 1.2、SetSet和Map类似，也是一组 key 的集合，但不存储 value，所以 key 不能重复 1234567set.add(2); //添加set.delete(1); //删除console. 1og(set. has(3)); -//是否包含某 个元素//重复元素在`Set`中自动被过滤var s = new Set([1, 2, 3, 3, &#x27;3&#x27;]);s; // Set &#123;1, 2, 3, &quot;3&quot;&#125; 2、iterator遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6 标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for ... of循环来遍历。 2.1、for … of 和 for … in遍历集合： 123456789101112var a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];var s = new Set([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]);var m = new Map([[1, &#x27;x&#x27;], [2, &#x27;y&#x27;], [3, &#x27;z&#x27;]]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + &#x27;=&#x27; + x[1]);&#125; for ... of循环和for ... in循环的区别：for ... in它遍历的实际上是对象的属性名称，for ... of它只循环集合本身的元素 var a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];a.name = &#x27;Hello&#x27;;for (var x in a) &#123; console.log(x); // &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;name&#x27;&#125; 2.2、forEachforEach()方法是 ES5.1 标准引入的只需要获得Array的element var a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];a.forEach(function (element) &#123; console.log(element);&#125;); Map的回调函数参数依次为value、key和map本身 var m = new Map([[1, &#x27;x&#x27;], [2, &#x27;y&#x27;], [3, &#x27;z&#x27;]]);m.forEach(function (value, key, map) &#123; console.log(value);&#125;); Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身 var s = new Set([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); set 可以认为是去除了 value 的 map , 他的存储模式是和 map 一样的, 数组+链表 or 红黑树的方式。而 array 是单纯的数组. 六、函数函数就是最基本的一种代码抽象的方式 1、函数的定义和调用函数提升：可以先调用再定义 1.1、函数的定义定义函数的方式如下： 123456789101112131415161718//方式一//abs()函数实际上是一个函数对象，而函数名`abs`可以视为指向该函数的变量function abs(x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;//方式二//是一个匿名函数，它没有函数名var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;; function指出这是一个函数定义； abs是函数的名称；函数体内部的语句在执行时。一旦执行到return时，函数就执行完毕，并将结果返回；如果没有return语句返回undefined 上述两种定义完全等价 调用函数时，按顺序传入参数即可 abs(10); // 返回10abs(-9); // 返回9abs(); //此时`abs(x)`函数的参数`x`将收到`undefined`， 返回NaN 通俗点说，函数就是抽象封装的东西，用来提高代码的复用性 1.2、arguments它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。 利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值；常用于判断传入参数的个数 1.3、rest 参数以前: if (arguments.1ength &gt; 2) &#123; for (var i = 2; i &lt; arguments.length; i++) &#123; //。。。。 &#125;&#125; ES6 引入的新特性，获取除了已经定义的参数之外的所有参数~ … function aaa(a, b, ...rest) &#123; console.1og(&quot;a=&gt;&quot; + a); console.1og(&quot;b=&gt;&quot; + b); console.1og(rest);&#125; 2、变量的作用域变量的作用域在 javascript 中，var 定义变量实际是有作用域的。假设在函数体中声明，则在函数体外不可以使用~！（闭包） function qj() &#123; varX = 1; X = X + 1;&#125;x = x + 2; //Uncaught ReferenceError: x is not defined 如果两个函数使用了相同的变量名，只要在函数内部，就不冲突;内部函数可以访问外部函数的成员，反之则不行 假如内部函数变量和外部函数的变量，重名 12345678910function qj() &#123; varx = 1; function qj2 () &#123; varx = &#x27; A&#x27;; console.1og(&#x27;inner&#x27; + x); // outer1 &#125; console.1og(&#x27;outer&#x27; + x); //innerA qj2()&#125;qj() 假设在 JavaScript 中函数查找变量从自身函数开始~，由内向外查找.假设外部存在这个同名的函数变量，则内部函数会屏蔽外部函数的变量。 2.1、提升变量作用域123456function qj() &#123; var x = &quot;x”+y;console.1og(x);vary=&#x27;y&#x27;;&#125;// 结果 x undefined 说明;js 执行引擎,自动提升了 y 的声明，但是不会提升变量 y 的赋值’; 123456 function qj2() &#123;var y;varx=&quot;x&quot;+y;console.1og(x);y =&#x27;y &#x27;;&#125; 这个是在 JavaScript 建立之初就存在的特性。养成规范:所有的变量定义都放在函数的头部，不要乱放,便于代码维护; 123456function qj2() &#123; varx = 1, y = x + 1, z,i,a; //undefined //之后随意用&#125; 2.2、全局函数123456//全局变量x = 1;function f() &#123; console.1og(x); f(); console.1og(x); 2.3、全局对象 windowvarX一XXX，alert(x);alert(window.x); //默认所有的全局变量，都会自动绑定在window对象下; alert()这个函数本身也是一个 window 变量; 12345678910varx = &#x27; xXx&#x27;;window.alert(x);var o1d_ alert = window.alert;//o1d_ alert(x);window.alert = function() &#123;&#125;;//发现alert() 失效了window.alert(123);//恢复window.alert = o1d_ alert;window.alert(456); Javascript 实际上只有一个全局作用域，任何变量 (函数也可以视为变量)， 假设没有在函数作用范围内找到，就会向外查找，如果在全局作用域都没有找到，报错RefrenceError 2.4、规范由于我们所有的全局变量都会绑定到我们的 window.上。如果不同的 js 文件，使用了相同的全局变量，冲突~&gt;如果能够减少冲突? 1234567//唯一全局变量var KuangApp = &#123;&#125;;//定义全局变量KuangApp. name =&#x27; kuangshenKuangApp.add = function (a,b) &#123;return a + b;&#125; 把自己的代码全部放入自己定义的唯一空间名字中，降低全局命名冲突的问题~jQuery –&gt; $() 2.5、局部作用域 letfunction aaa() &#123; for (vari = 0; i &lt; 100; i++) &#123; console.1og(i) console.1og(i + 1); //问题? i 出了这个作用域还可以使用 &#125; 解决局部作用域冲突问题，建议用 let 定义局部作用域变量 2.6、常量 const在 ES6 之前建议使用大写字母来定义的变量作为常量，建议不要修改，ES6 之后引入了常量关键字const const PI = &#x27;3.14&#x27;; //只读变量console.1og(PI);PI = &#x27; 123&#x27;; // TypeError: Assi gnment to constant variable.console.1og(PI); 3、方法把函数放在对象里面，只有属性和方法 123456789101112var kuangshen = &#123; name: &#x27;秦 疆&#x27;bitrh: 2000， // 方法 age: function() &#123; //今年一出生的年 var now = new Date().getFu11Year(); return now - this.bitrh; &#125; //属性 kuangshen.name //方法,一定要带() kuangshen.age() this 代表什么？拆开代码看看 123456789function getAge() &#123; //今年-出生的年 var now = new Date().getFul1Year(); return now - this.bitrh;&#125;var kuangshen = &#123; name: &#x27;秦疆&#x27;，bitrh: 2000，age: getAge // kuangshen.age() ok // getAge() NaN window 可以看出调用getAge()方法失败，因为 window 里没有this.birth所以调用失败 apply在 js 中可以控制 this 的指向 1234567891011function getAge() &#123; //今年-出生的年 var now = new Date().getFullYear(); return now - this.bitrh;&#125;var kuangshen = &#123; name: &#x27;秦疆&#x27;，bitrh: 2000, age: getAge&#125;;// kuangshen.age() okgetAge.app1y(kuangshen, []); // this， 指向了kuangshen这个对象， 参数为空 apply可以让方法里的 this 指向某个对象，获取改对象的属性和属性值，即调用可以成功 七、简单对象1、DateJavaScript 的 Date 对象月份值从 0 开始，牢记 0&#x3D;1 月，1&#x3D;2 月，2&#x3D;3 月，……，11&#x3D;12 月。 12345678910111213141516let now = new Date(); / /Sat Jan 04 2020 10:4/ :06 GMT+0800 ( 中国标准时间)now. getFul1year(); //年now. getMonth(); //月 0~11 代表月now. getDate(); //日now. getDay(); //星期几now. getHours(); // 时now. getMinutes(); //分now. getSeconds(); //秒now. getTime(); //时间戳全世界统-一1970 1.1 0:00:00毫秒数let d = new Date(1435146562875);d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)//时间戳转 为时间d.getMonth(); // 5now.toLocalestring() //获得本地时间now.toGMTString() //获得GMT时间 如果要创建一个指定日期和时间的Date对象，可以用： let d = new Date(2020, 5, 19, 20, 15, 30, 123); // 年,月,日,时,分,秒,毫秒 2、JSONJSON 是超轻量级的数据交换格式，能有效的提升网络传输效率 123456789var user = &#123; name: &quot;qinjiang&quot;, age: 3, sex: &quot;男&quot;,&#125;;//对象转化为json字符串&#123;&quot;name&quot; : &quot;qinjiang&quot;，&quot;age&quot;:3, &quot;sex&quot;:&quot;男&quot;&#125;var jsonUser = JSON.stringify(user);//json字符串转化为对象参数为json字符串var obj = JSON.parse(&#x27;&#123;&quot;name&quot;:&quot;qinjiang&quot;, &quot;age&quot;:3,&quot;sex&quot;:&quot;男&quot;&#125;&#x27;); 3、Math3.1、Math.abs()返回参数值的绝对值Math.abs(1); //1Math.abs(-1); //1 3.2、Math.max(), Math.min()Math.max 方法返回参数之中最大的那个值，Math.min 返回最小的那个值。如果参数为空，Math.min 返回 Infinity，Math.max 返回-Infinity。 Math. max(2, -1，5) // 5Math.min(2, -1，5) // -1Math.min() // InfinityMath.max() // -Infinity 3.3、Math.random()Math.random()返回 0 到 1 之间的-一个伪随机数，可能等于 0,但是-定小于 1 Math.random(); // 0.28525367438365223 任意范围(main——max)的随机数生成函数如下 function getRandomArbitrary(min, max) &#123; return Math.random() * (max - min) + min;&#125;getRandomArbitrary(5, 10); 3.4、Math.floor(), Math.ceil()Math.loor 方法返回小于参数值的最大整数 Math.f1oor(3.2); // 3Math.f1oor(-3.2); // -4 Math.ceil 方法返回大于参数值的最小整数 Math.cei1(3.2); // 4Math.ceil(-3.2); // -3 七、面向对象1、原型继承通过.__proto__继承后，被继承的对象类似于父类 123456789101112131415161718192021var student = &#123; name: &quot;qinjiang&quot;, age: 3, run: function() &#123; console.log(this.name + &quot; run....&quot;);&#125;&#125;;//xiaoming里没有age属性，没有run方法var xiaoming = &#123; name: &quot;xiaoming&quot;&#125;;//xiaoming相当于继承了对象student，会run有年龄有名字xiaoming.__proto__ = student;// 如果再次继承则会覆盖，以最后的一次继承的对象为父类var Bird = &#123; fly: function() &#123; console.1og(this.name + &quot;fl....&quot;); &#125;&#125;;//小明的原型是student，现在xiaoming只会fly和有名字xiaoming._ proto__ = Bird; 2、class 继承class和 Java 是面向对象非常相似,extends继承也和 Java 很像 123456789101112131415161718192021222324252627//定义一个学生的类class Student &#123; //构造器 constructor(name) &#123; this.name = name; &#125; //都是无返回值的方法 he11o() &#123; alert(&quot;he11o&quot;); &#125;&#125;//实例化var xiaoming = new Student(&quot;xiaoming&quot;);var xiaohong = new Student(&quot;xiaohong&quot;);//继承后super调用class xiaostudent extends Student &#123; constructor(name, grade) &#123; super(name); this.grade = grade; &#125; //自己的方法 myGrade() &#123; alert(&quot;我是一名小学生&quot;); &#125;&#125;var xiao = new xiaostudent(&quot;xiaostudent&quot;, 3); 我们打印xiao可以发现xiaostudent的原型是Student，而Student的原型是Object，那Object的原型是谁？我们把这种链状关系叫原型链 深入原型链 八、浏览器1、操作 BOM 对象BOM 就是浏览器模型 Window：浏览器窗口 123456789101112131415window.alert(1)undefinedwindow.innerHeight258wi ndow.innerwidth919window.outerHeight994wi n dow.outerWidth919//还有很多，可以自己再浏览器尝试 Navigater：封装了浏览器信息，但不建议使用 Screen：屏幕尺寸 screen.width1920 pxscreen.height1080 px location：当前页面 url 信息 host：主机 href：当前指向位置 protocol：协议 reload：方法； f reloadl:刷新 location:assign(‘url’)：设置新地址 123456host: &quot;www.baidu.comhref: &quot;https://www.baidu.com/&quot;protoco1: &quot;https:&quot;reload: f reload() // 刷新网页//设置新的地址location.assi gn(&#x27;https://b7og.kuangstudy.com/&#x27;) document：代表当前页面；HTML DOM 文档树，可以获取，删除，增加文档树节点，还可以获取 cookie 等,后面细讲 history：浏览器历史记录,不建议使用 history.back(); //后退history.forward(); //前进 2、操作 DOMDOM 是 JavaScript操作网页的接口，全称为”文档对象模型”(Document Object Model)。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作(比如对元素增删内容) 浏览器会根据 DOM 模型，将结构化文档 HTML 解析成一系列的节点， 再由这些节点组成一个树状结构(DOMTree)。所有的 节点和最终的树状结构，都有规范的对外接口 浏览器网页就是 DOM 树结构 更新:更新 Dom 节点 遍历 dom 节点:得到 Dom 节点 删除:删除一个 Dom 节点 添加:添加一个新的节点 2.1、获得节点DOM 的最小组成单位叫做节点(node) 。文档的树形结构(DOM 树)，就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子 节点类型 Document: 整个文档树的顶层节点 DocumentType: doctype 标签 Element: 网页的各种 HTML 标签 Attribute: 网页元素的属性(比如 class&#x3D;”right”) Text: 标签之间或标签包含的文本 Comment: 注释 DocumentFragment:文档的片段（不常用） 要操作一个 Dom 节点，就必须要先获得这个 Dom 节点，获取方式对应 css 选择器，比如标签选择器、id、class等 123456&lt;div id=&quot;father&quot;&gt; &lt;h1&gt;标题一&lt;/h1&gt; &lt;p id=&quot;p1&quot;&gt;p1&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;p2&lt;/p&gt; &lt;p name=&quot;p3&quot;&gt;p3&lt;/p&gt;&lt;/div&gt; 2.1.1、标签获取//如果有多个相应标签可以在后面通过添加[]来选取对应的标签var h1 = document.getElementsByTagName(&quot;h1&quot;); document.getElementsByTagName 方法搜索 HTML 标签名,返回符合条件的元素。它的返回值是一个类似数组对象( HTMColelon 实例)，可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集 var paras = document.getElementsByTagName(&quot;p&quot;); 如果传入。，就可以返回文档中所有 HTML 元素 var a11Elements = document.getElementsByTagName(&quot;*&quot;); 2.1.2、类获取var p2 = document.getElementsByClassName(&quot;p2&quot;); 2.1.3、id 获取var p1 = document.getElementById(&quot;p1&quot;); 2.1.4、name 获取//使用率低var h1 = document.getElementsByName(&quot;p3&quot;); 2.1.5、关系获取123456var father = document.getElementById(&quot;father&quot;);var childrens = father.children; //获取父节点下的所有子节点father.firstChild; //子节点的第一个节点father.LastChild; //子节点的最后一个节点father.Next; //子节点的下一个节点 2.1.6、document.querySelector()document.uerSelecor 方法接受一个 CSS 选择器作为参数,返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回 null var e11 = document.querySelector(&quot;.myclass&quot;); 2.1.7、document.querySelectorAll()document. qesSelectoll 方法与 queysSelector 用法类似，区别是返回一个 NodeList 对象，包含所有匹配给定选择器的节点 var elementList = document.queryselectorA11(&quot; .myclass&quot;); 以上都是原生代码，后面推荐使用 jQuery 2.2、更新节点1234567//id1 是获取的到的节点id1.innerText = &quot;456&quot;; //文本的值id1.innerHTML = &quot;&lt;strong&gt; 123&lt;/strong&gt;&quot;; //以解析HTML文本标签id1.sty1e.color = &quot;yel1ow&quot;; //属性使用字符串包裹id1.style.fontSize = &quot; 20px&quot;; // 一转驼峰命名问题id1.sty1e.padding = &quot;2em&quot;; 2.3、删除节点要通过父节点获取子节点来删除子节点 1234567891011121314151617&lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;h1&gt;标题一-&lt;/h1&gt; &lt;p id=&quot;p1&quot;&gt;p1&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var se1f = document.getElementById(&#x27;p1&#x27;); var father = p1.parentElement; father.removeChild(sejf) //动态过程，主要索引的下标变化 father.removeChi 1d(father.chi1dren [0]) father.removeChi 1d(father.chi1dren [1]) &lt;/script&gt;&lt;/body&gt; 注意:删除多个节点的时候，children 是在时刻变化的, 2.4、插入节点123456789101112131415161718192021222324252627282930313233 &lt;p id=&quot;js&quot;&gt; Javascript&lt;/p&gt; &lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;se&quot;&gt;JavaSE&lt;/p&gt; &lt;p id=&quot;ee&quot;&gt;JavaEE&lt;/p&gt; &lt;p id=&quot;me&quot;&gt;JavaME&lt;/p&gt; &lt;/div&gt;var js = document.getElementById(&#x27;js&#x27;);var 1ist = document.getElementById(&#x27;list&#x27;);1ist.appendChild(js);//追加到后面//通过JS创建一个新的节点//例如： &lt;p id=&quot;root&quot;&gt;我是文本&lt;/p&gt;//方法一var newP = document.createElement(&#x27;p&#x27;);//创建一个p标签newP.id =&#x27;root&#x27;;newP.innerText = &#x27;我是文本&#x27;; //设置标签内容//方法二var text = document.createElement(&quot;p&quot;);//创建一个p标签var content = document.createTextNode(&quot;我是文本&quot;)//创建文本var id = document.createAttribute(&quot;id&quot; )//创建id属性id.value = &quot;root&quot;//id值 //appendChild: 将内容或者子元素放到容器中，也即是追加text.appendChild(content);text.setAttributeNode(id);//如何渲染到页面呢？——&gt; 对页面上的某标签里使用appendChild追加到里面即可//创建一一个标签节点.// 例如： &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;var myScript = document.createElement(&#x27;script&#x27; );myScript.setAttribute(&#x27;type&#x27;，&#x27;text/javascript&#x27;); 2.5、Element 属性Element 对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个 Element 节点对象(以下简称元素节点) 2.5.1、Element.idElementid属性返回指定元素的 id 属性，该属性可读写 // HTML代码为&lt;p id=&quot;foo&quot;&gt;var p = document.querySelector(&quot;p&quot;);p.id; //&#x27;foo&#x27; 2.5.2、Element.classNameclassName属性用来读写当前元素节点的 class 属性。它的值是一个字符串，每个 class 之间用空格分割 // HTML代码&lt;div class=&quot;one two three&quot; id=&quot;myDiv&quot;&gt;&lt;/div&gt;var div = document. getElementById( myDiv&#x27;);div.c1assName 2.5.3、Element.classListclassList对象有下列方法 add():增加一个 class。 remove():移除一个 class。 contains() :检查当前元素是否包含某个 class。 toggle():将某个 class 移入或移出当前元素。 123456var div = document.getElementById(&#x27;myDiv&#x27;);div.classList.add(&#x27;myCssClass&#x27;);div.classList.add(&#x27;foo&#x27;，&#x27;bar&#x27;);div.classList.remove(&#x27;myCssClass&#x27;);div.classList.toggle(&#x27;myCssClass&#x27;); //如果myCssClass不存在就加入，否则移除div.classList.contains(&#x27;myCssClass&#x27;); //返回true或者false 2.5.4、Element.innerHTMLElementinerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括&lt;HTML&gt; 和&lt;body&gt;元素 e1.innerHTML = &quot;&quot;; 2.5.5、Element.innerTextinnerText和nnerHTML 类似,不同的是innerText无法识别元素,会直接渲染成字符串 2.6、Element 获取元素位置 属性 描述 clientHeight 获取元素高度包括 padding 部分，但是不包括 border、margin document.documentElement.clientHeight 获取视口高度(屏幕高度) doucument.body.clientHeight 获取页面的高度 clientWidth 获取元素宽度包括 padding 部分，但是不包括 border、margin scrollHeight 元素总高度,它包括 padding ,但是不包括 border、margin 包括溢出的不可见内容 scrollWidth 元素总宽度，它包括 padding，但是不包括 border、margin 包括溢出的不可见内容 scrollLeft 元素的水平滚动条向右滚动的像素数量 scrollTop 元素的垂直滚动条向下滚动的像素数量 offsetHeight 元素的 CSS 垂直高度(单位像素)，包括元素本身的高度、padding 和 border offsetWidth 元素的 CSS 水平宽度(单位像素)，包括元素本身的高度、 padding 和 border offsetLeft 到定位父级左边界的间距 offsetTop 到定位父级上边界的间距 3、操作 CSS 样式3.1、HTML 元素的 style 属性操作 CSS 样式最简单的方法，就是使用网页元素节点的 setAtribute 方法直接操作网页元素的 style 属性 div.setAttribute( &#x27;style&#x27;，//参数一&#x27; background-color:red;&#x27; + &#x27;border:1px solid black;&#x27;//参数二); 3.2、元素节点的 style 属性1234567var divstyle = document.querySelector(&quot;div&quot;).style;divsty1e.backgroundcolor = &quot;red&quot;;divStyle.border = &quot;1px solid black&quot;;divStyle.width = &quot; 100px&quot;;divStyle.height = &quot; 100px&quot;;divStyle.fontSize = &quot; 10em&quot;; 3.3、cssText 属性1234567var divstyle = document.querySelector(&quot;div&quot;).style;divSty1e.cssText = &quot; background-co1or: red;&quot; + &quot;border: 1px solid black;&quot; + &quot;height: 100px;&quot; + &quot;width: 100px;&quot;; 4、事件处理事件处理程序分为: HTML 事件处理 DOMO 级事件处理 DOM2 级事件处理 4.1、HTML 事件处理HTML 事件:缺点: HTML 和 JS 没有分开 4.2、DOMO 级事件处理DOM0 事件:优点: HTML 和 IS 是分离的 缺点:无法同时添加多个事件 4.3、DOM2 级事件处理DOM2 事件:优点:事件不会被覆盖 缺点:写起来麻烦 5、鼠标事件鼠标事件指与鼠标相关的事件，具体的事件主要有以下一些 事件 说明 click 按下鼠标时触发 dblclick 在同一个元素上双击鼠标时触发 mousedown 按下鼠标键时触发 mouseup 释放按下的鼠标键时触发 mousemove 当鼠标在节点内部移动时触发。当鼠标持续移动时，该事件会连触发。 mouseenter 鼠标进入一个节点时触发，进入子节点不会触发这个事件 mouseleave 鼠标离开一个节点时触发,离开父节点不会触发这个事件 mouseover 鼠标进入-个节点时触发,进入子节点会再一次触发这个事件 mouseout 鼠标离开一个节点时触发,离开父节点也会触发这个事件 wheel 滚动鼠标的滚轮时触发 6、Event 事件事件发生以后，会产生一个事件对象,作为参数传给监听函数 Event 对象属性 Event.Target Event.type 6.1、Event.targetEvent.target属性返回事件当前所在的节点(点击谁就返回) 1234567// HTML代码为// &lt;p id=&quot;para&quot;&gt;Hello&lt;/p&gt;function setCo1or(e) &#123; console.log(this === e.target); e.target.style.color = &quot;red&quot;;&#125;para.addEventListener(&quot;click&quot;, setCo1or); 6.2、Event.typeEvent.type属性返回一一个字符串,表示事件类型。事件的类型是在生成事件的时候。该属性只读 7、Event 对象万法 Event.preventDefault() Event.stopPropagation() 7.1、Event.preventDefaultEvent.preventDefault方法取消浏览器对当前事件的默认行为。比如点击链接后,浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了 btn. onclick = function(e)&#123; e.preventDefault(); //阻止默认事件 console.1og(&quot;点击A标签&quot;);&#125; 7.2、Event.stopPropagation()stopPropagation方法阻止事件在 DOM 中继续传播,防止再触发定义在别的节点上的监听函数, 但是不包括在当前节点上其他的事件监听函数 btn. onclick = function(e)&#123; e. stopPropagation(); // 阻止事件冒泡 console.1og(&quot;btn&quot;);&#125; 简单点说，事件冒泡就是事件从子级传递到了父级；也就是子级事件发生了，父级就算没有该事件但是也会发生（父子之间相互嵌套） 8、键盘事件键盘事件由用户击打键盘触发，主要有keydown ,keypress ,keyup三个事件 keydown:按下键盘时触发。 keypress: 按下有值的键时触发，即按下 Ctrl. Alt、 Shift、 Meta 这样无值的键，这个事件不会触发。对于有值的键， 按下时先触发 keydown 事件，再触发这个事件。 keyup:松开键盘时触发该事件 8.1、keydownusername.onkeypress = function(e)&#123;console. 1og(&quot;keypress事件&quot;);/ /也可以获取到该元素的值console.log(e.target.value);&#125; 8.2、keyCode;唯一标识每个键盘案件都有唯一标识用e.keyCode获取 123456 var username = document.getElementById&quot;username&quot;); username . onkeydown = function(e)&#123;if(e. keyCode === 13)&#123;console.1og(&quot;回车&quot;); &#125;&#125; 9、表单事件表单事件是在使用表单元素及输入框元素可以监听的一系列事件 input 事件 select 事件 Change 事件 reset 事件 submit 事件 9.1、input 事件input 事件当&lt;input&gt;. &lt;select&gt;. &lt;textarea&gt; 的值发生变化时触发。对于复选框( &lt;input type=checkbox&gt; )或单选框( &lt;input type=radio&gt;)，用户改变选项时，也会触发这个事件 input 事件的一个特点，就是会连续触发，比如用户每按下一次按键， 就会触发一次 input 事件。 var username = document.getElementById(&quot;username&quot;) ;username.oninput = function(e)&#123; console.1og(e.target.value) ;//读取数据 &#125; 9.2、select 事件select 事件当在&lt;input.textarea&gt; 里面选中文本时触发 123456// HTML代码如下 // &lt;input id=&quot;test&quot; type=&quot;text&quot; value=&quot;Select me!&quot; /&gt; var elem = document. getElementById(&#x27;test&#x27;); elem. addEventL istener(&#x27;select&#x27;， function (e) &#123; console.1og(e. type); // &quot;select&quot; &#125;，false); 9.3、Change 事件Change事件当&lt;input&gt;. &lt;select&gt;. &lt;textarea&gt;的值发生变化时触发。它与 input 事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发 var email = document . getElementById(&quot;email&quot;); email . onchange = function(e)&#123; console.1og(e. target. value); &#125; 9.4、reset 事件, submit 事件这两个事件发生在表单对象&lt;form&gt;上，而不是发生在表单的成员上。 reset 事件当表单重置(所有表单成员变回默认值)时触发。 submit 事件当表单数据向服务器提交时触发。注意, submit 事件的发生对象是&lt;orm&gt;元素,而不是&lt;button&gt;元素，因为提交的是表单，而不是按钮 12345678910&lt;form id=&quot;myForm&quot; onsubmi t=&quot;submi tHand1e&quot;&gt; &lt;button oncli ck=&quot;resetHandle&quot;&gt;重置数据&lt;/button&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; var myForm = document. getE1 ementById(&quot;myForm&quot;) function resetHandle()&#123; myForm. reset() ; function submi tHandle()&#123; console.1og(&quot;提交&quot;); &#125; 10、操作表单操作表单就是 form DOM 树，他有 文本框，对应的&lt;input type=&quot;text&quot;&gt;，用于输入文本； 口令框，对应的&lt;input type=&quot;password&quot;&gt;，用于输入口令； 单选框，对应的&lt;input type=&quot;radio&quot;&gt;，用于选择一项； 复选框，对应的&lt;input type=&quot;checkbox&quot;&gt;，用于选择多项； 下拉框，对应的&lt;select&gt;，用于选择一项； 隐藏文本，对应的&lt;input type=&quot;hidden&quot;&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 10.1、获得表单信息如果我们获得了一个&lt;input&gt;节点的引用，就可以直接调用value获得对应的用户输入值，并且还适用于text、password、hidden以及select // &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;var input = document.getElementById(&quot;email&quot;);input.value; // &#x27;用户输入的值&#x27; 也可以自己设置值 input.value = &#x27;test@example.com&#x27;; // 文本框的内容已更新 对于单选框和复选框，value属性返回的永远是 HTML 预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断： 12345678// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt; Monday&lt;/label&gt;// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt; Tuesday&lt;/label&gt;var mon = document.getElementById(&quot;monday&quot;);var tue = document.getElementById(&quot;tuesday&quot;);mon.value; // &#x27;1&#x27;tue.value; // &#x27;2&#x27;mon.checked; // true或者falsetue.checked; // true或者false 10.2、提交表单浏览器默认点击&lt;button type=&quot;submit&quot;&gt;时提交表单，或者用户在最后一个输入框按回车键。因此，可以在提交 form 时作修改： 1234567891011121314&lt;!-- HTML --&gt;&lt;form id=&quot;test-form&quot; onsubmit=&quot;return checkForm()&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;test&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() &#123; var form = document.getElementById(&#x27;test-form&#x27;); // 可以在此修改form的input... // 继续下一步: return true; //告诉浏览器继续提交&#125;&lt;/script&gt; 可以利用&lt;input type=&quot;hidden&quot;&gt;实现提交表单时不传输明文口令 1234567891011121314151617181920&lt;!-- HTML --&gt;&lt;form id=&quot;login-form&quot; method=&quot;post&quot; onsubmit=&quot;return checkForm()&quot;&gt; &lt;!--用户名--&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; /&gt; &lt;!--用户输入的密码，因为没有name使用密码不会被提交--&gt; &lt;input type=&quot;password&quot; id=&quot;input-password&quot; /&gt; &lt;input type=&quot;hidden&quot; id=&quot;md5-password&quot; name=&quot;password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt; function checkForm() &#123; var input_pwd = document.getElementById(&quot;input-password&quot;); var md5_pwd = document.getElementById(&quot;md5-password&quot;); // 把用户输入的明文变为MD5: md5_pwd.value = toMD5(input_pwd.value); // 继续下一步: return true; &#125;&lt;/script&gt; 11、事件代理（事件委托）前面已经说过什么是事件冒泡，那么现在由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上,由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理(delegation) 以无序列表为例 12345678var ul = document . querySelector(&#x27;ul&#x27;); //父级ul. addEventListener(&#x27;click&#x27;, function (event) &#123;//获取li标签具体内容 if (event.target.tagName.toLowercase() === &#x27;li&#x27;) &#123; console.log( event. target. innerHTML); //some code &#125;&#125; 12、定时器JavaScript 提供定时执行代码的功能，叫做定时器(timer), 主要 由setTimeout()和setinterva() 这两个函数来完成。.它们向任务队列添加定时任务 12.1、setTimeoutsetTimeout 函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数,表示定时器的编号，以后可以用来取消这个定时器。 var timerId = setTimeout(func|code， delay); setTimeout 函数接受两个参数,第一个参数 funclode 是将要推迟执行的函数名或者一段代码, 第二个参数 delay 是推迟执行的毫秒数 setTimeout(function()&#123;console.1og(&quot;定时器&quot;)&#125;，1000) 定时器可以进行取消 var id = setTimeout(f, 1000);clearTimeout(id); 注意： 在定时器里的 this 关键字指向全局环境 12.2、setIntervalsetInterval 函数的用法与 setTimeout 完全-致， 区别仅仅在于 setnterval 指定某个任务每隔一段时间就执行一次, 也就是无限次的定时执行 var timer = setInterval(function() &#123;console.1og(2); &#125;，1000) 九、jQurey1、jQurey 引入在 jQurey 的官网下载，会弹出链接，右击链接另存为就可以，然后复制到你的项目里就完成了本地导入 你的项目下面就会出现一个 jquery 的 js 文件 2、基本语法$(选择器).action() 12345678&lt;a href=&quot;&quot; id=&quot;test -jquery&quot;&gt; 点我&lt;/a&gt;;//选择器就是css的选择器$(&quot;#test-jquery&quot;).click(function () &#123; alert(&quot;he1lo, jQuery&quot;);&#125;); 1234567891011//原生js，选择器少，麻烦不好记//标签document.getElementsByTagName();//iddocument.getElementById();//类document.getElementsByClassName();$(&quot;p&quot;).click(); //标签选择器$(&quot;#id1&quot;).click(); //id选择器$(&quot;.class1&quot;).click(); //class选择器 3、事件3.1、鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在 DOM 内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于 mouseenter 加上 mouseleave。 3.2、键盘事件键盘事件仅作用在当前焦点的 DOM 上，通常是&lt;input&gt;和&lt;textarea&gt;。 keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。 3.3、其他事件 focus：当 DOM 获得焦点时触发； blur：当 DOM 失去焦点时触发； change：当&lt;input&gt;、&lt;select&gt;或&lt;textarea&gt;的内容改变时触发； submit：当&lt;form&gt;提交时触发； ready：当页面被载入并且 DOM 树完成初始化后触发。 操作 DOM 元素jQuery 对象的text()和html()方法分别获取节点的文本和原始 HTML 文本 &lt;!-- HTML结构 --&gt;&lt;ul id=&quot;test-ul&quot;&gt; &lt;li class=&quot;js&quot;&gt;JavaScript&lt;/li&gt; &lt;li name=&quot;book&quot;&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt; 分别获取文本和 HTML： $(&quot;#test-ul li[name=book]&quot;).text(); // &#x27;Java &amp; JavaScript&#x27;$(&quot;#test-ul li[name=book]&quot;).html(); // &#x27;Java &amp;amp; JavaScript&#x27; 节点文本操作 $(&quot; #test-u11i [name=python]&quot;).text(); //获得值$(&quot; #test-u1 1i [name=python]&quot;).text(&quot;设置值&quot;); //设置值$(&quot; #test-u1&quot;).htm1(); //获得值$(&quot; #test-u1&quot;).htm7(&quot;&lt;strong&gt;123&lt;/strong&gt;&quot;); //设置值 CSS 的操作 $(&#x27; #test-u1 1i [name=python]&#x27;). css(&#123;&quot;color&quot;,&quot;red&quot;&#125;) 元素的显示和隐藏:本质display :none $(&quot; #test-u11i [name=python] &quot;).show();$(&quot; #test-u1 1i [name=python]&quot;).hide(); 总结如果有误，欢迎指错纠正 参考文档廖雪峰–JavaScript 教程 jQuery 文档","tags":["JS"],"categories":["前端"]},{"title":"常用git指令","path":"/tool-Git.html","content":"git 指令随手记我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图 6 个命令，就可以了。但是熟练使用，恐怕要记住 60 ～ 100 个命令。 1、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 2、配置123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 3、增加&#x2F;删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 4、代码提交12345678910111213141516171819# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 5、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 6、标签12345678910111213141516171819202122232425# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag 7、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 8、远程同步1234567891011121314151617181920212223242526# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 指定上传仓库位置$ git remote add origin [你远程仓库的url]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 9、撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 10、其他# 生成一个可供发布的压缩包$ git archive 参考文档借鉴自大佬：阮一峰","tags":["git"],"categories":["笔记"]},{"title":"(四). 渐入佳境 - 常用API","path":"/JavaSE-APIs.html","content":"Object类概述java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类，\t那么默认则继承自Object类。例如： public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 toString方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 1234567891011public class Person &#123; private String name; private int age; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; // 省略构造器与Getter Setter&#125; 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。如下图所示： 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 1234567891011121314151617181920import java.util.Objects;public class Person &#123; private String name;\tprivate int age; @Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; // 转换为当前类型 Person person = (Person) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;&#125; 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： Objects类Objects类是对象工具类，它里面的的方法都是用来操作对象的。 equals方法在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 我们可以查看一下源码，学习一下： public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); isNullstatic boolean isNull(Object obj) 判断对象是否为null，如果为null返回true。 123456Student s1 = null;Student s2 = new Student(&quot;蔡徐坤&quot;, 22);// static boolean isNull(Object obj) 判断对象是否为null,如果为null返回trueSystem.out.println(Objects.isNull(s1)); // trueSystem.out.println(Objects.isNull(s2)); // false Date类Date概述java.util.Date&#96;类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，我们重点看以下两个构造函数 public Date()：从运行程序的此时此刻到时间原点经历的毫秒值,转换成Date对象，分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：将指定参数的毫秒值date,转换成Date对象，分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于中国处于东八区（GMT+08:00）是比世界协调时间&#x2F;格林尼治时间（GMT）快8小时的时区，当格林尼治标准时间为0:00时，东八区的标准时间为08:00。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2020 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 Date常用方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 public void setTime(long time) 把方法参数给定的毫秒值设置给日期对象 示例代码 1234567891011121314151617public class DateDemo02 &#123; public static void main(String[] args) &#123; //创建日期对象 Date d = new Date(); //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 //System.out.println(d.getTime()); //System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + &quot;年&quot;); //public void setTime(long time):设置时间，给的是毫秒值 //long time = 1000*60*60; long time = System.currentTimeMillis(); d.setTime(time); System.out.println(d); &#125;&#125; 小结：Date表示特定的时间瞬间，我们可以使用Date对象对时间进行操作。 DateFormat类java.text.DateFormat 是日期&#x2F;时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，把Date对象转换为String对象。 解析：按照指定的格式，把String对象转换为Date对象。 构造方法由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 1234567891011121314151617public class SimpleDateFormatDemo &#123; public static void main(String[] args) throws ParseException &#123; //格式化：从 Date 到 String Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String s = sdf.format(d); System.out.println(s); System.out.println(&quot;--------&quot;); //从 String 到 Date String ss = &quot;2048-08-09 11:11:11&quot;; //ParseException SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date dd = sdf2.parse(ss); System.out.println(dd); &#125;&#125; 小结：DateFormat可以将Date对象和字符串相互转换。 Calendar类概述 java.util.Calendar类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：java.util.GregorianCalendar类。 有两种方式可以获取GregorianCalendar对象： 直接创建GregorianCalendar对象； 通过Calendar的静态方法getInstance()方法获取GregorianCalendar对象 常用方法 方法名 说明 public static Calendar getInstance() 获取一个它的子类GregorianCalendar对象。 public int get(int field) 获取某个字段的值。field参数表示获取哪个字段的值，可以使用Calender中定义的常量来表示：Calendar.YEAR : 年Calendar.MONTH ：月Calendar.DAY_OF_MONTH：月中的日期Calendar.HOUR：小时Calendar.MINUTE：分钟Calendar.SECOND：秒Calendar.DAY_OF_WEEK：星期 public void set(int field,int value) 设置某个字段的值 public void add(int field,int amount) 为某个字段增加&#x2F;减少指定的值 get方法12345678910111213141516171819202122232425262728293031323334public class Demo &#123; public static void main(String[] args) &#123; //1.获取一个GregorianCalendar对象 Calendar instance = Calendar.getInstance();//获取子类对象 //2.打印子类对象 System.out.println(instance); //3.获取属性 int year = instance.get(Calendar.YEAR); int month = instance.get(Calendar.MONTH) + 1;//Calendar的月份值是0-11 int day = instance.get(Calendar.DAY_OF_MONTH); int hour = instance.get(Calendar.HOUR); int minute = instance.get(Calendar.MINUTE); int second = instance.get(Calendar.SECOND); int week = instance.get(Calendar.DAY_OF_WEEK);//返回值范围：1--7，分别表示：&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,...,&quot;星期六&quot; System.out.println(year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + second); System.out.println(getWeek(week)); &#125; //查表法，查询星期几 public static String getWeek(int w) &#123;//w = 1 --- 7 //做一个表(数组) String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;; // 索引 [0] [1] [2] [3] [4] [5] [6] //查表 return weekArray[w - 1]; &#125;&#125; set方法123456789101112131415161718192021222324public class Demo &#123; public static void main(String[] args) &#123; //设置属性——set(int field,int value): Calendar c1 = Calendar.getInstance();//获取当前日期 //计算班长出生那天是星期几(假如班长出生日期为：1998年3月18日) c1.set(Calendar.YEAR, 1998); c1.set(Calendar.MONTH, 3 - 1);//转换为Calendar内部的月份值 c1.set(Calendar.DAY_OF_MONTH, 18); int w = c1.get(Calendar.DAY_OF_WEEK); System.out.println(&quot;班长出生那天是：&quot; + getWeek(w)); &#125; //查表法，查询星期几 public static String getWeek(int w) &#123;//w = 1 --- 7 //做一个表(数组) String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;; // 索引 [0] [1] [2] [3] [4] [5] [6] //查表 return weekArray[w - 1]; &#125;&#125; add方法1234567891011121314151617181920212223public class Demo &#123; public static void main(String[] args) &#123; //计算200天以后是哪年哪月哪日，星期几？ Calendar c2 = Calendar.getInstance();//获取当前日期 c2.add(Calendar.DAY_OF_MONTH, 200);//日期加200 int y = c2.get(Calendar.YEAR); int m = c2.get(Calendar.MONTH) + 1;//转换为实际的月份 int d = c2.get(Calendar.DAY_OF_MONTH); int wk = c2.get(Calendar.DAY_OF_WEEK); System.out.println(&quot;200天后是：&quot; + y + &quot;年&quot; + m + &quot;月&quot; + d + &quot;日&quot; + getWeek(wk)); &#125; //查表法，查询星期几 public static String getWeek(int w) &#123;//w = 1 --- 7 //做一个表(数组) String[] weekArray = &#123;&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;&#125;; // 索引 [0] [1] [2] [3] [4] [5] [6] //查表 return weekArray[w - 1]; &#125;&#125; Math类概述 java.lang.Math(类): Math包含执行基本数字运算的方法。 它不能创建对象，它的构造方法被“私有”了。因为他内部都是“静态方法”，通过“类名”直接调用即可。 常用方法 方法名 说明 public static int abs(int a) 获取参数a的绝对值： public static double ceil(double a) 向上取整 public static double floor(double a) 向下取整 public static double pow(double a, double b) 获取a的b次幂 public static long round(double a) 四舍五入取整 示例1234567891011public class Demo &#123; public static void main(String[] args) &#123; System.out.println(&quot;-5的绝对值：&quot; + Math.abs(-5));//5 System.out.println(&quot;3.4向上取整：&quot; + Math.ceil(3.4));//4.0 System.out.println(&quot;3.4向下取整：&quot; + Math.floor(3.4));//3.0 System.out.println(&quot;2的8次幂：&quot; + Math.pow(2, 8));//256.0 System.out.println(&quot;3.2四舍五入：&quot; + Math.round(3.2));//3 System.out.println(&quot;3.5四舍五入：&quot; + Math.round(3.5));//4 &#125;&#125; System概述java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作。 常用方法 方法名 说明 public static void exit(int status) 终止当前运行的 Java 虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前时间(以毫秒为单位) 示例123456789101112131415import java.util.Date;//验证for循环打印数字1-9999所需要使用的时间（毫秒）public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); //计算程序运行时间 long start = System.currentTimeMillis(); for (int i = 1; i &lt;= 10000; i++) &#123; System.out.println(i); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;共耗时毫秒：&quot; + (end - start)); &#125; &#125; BigDecimal类引入浮点数做运算精度问题； 看程序说结果： 123456public static void main(String[] args) &#123; System.out.println(0.09 + 0.01); System.out.println(1.0 - 0.32); System.out.println(1.015 * 100); System.out.println(1.301 / 100);&#125; 概述 相关内容 具体描述 包 java.math 使用时需要导包 类声明 public class BigDecimal extends Number implements Comparable 描述 BigDecimal类提供了算术，缩放操作，舍入，比较，散列和格式转换的操作。提供了更加精准的数据计算方式 构造方法名 描述 BigDecimal(double val) 将double类型的数据封装为BigDecimal对象 BigDecimal(String val) 将 BigDecimal 的字符串表示形式转换为 BigDecimal 注意：推荐使用第二种方式，第一种存在精度问题； 常用方法BigDecimal类中使用最多的还是提供的进行四则运算的方法，如下： 方法声明 描述 public BigDecimal add(BigDecimal value) 加法运算 public BigDecimal subtract(BigDecimal value) 减法运算 public BigDecimal multiply(BigDecimal value) 乘法运算 public BigDecimal divide(BigDecimal value) 触发运算 注意：对于divide方法来说，如果除不尽的话，就会出现java.lang.ArithmeticException异常。此时可以使用divide方法的另一个重载方法； BigDecimal divide(BigDecimal divisor, int scale, int roundingMode): divisor：除数对应的BigDecimal对象；scale:精确的位数；roundingMode取舍模式 小结：Java中小数运算有可能会有精度问题，如果要解决这种精度问题，可以使用BigDecimal 正则表达式概念及演示 在Java中，我们经常需要验证一些字符串，例如：年龄必须是2位的数字、用户名必须是8位长度而且只能包含大小写字母、数字等。正则表达式就是用来验证各种字符串的规则。它内部描述了一些规则，我们可以验证用户输入的字符串是否匹配这个规则。 先看一个不使用正则表达式验证的例子：下面的程序让用户输入一个QQ号码，我们要验证： QQ号码必须是5–15位长度 而且必须全部是数字 而且首位不能为0 12345678910111213141516171819202122232425262728293031public class Demo &#123;\tpublic static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你的QQ号码：&quot;); String qq = sc.next(); System.out.println(checkQQ(qq));\t&#125;\t//我们自己编写代码，验证QQ号码\tprivate static boolean checkQQ(String qq) &#123; //1.验证5--15位 if(qq.length() &lt; 5 || qq.length() &gt; 15)&#123; return false; &#125; //2.必须都是数字； for(int i = 0;i &lt; qq.length() ; i++)&#123; char c = qq.charAt(i); if(c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;)&#123; return false; &#125; &#125; //3.首位不能是0； char c = qq.charAt(0); if(c == &#x27;0&#x27;)&#123; return false; &#125; return true;//验证通过\t&#125;\t&#125; 使用正则表达式验证： 123456789101112131415public class Demo &#123;\tpublic static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你的QQ号码：&quot;); String qq = sc.next(); System.out.println(checkQQ2(qq));\t&#125;\t//使用正则表达式验证\tprivate static boolean checkQQ2(String qq)&#123; String regex = &quot;[1-9]\\\\d&#123;4,14&#125;&quot;;//正则表达式 return qq.matches(regex);\t&#125;&#125; 上面程序checkQQ2()方法中String类型的变量regex就存储了一个”正则表达式 “，而这个正则表达式就描述了我们需要的三个规则。matches()方法是String类的一个方法，用于接收一个正则表达式，并将”本对象”与参数”正则表达式”进行匹配，如果本对象符合正则表达式的规则，则返回true，否则返回false。 字符类 语法示例： [abc]：代表a或者b，或者c字符中的一个。 [^abc]：代表除a,b,c以外的任何字符。 [a-z]：代表a-z的所有小写字符中的一个。 [A-Z]：代表A-Z的所有大写字符中的一个。 [0-9]：代表0-9之间的某一个数字字符。 [a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。 [a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。 代码示例： 12345678910111213141516171819202122public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;ead&quot;; //1.验证str是否以h开头，以d结尾，中间是a,e,i,o,u中某个字符 String regex = &quot;h[aeiou]d&quot;; System.out.println(&quot;1.&quot; + str.matches(regex)); //2.验证str是否以h开头，以d结尾，中间不是a,e,i,o,u中的某个字符 regex = &quot;h[^aeiou]d&quot;; System.out.println(&quot;2.&quot; + str.matches(regex)); //3.验证str是否a-z的任何一个小写字符开头，后跟ad regex = &quot;[a-z]ad&quot;; System.out.println(&quot;3.&quot; + str.matches(regex)); //4.验证str是否以a-d或者m-p之间某个字符开头，后跟ad regex = &quot;[[a-d][m-p]]ad&quot;; System.out.println(&quot;4.&quot; + str.matches(regex));\t&#125;&#125; 逻辑运算符 语法示例： &amp;&amp;：并且 | ：或者 代码示例： 12345678910111213public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;had&quot;; //1.要求字符串是小写辅音字符开头，后跟ad String regex = &quot;[a-z&amp;&amp;[^aeiou]]ad&quot;; System.out.println(&quot;1.&quot; + str.matches(regex)); //2.要求字符串是aeiou中的某个字符开头，后跟ad regex = &quot;[a|e|i|o|u]ad&quot;;//这种写法相当于：regex = &quot;[aeiou]ad&quot;; System.out.println(&quot;2.&quot; + str.matches(regex));\t&#125;&#125; 预定义字符 语法示例： “.” ： 匹配任何字符。 “\\d”：任何数字[0-9]的简写； “\\D”：任何非数字[^0-9]的简写； “\\s”： 空白字符：[ \\t \\x0B\\f\\r] 的简写 “\\S”： 非空白字符：[^\\s] 的简写 “\\w”：单词字符：[a-zA-Z_0-9]的简写 “\\W”：非单词字符：[^\\w] 代码示例： 12345678910111213141516171819202122232425public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;258&quot;; //1.验证str是否3位数字 String regex = &quot;\\\\d\\\\d\\\\d&quot;; System.out.println(&quot;1.&quot; + str.matches(regex)); //2.验证手机号：1开头，第二位：3/5/8，剩下9位都是0-9的数字 str = &quot;13513153355&quot;;//要验证的字符串 regex = &quot;1[358]\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d\\\\d&quot;;//正则表达式 System.out.println(&quot;2.&quot; + str.matches(regex)); //3.验证字符串是否以h开头，以d结尾，中间是任何字符 str = &quot;had&quot;;//要验证的字符串 regex = &quot;h.d&quot;;//正则表达式 System.out.println(&quot;3.&quot; + str.matches(regex)); //4.验证str是否是：had. str = &quot;had.&quot;;//要验证的字符串 regex = &quot;had\\\\.&quot;;//\\\\.代表&#x27;.&#x27;符号，因为.在正则中被预定义为&quot;任意字符&quot;，不能直接使用 System.out.println(&quot;4.&quot; + str.matches(regex)); &#125;&#125; 数量词 语法示例： X? : 0次或1次 X* : 0次到多次 X+ : 1次或多次 X{n} : 恰好n次 X{n,} : 至少n次 X{n,m}: n到m次(n和m都是包含的) 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;&quot;; //1.验证str是否是三位数字 str = &quot;012&quot;; String regex = &quot;\\\\d&#123;3&#125;&quot;; System.out.println(&quot;1.&quot; + str.matches(regex)); //2.验证str是否是多位数字 str = &quot;88932054782342&quot;; regex = &quot;\\\\d+&quot;; System.out.println(&quot;2.&quot; + str.matches(regex)); //3.验证str是否是手机号： str = &quot;13813183388&quot;; regex = &quot;1[358]\\\\d&#123;9&#125;&quot;; System.out.println(&quot;3.&quot; + str.matches(regex)); //4.验证小数:必须出现小数点，但是只能出现1次 String s2 = &quot;3.1&quot;; regex = &quot;\\\\d*\\\\.&#123;1&#125;\\\\d+&quot;; System.out.println(&quot;4.&quot; + s2.matches(regex)); //5.验证小数：小数点可以不出现，也可以出现1次 regex = &quot;\\\\d+\\\\.?\\\\d+&quot;; System.out.println(&quot;5.&quot; + s2.matches(regex)); //6.验证小数：要求匹配：3、3.、3.14、+3.14、-3. s2 = &quot;-3.&quot;; regex = &quot;[+-]\\\\d+\\\\.?\\\\d*&quot;; System.out.println(&quot;6.&quot; + s2.matches(regex)); //7.验证qq号码：1).5--15位；2).全部是数字;3).第一位不是0 s2 = &quot;1695827736&quot;; regex = &quot;[1-9]\\\\d&#123;4,14&#125;&quot;; System.out.println(&quot;7.&quot; + s2.matches(regex));\t&#125;&#125; 分组括号( )123456789public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;DG8FV-B9TKY-FRT9J-99899-XPQ4G&quot;; //验证这个序列号：分为5组，每组之间使用-隔开，每组由5位A-Z或者0-9的字符组成 String regex = &quot;([A-Z0-9]&#123;5&#125;-)&#123;4&#125;[A-Z0-9]&#123;5&#125;&quot;; System.out.println(str.matches(regex));\t&#125;&#125; String的split方法 String类的split()方法原型： public String[] split(String regex)//参数regex就是一个正则表达式。可以将当前字符串中匹配regex正则表达式的符号作为&quot;分隔符&quot;来切割字符串。 代码示例： 12345678910public class Demo &#123;\tpublic static void main(String[] args) &#123; String str = &quot;18 4 567 99 56&quot;; String[] strArray = str.split(&quot; +&quot;); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.println(strArray[i]); &#125;\t&#125;&#125; String类的replaceAll String类的replaceAll()方法原型： public String replaceAll(String regex,String newStr)//参数regex就是一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。 代码示例： 1234567public class Demo &#123; public static void main(String[] args) &#123; //将下面字符串中的&quot;数字&quot;替换为&quot;*&quot; String str = &quot;jfdk432jfdk2jk24354j47jk5l31324&quot;; System.out.println(str.replaceAll(&quot;\\\\d+&quot;, &quot;*&quot;)); &#125;&#125; 包装类概述Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean Integer类 Integer类概述 包装一个对象中的原始类型 int 的值 Integer类构造方法及静态方法 方法名 说明 public Integer(int value) 根据 int 值创建 Integer 对象(过时) public Integer(String s) 根据 String 值创建 Integer 对象(过时) public static Integer valueOf(int i) 返回表示指定的 int 值的 Integer 实例 public static Integer valueOf(String s) 返回保存指定String值的 Integer 对象 示例代码 123456789101112131415161718192021public class IntegerDemo &#123; public static void main(String[] args) &#123; //public Integer(int value)：根据 int 值创建 Integer 对象(过时) Integer i1 = new Integer(100); System.out.println(i1); //public Integer(String s)：根据 String 值创建 Integer 对象(过时) Integer i2 = new Integer(&quot;100&quot;); //Integer i2 = new Integer(&quot;abc&quot;); //NumberFormatException System.out.println(i2); System.out.println(&quot;--------&quot;); //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例 Integer i3 = Integer.valueOf(100); System.out.println(i3); //public static Integer valueOf(String s)：返回保存指定String值的Integer对象 Integer i4 = Integer.valueOf(&quot;100&quot;); System.out.println(i4); &#125;&#125; 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—-&gt;包装对象 Integer i = new Integer(4);//使用构造函数函数Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 包装对象—-&gt;基本数值 int num = i.intValue(); 自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;//加法运算完成后，再次装箱，把基本数值转成对象。 基本类型与字符串之间的转换基本类型转换为String 转换方式 方式一：直接在数字后加一个空字符串 方式二：通过String类静态方法valueOf() 示例代码 1234567891011121314public class IntegerDemo &#123; public static void main(String[] args) &#123; //int --- String int number = 100; //方式1 String s1 = number + &quot;&quot;; System.out.println(s1); //方式2 //public static String valueOf(int i) String s2 = String.valueOf(number); System.out.println(s2); System.out.println(&quot;--------&quot;); &#125;&#125; String转换成基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 转换方式 方式一：先将字符串数字转成Integer，再调用valueOf()方法 方式二：通过Integer静态方法parseInt()进行转换 示例代码 123456789101112131415public class IntegerDemo &#123; public static void main(String[] args) &#123; //String --- int String s = &quot;100&quot;; //方式1：String --- Integer --- int Integer i = Integer.valueOf(s); //public int intValue() int x = i.intValue(); System.out.println(x); //方式2 //public static int parseInt(String s) int y = Integer.parseInt(s); System.out.println(y); &#125;&#125; 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。 泛型泛型概述在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换 1234567891011121314public class GenericDemo &#123;\tpublic static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add(&quot;abc&quot;); coll.add(&quot;itcast&quot;); coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = coll.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length()); &#125;\t&#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。为什么会发生类型转换异常呢？ 我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。怎么来解决这个问题呢？ Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 好处上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？ 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 通过我们如下代码体验一下： 123456789101112131415public class GenericDemo2 &#123;\tpublic static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;abc&quot;); list.add(&quot;itcast&quot;); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125;\t&#125;&#125; tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 定义与使用我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类定义格式： 修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 泛型在定义的时候不具体，使用的时候才变得具体。在使用的时候确定泛型的具体数据类型。 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125; 含有泛型的方法定义格式： 修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125; 调用方法时，确定泛型的类型 12345678910public class GenericMethodDemo &#123; public static void main(String[] args) &#123; // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(&quot;aaa&quot;); mm.show(123); mm.show(12.45); &#125;&#125; 含有泛型的接口定义格式： 修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， public interface MyGenericInterface&lt;E&gt;&#123;\tpublic abstract void add(E e); public abstract E getE(); &#125; 使用格式： 1、定义类时确定泛型的类型 例如 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123;\t@Override public void add(String e) &#123; // 省略... &#125;\t@Override\tpublic String getE() &#123; return null;\t&#125;&#125; 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123;\t@Override\tpublic void add(E e) &#123; // 省略...\t&#125;\t@Override\tpublic E getE() &#123; return null;\t&#125;&#125; 确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(&quot;aa&quot;); &#125;&#125; 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 123456789public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;// ？代表可以接收任意类型泛型不存在继承关系 Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种是错误的 通配符高级使用之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); &#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;","tags":["Java"],"categories":["JavaSE"]},{"title":"(三). 渐入佳境 - 重学多态","path":"/JavaSE-Polymorphism.html","content":"多态形式多态是继封装、继承之后，面向对象的第三大特性。多态是出现在继承或者实现关系中的。 多态体现的格式： 父类类型 变量名 = new 子类/实现类构造器;变量名.方法名(); 多态的前提：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。 示例当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。如果子类没有重写该方法，就会调用父类的该方法。 总结起来就是：编译看左边，运行看右边。 代码如下： 定义父类： public class Animal &#123; public void eat()｛ System.out.println(&quot;动物吃东西！&quot;) ｝&#125; 定义子类： 1234567891011class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; &#125; 定义测试类： 12345678910111213public class Test &#123; public static void main(String[] args) &#123; // 多态形式，创建对象 Animal a1 = new Cat(); // 调用的是 Cat 的 eat a1.eat(); // 多态形式，创建对象 Animal a2 = new Dog(); // 调用的是 Dog 的 eat a2.eat(); &#125; &#125; 定义多态： 是指同一行为，具有多个不同表现形式。 从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。 前提【重点】 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 优缺点好处实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下： 定义父类： public abstract class Animal &#123; public abstract void eat(); &#125; 定义子类： 1234567891011class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; &#125; 定义测试类： 12345678910111213141516171819202122232425262728293031public class Test &#123; public static void main(String[] args) &#123; // 多态形式，创建对象 Cat c = new Cat(); Dog d = new Dog(); // 调用showCatEat showCatEat(c); // 调用showDogEat showDogEat(d); /* 以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代 而执行效果一致 */ showAnimalEat(c); showAnimalEat(d); &#125; public static void showCatEat (Cat c)&#123; c.eat(); &#125; public static void showDogEat (Dog d)&#123; d.eat(); &#125; public static void showAnimalEat (Animal a)&#123; a.eat(); &#125;&#125; 由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。 当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。 不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。从而实现了实现类的自动切换。 所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。 弊端我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时多态的写法就无法访问子类独有功能了。 12345678910111213141516171819202122232425262728class Animal&#123; public void eat()｛ System.out.println(&quot;动物吃东西！&quot;) ｝&#125;class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse() &#123; System.out.println(&quot;抓老鼠&quot;); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; &#125;class Test&#123; public static void main(String[] args)&#123; Animal a = new Cat(); a.eat(); a.catchMouse();//编译报错，编译看左边，Animal没有这个方法 &#125;&#125; 引用类型转换为什么要转型多态的写法就无法访问子类独有功能了。 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 回顾基本数据类型转换 自动转换: 范围小的赋值给范围大的.自动完成:double d &#x3D; 5; 强制转换: 范围大的赋值给范围小的,强制转换:int i &#x3D; (int)3.14 ​ 多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。 向上转型（自动转换） 向上转型：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。当父类引用指向一个子类对象时，便是向上转型。使用格式： 父类类型 变量名 = new 子类类型();如：Animal a = new Cat(); 原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。所以子类范围小可以直接自动转型给父类类型的变量。 向下转型（强制转换） 向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 使用格式： 子类类型 变量名 = (子类类型) 父类变量名;如:Aniaml a = new Cat(); Cat c =(Cat) a; 转型的异常转型的过程中，一不小心就会遇到这样的问题，请看如下代码： 1234567891011public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse 【运行报错】 &#125; &#125; 这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。 instanceof关键字为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下： 变量名 instanceof 数据类型 如果变量属于该数据类型或者其子类类型，返回true。如果变量不属于该数据类型或者其子类类型，返回false。 所以，转换前，我们最好先做一个判断，代码如下： 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 if (a instanceof Cat)&#123; Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125; else if (a instanceof Dog)&#123; Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse &#125; &#125; &#125; 内部类概述什么是内部类将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。可以把内部类理解成寄生，外部类理解成宿主。 内部类是Java类的五大成份之一，也是我们最后一个需要学习的成份。 一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用 人里面有一颗心脏。 汽车内部有一个发动机。 为了实现更好的封装性。 分类按定义的位置来分 静态内部类，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类) 实例内部内，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类) 局部内部类，类定义在方法内 匿名内部类。一般定义在方法中，或者可执行代码中 静态内部类静态内部类特点： 有static修饰的内部类，属于外部类本身的。 总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。 拓展:静态内部类可以直接访问外部类的静态成员。 内部类的使用格式： 外部类.内部类。 静态内部类对象的创建格式： 外部类.内部类 变量 = new 外部类.内部类构造器; 实例内部类实例内部类特点： 无static修饰的内部类，属于外部类对象的。 宿主：外部类对象。 内部类的使用格式： 外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类 实例内部类创建对象格式： 外部类.内部类 变量 = new 外部类构造器.new 内部类构造器; 拓展1：实例内部类不能定义静态成员。 拓展2：实例内部类可以直接访问外部类的私有和静态成员。 局部内部类 局部内部类 ：定义在方法中的类。 定义格式: 1234567891011class 外部类名 &#123;\t数据类型 变量名; 修饰符 返回值类型 方法名(参数列表) &#123; // … class 内部类 &#123; // 成员变量 // 成员方法 &#125;\t&#125;&#125; 局部内部类编译后仍然是一个独立的类，编译后有$还有一个数字。Chinese$1Chopsticks.class 匿名内部类匿名内部类 ：是内部类的简化写法。它的本质是一个带具体实现的 父类或者父接口的 匿名的 子类对象。开发中，最常用到的内部类就是匿名内部类了。 实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用 是为了简化代码。 之前我們使用接口时，似乎得做如下几步操作： 定义子类 重写接口中的方法 创建子类对象 调用重写后的方法 123456789101112131415161718192021interface Swim &#123; public abstract void swimming();&#125;// 1. 定义接口的实现类class Student implements Swim &#123; // 2. 重写抽象方法 @Override public void swimming() &#123; System.out.println(&quot;狗刨式...&quot;); &#125;&#125;public class Demo07 &#123; public static void main(String[] args) &#123; // 3. 创建实现类对象 Student s = new Student(); // 4. 调用方法 s.swimming(); &#125;&#125; 我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。 匿名内部类必须继承一个父类或者实现一个父接口。 匿名内部类格式 1234567new 父类名或者接口名()&#123; // 方法重写 @Override public void method() &#123; // 执行语句 &#125;&#125;; 定义一个没有名字的内部类 这个类实现了父类，或者父类接口 匿名内部类会创建这个没有名字的类的对象 包和权限修饰符包包我们每天建的项目就是在一个目录下，我们每次都会建立一个包，这个包在磁盘下其实就是一个目录。包是用来分门别类的管理技术，不同的技术类放在不同的包下，方便管理和维护。 包名的命名规范： 路径名.路径名.xxx.xxx// 例如：com.huzhiha.oa 包名一般是公司域名的倒写。 包名必须用”.“连接。 包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。 权限修饰符在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了public 和 private，接下来我们研究一下protected和缺省（default默认）修饰符的作用。 public：公共的，所有地方都可以访问。 protected：当前类 ，当前包，当前类的子类可以访问。 缺省（没有修饰符）：当前类 ，当前包可以访问。 private：私有的，当前类可以访问。public &gt; protected &gt; 缺省 &gt; private public protected 缺省（空的） private 同一类中 √ √ √ √ 同一包中的类 √ √ √ 不同包的子类 √ √ 不同包中的无关类 √ 可见，public具有最大权限。private则是最小权限。 编写代码时，如果没有特殊的考虑，建议这样使用权限： 成员变量使用private ，隐藏细节。 构造方法使用 public ，方便创建对象。 成员方法使用public ，方便调用方法。 小贴士：不加权限修饰符，就是default权限","tags":["Java","OOP"],"categories":["JavaSE"]},{"title":"(二). 基础入门 - Java面向对象","path":"/JavaSE-OOP.html","content":"面向对象编程顾名思义，面向对象，你得首先有个对象，有了对象后，就可以和对象进行互动，所以面向对象编程是通过对象的方式，把现实世界映射到计算机模型的一种编程方法；与面向对象编程相反的是面向过程编程，是把模型分解成一步一步的过程 面向对象基础现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance） 先仔细看看这简单的段代码吧~ 相信在此框架下，后面学起来更轻松~ 123456789101112131415161718192021222324252627282930313233// 定义了一个人类public class person&#123; //成员变量 String name; //名字 int age; // 年龄 //无参构造方法 public person()&#123;&#125; //含参数构造方法 public person(String name,int age)&#123; this.name = name; this.age = age; &#125; //成员方法 public void eat()&#123; System.out.println(this.name+&quot;在&quot;+this.age+&quot;岁就已经学会干饭了&quot;); &#125; public static void main(String[] args)&#123; //无参实例化 person p1 = new person(); p1.name = &quot;小红&quot;; p1.age = 18; //调用eat方法 p1.eat(); // 含参实例化 person p2 = new person(&quot;小明&quot;,80); //调用eat方法 p2.eat(); &#125; &#125; 1、 类class 是一种对象模版，它定义了如何创建实例，因此，class 本身就是一种数据类型 定义 class在 Java 中，创建一个类，例如，给这个类命名为Person，就是定义一个class： class Person &#123; public String name; public int age;&#125; 一个class可以包含多个字段（field），字段用来描述一个类的特征，通过 class 把一组数据汇集到一个对象上，实现了数据封装 2、 实例instance 是根据 class 创建的实例，可以创建多个 instance，每个 instance 类型相同，但各自属性可能不相同 创建实例new 操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例，所以是引用变量ming指向实例new Person(),可以通过这个变量来操作实例 Person ming = new Person(); 不同的实例在内存中对应位置不一样哦~ 3、this 关键字在调用方法的时候，java 会自动的把对象传递给方法， 在方法中由this来接收对象，就和开始所示代码一样；变量的查找顺序: 先找自己方法内。如果自己没有，就去this里面找 this:当前类的对象 this 可以在方法内部获取到对象中的属性信息 this 还可以区分局部变量和成员变量 4、方法访问权限 public 公共的.所有人都可访问 default 包访问权限.在自己包内可以随意访问. private 私有的. get set方法引入开始已经说了字段field可以用来用来描述一个类的特征，但是直接把field用public暴露给外部可能会破坏封装性。比如： 12345678910//定义person类class Person &#123; public String name; public int age;&#125;//实例化Person ming = new Person();ming.name = &quot;Xiao Ming&quot;;ming.age = -99; // age可以设置为负数 怎么办？使用private（私有） 字段 class Person &#123; private String name; private int age;&#125; private修饰field，就避免外部代码直接去访问field，那我们要怎么使用这些dield呢？ 我们需要方法（method） 来从外部代码间接修改field的值，比如我们使用使用外部方法getName来间接获取private字段的值，再使用setName来检查传入的参数对不对，从而达到筛选的效果 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; //实例化调用 Person ming = new Person(); ming.setName(&quot;Xiao Ming&quot;); // 设置name ming.setAge(12); // 设置age System.out.println(ming.getName() + &quot;, &quot; + ming.getAge()); &#125;&#125;//定义类class Person &#123; private String name; private int age; public String getName() &#123; return this.name; &#125;// 在这里我们就筛选出了不能传入name为空的字符串， public void setName(String name) &#123; if (name==null) &#123; //抛出非法或者不合适的这个异常 throw new IllegalArgumentException(&quot;invalid name&quot;); &#125; //返回方法值 this.name = name; &#125; 同理 age 也可以如此操作，需要注意的是，这个方法相当于被封装在 person 类里，通过一个类定义方法，就可以给外部暴露一些操作的接口的同时保证自己内部类的统一，我们可以在外部使用实例变量.方法名(参数); 来进行调用 看起来可能会有点麻烦，因为一个成员变量就要两个方法，所以在我们的 idea 中可以快捷生成get set 方法 : 空白位置-&gt;右键-&gt; generate -&gt; getter and setter-&gt;全选-&gt; Ok. 构造方法指的是在创建对象的时候，类自动调用的方法.语法:public 类名(传参){}注意: 没有返回值这一项 在我们 new 的时候.自动调用构造方法作用: 在创建对象的时候.给对象设置属性信息. java 会默认自动的送给每一个类一个无参构造方法 构造方法的重载构造方法也是方法，也可以进行重载。 作用: 可以又更多的方式去创建对象；可以使用 this 可以访问其他的构造方法 this() 成员方法定义方法的语法是： 修饰符 方法返回类型 方法名(方法参数列表) &#123; 若干方法语句; return 方法返回值;&#125; 方法返回值通过return语句实现，如果没有返回值，返回类型设置为void，可以省略return 同样的我们既然有private字段那么也就有private方法，并且private方法不允许外部调用，但是我们可以在 privet 内部调用private方法 1234567891011121314151617class Person &#123; private String name; private int birth; public void setBirth(int birth) &#123; this.birth = birth; &#125; public int getAge() &#123; return calcAge(2019); // 调用private方法 &#125; // private方法: private int calcAge(int currentYear) &#123; return currentYear - this.birth; &#125;&#125; 5、静态在一个class中定义的字段，我们称之为实例字段，用static修饰的字段，称为静态字段：static field，实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间” 123456class Person &#123; public String name; public int age; // 定义静态字段number: public static int number;&#125; 可以有两者办法使用静态 12345678//直接通过实例变量访问静态对象//所有实例的静态字段都被修改了，原因是静态字段并不属于实例 hong.number = 99; System.out.println(ming.number); //通过类名访问静态变量Person.number = 99;System.out.println(Person.number); 但是不推荐用 实例变量.静态字段 去访问静态字段， 因为在 Java 程序中，实例对象并没有静态字段 ；实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为 类名.静态字段 来访问静态对象。所以推荐用类名来访问静态字段。 因为静态对象会比实例对象更先加载，就和司马迁不能给你编写历史，但是你可以给司马迁编写历史一样：不能够用 this 去访问实例对象，不能在静态方法里调用非静态方法，可以在静态方法里调用静态方法，也可以用类名来调用静态方法 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; Person.setNumber(99); System.out.println(Person.number); &#125;&#125;class Person &#123; public static int number; public static void setNumber(int value) &#123; number = value; &#125;&#125; 特点: . 数据共享 (要变一起变) 属于类的，并不属于对象 优先于对象产生的 6、包和导包包:其实本质上就是文件夹，在代码中需要写 package+包名; 例如： 导包:import 包+类; 不同包之间需要进行导包才能互相访问 不需要导包: 在自己包里 java.lang 包 下的所有内容都不需要导包 比如： StringSystem.out.println0 7、继承继承:子类可以自动拥有父类中除了私有内容外的其他所有内容. 当出现 x 是一种 y 的时候. x 就可以继承 y，换句话说就是动物都会叫，猴子是动物，猴子继承了动物会叫的功能，所以猴子会叫 public class类extends父类&#123;&#125; 作用: 简化代码的开发. 子类对父类进行了扩展. 如果父类和子类存在相同属性，子类是如何继承的呢？ 使用super关键字调用父类，使用this关键字调用自己类，在调用变量时this关键字是先找自己类，再找父类； 父类： 123456public class Hero &#123; String name = &quot;英雄&quot; public fulei()&#123; System. out. print ln(&quot;我是父类的构造方法&quot;); &#125;&#125; 子类： 1234567891011121314151617public class SunWuKong extends Hero &#123; String name = &quot;孙大圣&quot;; public SunWuKong( ) &#123; super(); // 还原程序，在子 类构造方法的第一行，默认调用父类的构造方法 System. out. print ln(&quot;我是子类的构造方法&quot; );&#125; public void chi( )&#123; //想看到父类中的name System.out. print Ln(super.name) ; //先找自己类，然后找父类 System. out. println( this.name+&quot;在吃桃子&quot;) ;&#125; public static void main(String[] args) &#123; SunWuKong S = new SunWuKong( ) ; S.chi() ; &#125;&#125; 调用方法时一般默认在子类的第一个构造方法里最先使用super()调用父类的**无参构造方法，所以可以不写super()调用父类的无参构造方法，但是对于含参构造方**法，就需要在子类中使用super(参数)调用父类的含参构造方法，不然就会报错 那如果子类不满意继承来的方法怎么办呢？ 8、重写方法的重写，也即是子类对父类中提供的方法进行重新定义 语法: 子类和父类中的方法的声明完全一致，重写又被称为方法的覆盖； 如果子类想在重写的方法中使用父类原本的方法仍然可以使用super.方法名()的形式去调用，这种既重写了方法又调用了原方法叫做半盖 上面就是 toString 方法的重写 9、多态多态:同一个对象拥有多种形态 举个例子： 假如有三个动物，猫、狗、鸡，猫吃鱼、狗啃骨头、鸡啄米，现在有一个人，这个人要在早晨去喂这三个动物，应该怎么写呢？ 因为多态比较难一点所以就写详细一点 动物： public class Animal &#123; public void eat()&#123; System.out.println(&quot;动物会进食&quot;); &#125;&#125; 猫： public class Cat extends Animal &#123; public void eat()&#123; System.out.println(&quot;猫吃鱼&quot;); &#125;&#125; 狗： 123456public class Dog extends Animal &#123; public void eat()&#123; System.out.println(&quot;狗啃骨头&quot;); &#125;&#125; 鸡： 123456789public class Chicken extends Animal &#123; public void eat()&#123; System.out.println(&quot;鸡啄米&quot;); &#125; public void dance()&#123; System.out.println(&quot;练习时常两年半的舞蹈鸡&quot;);&#125;&#125; 人： 123456public class Person &#123; public void feedanimal(Animal ain)&#123; System.out.print(&quot;人在喂&quot;); ain.eat(); &#125;&#125; 场景： 123456789101112131415161718192021public class Scenario &#123; public static void main(String[] args) &#123; // 实例化 向上转型 Animal ain1 = new Cat(); Animal ain2 = new Chicken(); Animal ain3 = new Dog(); Person p = new Person(); System.out.println(&quot;在一个早晨&quot;); p.feedanimal(ain1); p.feedanimal(ain2); p.feedanimal(ain3); /* 在早晨 人在喂猫吃鱼 人在喂鸡啄米 人在喂狗啃骨头 */ &#125;&#125; 可以看出人在喂的时候只喂了动物，而不是把猫狗鸡都一个一个挨着喂，是因为猫狗鸡和动物有一个继承关系，并且我们在实例化的时候把子类对象赋值给了父类变量，相对于把子类们都统一到了父类里，其实这就是多态的体现，我们把这叫做向上转型 ，但是不难看出，鸡还有跳舞的功能被屏蔽了， 因为向上转型会屏蔽掉子类不同于父类的方法 有向上转型就有向下转型，我们把父类的变量转化回子类的变量就叫做向下转型，向下转型有可能有风险. java 要求必须要写强制类型转换(转换之后的数据类型)变量 12345678910111213public class Scenario &#123; public static void main(String[] args) &#123; Animal ain2 = new Chicken(); Chicken c = (Chicken) ain2; c.dance(); c.eat(); /* 练习时常两年半的舞蹈鸡 鸡啄米 */ &#125;&#125; 10、final 被final 修饰的变量不可以被改变，又被称为常量 被final修饰的方法不可以被重写. 被final修饰的类不可以被继承. 11、抽象只声明，不实现，可以有正常的方法 抽象方法:使用 abstract 来修饰，不可以有方法体，直接用分号结束即可； 抽象类:如果一个类中有抽象方法，这个类必须是一一个抽象类； 特点: 抽象类不可以创建对象； 抽象类的子类，必须重写父类中的抽象方法.否则,子类必须也是抽象类； 通过抽象类可以强制的要求子类中必须有哪些方法.； 12、接口特殊的抽象类：所有的方法都是抽象方法,用 interface 来声明 接口中所有的方法都是抽象方法。可以省略掉abstract； 接口中所有的内容都是公开的。公共的； 接口中所有的变量都是全局静态常量 public static final ； 能继承接口的只能是接口； 接口和类只能是实现关系implepents； 接口也具有多态性，也就是 接口可以把很多不相关的内容进行整合； 类只能单继承，接口支持多实现，也就是类可以继承一个类，实现多个接口； 13、成员变量初始值 java 中所有的变量必须先声明，后赋值才能使用 I java 中的成员变量，在创建对象的时候，都会执行一次初始化操作.都会给一个默认值. 基本数据类型默认值都是 0 包括 boolean -&gt; false 引用数据类型: null，null 表示空,什么都没有.占位. 14、toString默认的 toString() -&gt;包+ 类@内存地址 1234567891011121314151617package com.xyq.entity;public class Cat &#123;\t//类默认继承Object\tString name;\tString color ;\tpublic Cat(String name, String color)&#123; this.name = name; this.color = color;\t&#125;\tpublic static void main(String[] args) &#123; Cat C = new Cat( name:&quot;小花&quot;， color: &quot;绿色&quot;); //直接打印这个 System.out.println(c) ; //输出 com.xyq.entity.Cat@47d384ee //默认打印对象，自动的执行这个对象中的toString( )方法 System.out.println(c.toString()) ; //也输出 com.xyq.entity.Cat@47d384ee &#125;&#125; 很明显我们对父类 Stirng 里的 toString 方法并不满意，那么我们可以重写这个方法(上面有) 15、instanceof判断 xxx 对象是否是 xxx 类型的 1234567891011public class Cat extends Anima 1 &#123;\tpublic static void main(String[] args) &#123; Animal ani = new Animal( ) ; if(ani instanceof Cat)&#123; System. ou.println(&quot;是一只猫。撸一撸&quot;); &#125; else &#123; System. out.pr intln(&quot;不是一只猫&quot;); &#125;\t&#125;&#125; 16、内存分析 堆：主要存放对象. 栈：局部变量，以及基本数据类型的变量. 代码区：类和方法 数据区：常量池和静态变量","tags":["Java","OOP"],"categories":["JavaSE"]},{"title":"(一). 基础入门 - Java基础","path":"/JavaSE-Basics.html","content":"前言 作为学习笔记，可能存在一些错误，若发现望指正，万分感激 本文主要记录了一些Java基础内容，如单例设计模式 类什么是类与对象 类：描述相同事物的共同特征的抽象。人类 对象：具体存在的实例，是真实的。实例&#x3D;&#x3D;对象 在代码层面：必须先有类，才能创建出对象。 如何定义类类的定义格式如下: 12345678修饰符 class 类名&#123; // 类中有且仅有的五大成分。 // 1.成员变量 （描述类和对象的属性信息） // 2.成员方法 （行为信息） // 3.构造器 （初始化类对象并且返回引用） // 4.代码块 // 5.内部类&#125; 如何通过类创建对象类名 对象名称 = new 类名(); 注意 类名的首字母应该大写，满足“驼峰写法”。 一个Java代码文件中可以定义多个类。但是只能有一个类是用public修饰的，而且.public修饰的类名必须成为代码的文件名称。 构造器构造器的作用通过调用构造器可以返回一个类的对象，构造器同时负责帮我们把对象的数据（属性和行为等信息）初始化好。 构造器的格式修饰符 类名(形参列表) &#123; // 构造体代码，执行代码&#125; 构造器初始化对象类名 对象名称 = new 构造器; 注意 一个类默认会自带一个 无参数构造器，即使不写它也存在， 但是如果一个类它写了一个构造器，那么默认的无参数构造器就被覆盖了! 封装什么是封装是Java语言的风格。是我们在开发中必须遵循的，即使毫无意义，代码还是要按照这个风格写! ! 封装的作用 1.可以提高安全性。 2.可以实现代码的组件化。 封装的步骤 使用 private 关键字来修饰成员变量。 使用public修饰getter和setter方法。 this关键字this关键字的作用 this代表所在类的当前对象的引用（地址值），即代表当前对象。 this关键字可以用在实例方法和构造器中。 this出现在实例方法中，谁调用这个方法（哪个对象调用这个方法），this就代表谁（this就代表哪个对象）。 this用在构造器，代表了构造器正在初始化的那个对象的引用 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ThisDemo02 &#123; public static void main(String[] args) &#123; Animal animal = new Animal(); animal.setName(&quot;小明&quot;); Animal animal1 = new Animal(&quot;哈哈&quot;,&#x27;男&#x27;); &#125;&#125;class Animal&#123; private String name; private char sex; /** * @return this.name * this有时候可以省略 * this-&gt;animal */ public String getName() &#123; return name; &#125; /** * @param name * 谁调用这个方法，this就指向谁 * this-&gt;animal animal.name = 小明 */ public void setName(String name) &#123; this.name = name; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125; /** * @param name * @param age * @param sex * * this-&gt;animal1 * animal1.name = 哈哈 * animal1.sex = 男 */ public Animal(String name, char sex) &#123; this.name = name; this.sex = sex; &#125; public Animal() &#123;&#125;&#125; static关键字引入我们之前定义了很多成员变量(name ,age，sex)，其实我们只写了一份，但是发现每个对象都可以用，就说明Java中这些成员变量或者方法是存在所属性的。有些是属于对象的，有些是属于类本身的。 如何理解 被static修饰的成员是属于类的是放在静态区中 没有static修饰的成员变量和方法则是属于对象的 成员变量有无static区分 有static修饰：属于类叫静态成员变量，与类一起加载一次， 直接用类名调用即可。 无static修饰：属于类的每个对象的叫实例成员变量，与类的对象一起加载，对象有多少个，实例成员变量就加载多少份。必须用类的对象调用 成员方法有无static区分 有static修饰：属于类叫静态方法，直接用类名调用即可 无static修饰：属于类的每个对象的叫实例方法，必须用类的对象调用。 成员变量的访问语法123456// 静态成员变量访问:// 类名.静态成员变量。// 对象.静态成员变量。(不推荐 )// 同一个类中访问可省略类名// 实例成员变量的访问:// 对象.实例成员变量 成员方法的访问语法123456// 静态成员方法访问：// 类名.静态方法// 对象.静态方法。(不推荐 )// 同一个类中访问可省略类名// 实例成员变量访问：// 对象.实例方法 面试常问 实例方法是否可以直接访问实例成员变量? 可以的，因为它们都属于对象。 实例方法是否可以直接访问静态成员变量? 可以的，静态成员变量可以被共享访问。 实例方法是否可以直接访问实例方法? 可以的，实例方法和实例方法都属于对象。 实例方法是否可以直接访问静态方法? 可以的，静态方法可以被共享访问! 静态方法是否可以直接访问实例变量? 不可以的，实例变量必须用对象访调 静态方法是否可以直接访问静态变量? 可以的， 静态成员变量可以被共享访问。 静态方法是否可以直接访问实例方法? 不可以的，实例方法必须用对象访问! ! 静态方法是否可以直接访问静态方法? 可以的，静态方法可以被共享访问! ! 继承继承的含义 一般到特殊 是is a的关系 子类继承父类的属性和行为，使得子类对象可以直接具有与父类相同的属性、相同的行为。 子类可以直接访问父类中的非私有的属性和行为。 继承的格式通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下： 1234567class 父类 &#123;\t...&#125;class 子类 extends 父类 &#123;\t...&#125; 需要注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的 子类不能继承的内容 子类不能继承父类的构造器，因为子类有自己的构造器 (争议)子类是可以继承父类的私有成员的，只是不能直接访问而已。以后可以暴力去访问继承自父类的私有成员 (争议)子类是不能继承父类的静态成员的子类只是可以访问父类的静态成员，父类的静态成员只有一份可以被子类共享访问。共享并非继承。 继承后子类成员变量访问特点就近原则: 子类有找子类，子类没有找父类，父类没有就报错。 this代表了当前对象的引用，可以用于访问当前子类对象的成员变量。 super代表了父类对象的引用，可以用于访问父类中的成员变量。 方法重写的概念 发生在子父类之间的关系 子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。 子类返回值类型范围相同或者更小 子类修饰符权限相同或者更大 子类异常抛出范围一样或更小 @Override重写注解 这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。 建议重写都加上这个注解，一方面可以提高代码的可读性，一方面可以防止重写出错！ 注意 父类被重写后只能通过子类中转调用或者实例化父类调用 私有方法和静态方法都不能被重写 继承后构造器特点子类所有构造器的第一行都会先调用父类的无参构造器，再执行自己（先有爸爸，才能有儿子） 可以在子类构造器中使用super(…)调用指定构造器，以便初始化继承自父类的数据 this关键字拓展可以使用this关键字实现构造器默认值：this(…)可以根据参数类型访问本类其他构造器。此时！由对应被调用的构造器去调用父类构造器 注意：this(…)和super(…)必须放在构造器的第一行， 否则报错!所以this(…)和super(…)不能同时出现在构造器中!! 继承的特点 Java只支持单继承，不支持多继承。 假如可以多继承，若两个父类都有某一方法，且子类多继承这两个父类，在实例化子类时调用这个相同的方法，则会程序出现不知道调用谁而出现类的二义性！ 一个类可以有多个子类。 可以多层继承。 顶层父类是Object类。所有的类默认继承Object，作为父类。 抽象类概念 抽象方法 ： 没有方法体的方法。 抽象类：包含抽象方法的类。 public abstract void run()； 特征与注意事项 继承抽象类的子类必须重写父类所有的抽象方法 无法创建对象(其他的都有) 假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义 有构造器 供子类创建对象时，初始化父类成员使用的。 意义 为了派生子类 体现模板思想，部分实现、部分抽象，可以设计模板设计模式 设计模式——优秀软件设计架构和思想 模板设计模式作用：优化代码架构，提高代码复用型，实现部分实现，部分抽象，抽象部分交给使用模板的人重复实现 接口概述 体现的是规范的思想（公开） 接口是更加彻底的抽象 在JDK8之前，接口中的成分包含：抽象方法和常量 public static final（抽象类里可省略） 常量：变量值只有一个，而且在程序运行的过程中不可更改!变量名全大写 12345678//接口的定义格式：修饰符 interface 接口名称&#123; // 抽象方法&#125;// 修饰符：public|缺省// 接口的声明：interface// 接口名称：首字母大写，满足“驼峰模式” 使用 一个类实现接口，这个称为实现类。 接口是用来被类实现的，实现的关键字是implements,按口可以多实现。 一个类实现接口必须重写完接口中全部的抽象方法，否则这个类要定义成抽象类 类与接口之间的关系是多实现的，一个类可以同时实现多个接口 意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。 123456/**接口的实现： 在Java中接口是被实现的，实现接口的类称为实现类。 实现类的格式:*/[修饰符] class 类名 implements 接口1,接口2,接口3...&#123;&#125; 接口与接口之间是可以多继承的 12345678910111213141516171819public interface Abc &#123; void go(); void test();&#125;/** 法律规范：接口*/public interface Law &#123; void rule(); void test();&#125; * * 总结： * 接口与类之间是多实现的。 * 接口与接口之间是多继承的。 * */public interface SportMan extends Law , Abc &#123; void run();&#125; JDK 8之后的接口新增方法接口不再纯洁了，接口中不再只是抽象方法，接口还可以有默认方法（也就是实例方法），和静态方法了，还包含了私有实例方法和私有静态方法 默认方法：默认加入public修饰，可省略；使用 default 修饰，不可省略，供子类调用或者子类重写。 静态方法：默认加入public修饰，可省略；使用 static 修饰，供接口直接调用。 私有方法：1.9开始新增，使用 private 修饰，供接口中的默认方法或者静态方法调用。 1234567891011public interface InterFaceName &#123; public default void method() &#123; // 执行语句 &#125; public static void method2() &#123; // 执行语句 &#125; private void method() &#123; // 执行语句 &#125;&#125; 接口小结 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。 接口中的方法全是抽象方法，默认会自动加上public abstract修饰 JDK 8开始，接口不再纯洁，支持静态方法，默认方法，私有方法。 接口中，没有构造器，不能创建对象。 类与接口是多实现的 接口与接口是多继承的 接口体现的规范。 代码块静态代码块 每次执行类，加载类的时候都会先执行静态代码块一次。 静态代码块是自动触发执行的，只要程序启动静态代码块就会先执行一次。 作用：在启动程序之前可以做资源的初始化，一般用于初始化静态资源。 static&#123; // 执行代码&#125; 实例代码块 无static修饰。属于对象，与对象的创建一起执行的。 每次调用构造器初始化对象，实例代码块都要自动触发执行一次。 实例代码块实际上是提取到每一个构造器中去执行的。 作用：实例代码块用于初始化对象的资源。 &#123; // 执行代码&#125; final关键字基本知识 final： 不可改变，最终的含义。可以用于修饰类、方法和变量。 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，有且仅能被赋值一次。 修饰局部变量时，防止在执行过程中被修改 修饰成员变量 时可以在被定义的 时候赋值一次，或者在静态代码块里赋值一次 abstract和final是互斥关系，不能同时修饰成员 单例设计模式什么是单例？ 一个类只有一个对象实例，可以节约内存提高性能，有8种 有哪些？ 饿汉单例设计模式使用类的时候已经将对象创建完毕，不管以后会不会使用到该实例化对象，先创建了再说 123456789101112public class Singleton &#123; // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 private Singleton() &#123;&#125; // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。 private static final Singleton instance = new Singleton(); // 3.定义一个静态方法返回这个唯一对象。 public static Singleton getInstance() &#123; return instance; &#125;&#125; 懒汉单例设计模式调用getInstance()方法时实例才被创建，先不急着实例化出对象，等要用的时候才例化出对象 12345678910111213141516public class Singleton &#123; // 2.在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型的成员变量。 private static Singleton instance; // 1.将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。 private Singleton() &#123;&#125; // 3.定义一个静态方法返回这个唯一对象。要用的时候才例化出对象 public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 枚举类定义枚举的格式enum 枚举名 &#123; //第一行都是罗列枚举实例,这些枚举实例直接写大写名字即可。 BOY, GIRL; // 男，女&#125; 特点 final修饰的，不能被继承 枚举是不能在外部创建对象的，枚举的构造器默认是私有的。 枚举类在第一行罗列若干个枚举对象。（多例） 第一行都是常量，存储的是枚举类的对象。 枚举通常用于做信息的标志和分类。 使用Sex s ＝ Sex.BOY // BOYs.ordinal() // 枚举对象索引位置 多态概念同一个类型对象，执同一个行为，在不同状态下表现出不同的行为特征，多态是出现在继承或者实现关系中的。 格式：// 方法调用（行为）：编译看左边，运行看右边// 变量调用：编译运行都看左边父类类型 变量名 = new 子类/实现类构造器;变量名.方法名(); 存在条件 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 多态优势 组件化切换，可以实现类于类的解耦 拓展性，便利 不能调用子类独有的功能，小范围自动转换为大范围 内部类提供更好的封装性，内部类也更多权限修饰符，封装性也更多控制，体现出组件的思想，寄身 静态内部类 属于外部类本身，只会加载一次，可以通过外部类名称.内部类名称实例化。内部类中可以直接访问外部类静态成员，但是不能访问实例成员 实例内部类 属于外部类对象，不能定义静态成员，但可以定义常量，可以通过外部类名称.内部类 name ＝ new 外部类().new 内部类()来实例化，可以访问外部的静态和实例成员 局部内部类 和实例内部类很像 匿名内部类 没有名字的局部内部类，也是一个匿名内部类的对象，是子类类型 权限修饰符 public protected 缺省（空的） private 本类中 √ √ √ √ 本包下的其他类类 √ √ √ 其他包下的子类 √ √ 其他包中的无关类 √","tags":["Java"],"categories":["JavaSE"]},{"title":"JVM 相关知识与面试题的结合","path":"/intvSum/JVM.html","content":"JVM 概述 什么是JVM，说说jvm的组织架构JVM，也就是 Java 虚拟机，在运行Java程序的时候编译器会把Java源文件编译成平台无关的class字节码文件，然后再由虚拟机进行解释，把字节码文件翻译成对应的二进制指令。这也是Java为什么具有跨平台性的核心原因。JVM由类加载器、运行时数据区、执行引擎三大部分组成。首先Java类被编译成class文件之后，会进到类加载子系统，经过验证、准备、解析、初始化之后把类加载成class对象到内存的方法区。在内存中有方法区、堆、本地方法栈、虚拟机栈，被加载到方法区的类对象会执行其二进制指令，其中每个线程方法会被压入虚拟机栈，虚拟机栈有每个方法对应一个栈帧，每个栈帧有局部变量表、操作树栈、动态链接、放回方法地址等，方法会在栈帧中执行，如果创建了对象，则对象会被放在堆中，堆一般被分为新生代和老生代，这还涉及到GC算法。 类加载器：负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。 运行时数据区：JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域主要包括方法区、堆、虚拟机栈、程序计数器和本地方法栈。 执行引擎：是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器，还包括即时编译器（JIT Compiler）和垃圾回收器（Garbage Collector）。 类加载子系统 类加载子系统是如和工作的？将编译好的字节码文件（.class 文件）加载到 Java 虚拟机 (JVM) 中 加载：类加载器读取字节码文件，并将其内容转换为二进制流，再在内存中创建一个 java.lang.Class 对象来表示这个类。 验证：对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。 准备：对类变量（也称为静态变量，static 关键字修饰的变量）分配内存并初始化，初始化为数据类型的默认值，如 0、0L、null、false 等，但是不包括static静态代码块。 解析：是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、成员方法等。 初始化：在准备阶段，类变量已经被赋过默认初始值了，而在初始化阶段，类变量将被赋值为代码期望赋的值。 类加载子系统是将class文件加载成内存中的方法区的class对象，类加载过程主要包含三个阶段：加载、链接、初始化；他会先从文件系统、网络或其他来源加载 Class 文件，读取类的二进制数据到内存中。然后进行验证，确保加载的类符合 JVM 规范，比如说验证文件格式继承结构的正确性、常量池中的常量是否有效。然后进行准备，为类的静态变量分配内存并设置默认初始值。再然后进行解析，把类中的符号引用转换为直接引用，比如类和接口的符号引用、字段和方法的符号引用解析为直接引用。解析完后进行初始化，比如初始化类的静态变量和执行静态代码块。 类加载器有哪些？他们是如何工作的 Bootstrap ClassLoader（启动类加载器）：负责加载 JVM 的核心类库，是c&#x2F;c++写的是最顶层的加载器。 Extension ClassLoader（扩展类加载器）：负责加载JAVA_HOME/jre/lib/ext目录下，或者由系统属性java.ext.dirs指定位置的类库 Application ClassLoader（应用程序类加载器）：负责加载系统类路径CLASSPATH上的类库，通常是我们在开发 Java 应用程序时的主要类加载器。 User-defined ClassLoader（用户自定义类加载器）：我们可以通过继承java.lang.ClassLoader类来创建自己的类加载器。 这四个加载器从用户自定义加载器到启动类加载器，从下到上构成了分层非继承的关系，也就是用户类加载器的上一级是应用程序加载器，每层都是往上如此，当加载请求到来时他们会从下往上依次把请求交给上一级，直到最顶层。如果父类加载器能够加载该类，则直接返回；如果不能那么子类加载器才会尝试加载。这种加载机制构成了双亲委派模型。 双亲委派模型有什么好处？如果用户自定义了一个java.long.String类，通过这种加载机制也会先找到顶层的类加载器加载并返回Class对象，既可以防止核心API被篡改，保证Java体系的稳定，也可以避免类的重复加载，如果没有这种模型，可能会导致同一个类被不同的类加载器重复加载到内存中 为什么要打破双亲委派模型，怎么打破？ 要打破双亲委派模型肯定是有对应的需求 自定义类加载需求：可以通过继承java.lang.ClassLoader类并重写findClass方法来实现自定义的类加载器，比如直接加载类而不是委托给父加载器 插件化需求：比如我们熟悉的JDBC各个厂商都有不同的JDBC实现，但是Java核心包里也有，而各个厂商的实现，是没办法放在核心包里的，只能放在classpath里，也就只能由AppClassLoder 进行加载，如果遵循模型，那么只会优先加载Java核心包里的。那么我们可以通过设置线程上下文类加载器来让某个线程使用不同的类加载器加载类 热更新：比如例如代码热替换（Hot Swap），因为双亲委派模型是使用已经加载的类而不是尝试重新加载，那么我们监控类文件或配置文件的变更来触发热部署，重写findClass()方法，当需要跟新时就把类加载器换掉。 为什么Tomcat需要自定义类加载器？Tomact 是 web 容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。所以，Tomcat 破坏了双亲委派模型，提供隔离的机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。并且Tomcat的热加载也是需要破坏双亲委派模型 JVM内存能简单说一下 JVM 的内存区域吗？ JVM 的内存区域，有时叫 JVM 的内存结构，有时也叫 JVM 运行时数据区，其中包含方法区、堆，Java方法栈、本地方法栈、程序计数器 其中方法区和堆是线程共享的，其他的都是线程私有的，然后我把每个都大致说一下功能 程序计数器：较小内存空间，不存在内存溢出问题，前线程所执行的字节码行号指示器 Java虚拟机栈：线程独有的，生命周期和线程一致，执行一个方法时压入一个栈帧，执行完毕后被移除，栈不存在垃圾回收问题，但是存在内存溢出问题 本地方法栈：其实和虚拟机栈差不多，只是虚拟机栈是由Java写的，而本地方法栈是为 Java 调用本地（native）方法服务的，由 C&#x2F;C++ 编写。 堆：是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储对象的。也是垃圾回收器作用的主要区域。 方法区：方法区并不真实存在，属于 Java 虚拟机规范中的一个逻辑概念，用于存储已被 JVM 加载的类信息、常量、静态变量，在JDK1.8前叫永久代，后面就改名为直接内存中划出一块区域作为元空间，运行时常量池、类常量池都移动到元空间。 为什么PC寄存器为什么会被设定为线程私有的？首先多线程如果共享一个计数器，当一个线程被中断，另一个线程开始执行的时候程序计数器会被错误的更新，这样会破坏前一个线程的状态。如果是线程独享的，那么在进行线程调度的时候他都可以保存当前执行状态，这种隔离性在多线程中至关重要。 Java虚拟机栈如何进行方法计算的？ 局部变量表（Local Variable Array）：当方法被调用时，传入的参数会被存储在局部变量表中。对于实例方法，第一个局部变量总是this引用，指向调用该方法的对象。局部变量表中的变量可以通过索引来访问。 操作数栈（Operand Stack）：用于临时存储中间结果，以及作为方法调用和返回过程中参数传递的工具。 动态链接（Dynamic Linking）：因为多态概念的存在，所以编译器在编译的时候并不知道对象类型，所以只有在运行时才能确定对象，指向常量池里方法的引用。 方法返回地址（Return Address）：当方法执行完成后，返回到调用方法的地址。 当一个线程调用一个方法时，JVM会为这个方法分配一个新的栈帧，并将其压入当前线程的JVM栈中，栈帧里有局部遍历表、操作数栈、动态链接、方法返回地址等等。JVM中的解释器会逐条读取并执行方法中的字节码指令，比如将操作数栈中的值进行算术运算后存储到局部变量表，将局部变量表中的值加载到操作数栈，具体操作会根据字节码指令来，比如在不同数据类型之间进行转换、创建和操作对象、条件判断、循环和方法调用等。 对象创建的过程了解吗？销毁呢当我们使用 new 关键字创建一个对象的时候，JVM 首先会检查 new 指令的参数是否能在常量池中定位到一个类的符号引用，然后检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程。 如果已经加载，JVM 会为新生对象分配内存，内存分配完成之后，JVM 将分配到的内存空间初始化为零值（成员变量，数值类型是 0，布尔类型是 false，对象类型是 null），接下来设置对象头，对象头里包含了对象是哪个类的实例、对象的哈希码、对象的 GC 分代年龄等信息。 最后，JVM 会执行构造方法（&lt;init&gt;），将成员变量赋值为预期的值，这样一个对象就创建完成了。 当对象不再被任何引用指向时，对象就会变成垃圾，这就涉及到垃圾回收机制。 JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？ 堆：所有线程共享的内存区域 线程本地分配缓冲区（Thread Local Allocation Buffer, TLAB）：为了减少多线程分配对象时的竞争，JVM为每个线程分配了一个私有的小堆空间每个线程在其自己的TLAB中分配内存，这样在大多数情况下，内存分配是线程私有的。 会，首先有TLAB的存在，大大减少了多线程的竞争，但是如果TLAB中没有足够的空间，比如对象太大，那就得从全局堆里分配。这就涉及到了对全局堆的竞争和同步，比如线程A给对象分配内存按流程指正应该右移一个对象size的距离，但是指针还没来得及修改，另一个线程为B分配内存又引用了这个还没来的及右移的指针，这就发生了抢占。至于JVM设计的方法，就像刚刚说的TLAB 线程本地分配缓冲区，为每个线程分配了一个私有的小堆空间每个线程在其自己的TLAB中分配内存，这样在大多数情况下，内存分配是线程私有的。还有采用CAS 比较并交换（Compare And Swap）他是一直乐观锁实现方式，用来保证更新的原子性，就是类似于版本控制一样的，会把要更新的变量和预期值进行判短，如果符合预期那就更新不符合就不更新。 能说一下对象的内存布局吗？具体的实现细节可能因不同的 JVM 实现（如 HotSpot、OpenJ9 等）而异。我这里以HotSpot为例，对象在堆内存中的存储布局可以划分为三个部分：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。其中对象头 有标记字（Mark Word）、类型指针（Class Pointer）、数组长度（Array Length）。然后标记字里面又包含了对象自身的运行时数据，如哈希码（HashCode）、垃圾回收分代年龄、锁状态标志、线程持有的锁、偏向线程 ID 等信息。在 64 位操作系统下占 8 个字节，32 位操作系统下占 4 个字节。 内存溢出和内存泄漏是什么意思？能举个例子吗内存溢出（Out of Memory，俗称 OOM）和内存泄漏（Memory Leak）是两个不同的概念，但它们都与内存管理有关。内存溢出是程序请求分配内存时，由于没有足够的内存空间满足其需求，而内存泄漏是指程序在使用完内存后，未能释放已分配的内存空间，导致这部分内存无法再被使用。随着时间的推移，内存泄漏会导致可用内存逐渐减少，最终可能导致内存溢出。 内存泄漏可能由哪些原因导致呢？怎么解决 使用静态集合类存储对象，这些对象可整个生命周期内都不会被清除 创建的连接不再使用时，需要调用 close 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。 长生命周期的对象引用了短生命周期的对象，导致导致短生命周期对象无法被回收。 ThreadLocal 的弱引用导致内存泄漏也是个老生常谈的话题了，使用完 ThreadLocal 一定要记得使用 remove 方法来进行清除。 知道了原因要解决就相对简单了，比如尽量避免非静态内部类，写代码的时候及时释放资源等等 说一下对象有哪几种引用？Java 中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。 强引用就是最传统的引用的定义，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象 软引用 ，SoftReference实现，用来描述一些还有用，但非必须的对象，只被软引用关联着的对象，如果将要发生内存 溢出了就会被回收， 弱引用，WeakReference实现，描述那些非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。 虚引用，PhantomReference实现，也称为“幽灵引用”或者“幻影引用”，为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。 对象一定分配在堆中吗？有没有了解逃逸分析技术？（待补充）垃圾回收Minor GC&#x2F;Young GC、Major GC&#x2F;Old GC、Mixed GC、Full GC 都是什么意思？Minor GC 也称为 Young GC，是指发生在年轻代（Young Generation）的垃圾收集。Major GC 也称为 Old GC，主要指的是发生在老年代的垃圾收集。Mixed GC 是 G1 垃圾收集器特有的一种 GC 类型，它在一次 GC 中同时清理年轻代和部分老年代。Full GC 是最彻底的垃圾收集，涉及整个 Java 堆和方法区（或元空间）。它是最耗时的 GC，通常在 JVM 压力很大时发生。 为什么JVM要垃圾回收？你知道哪些垃圾回收器垃圾回收GC，有多种垃圾回收器，我知道的有8种，每种回收器可能使用了不同的算法，一步一步来，第一为什么jvm要进行垃圾回收，垃圾就是JVM中没有任何引用指向它的对象，如果不清理就会一直占用内存，然后垃圾对象越来越多就可能出现OOM（Out Of Memory）内存溢出。 名称 执行方式 执行目标 使用算法 Serial GC STW、串行、单线程 新生代 复制算法 Serial Old GC STW、串行、单线程 老年代 标记-整理算法 ParNew GC STW、并行、多线程 新生代 复制算法 CMS GC 低暂停、并行 老年代 标记-清除算法 Parallel GC STW、并行、多线程 新生代 复制算法 Parallel Old GC STW、并行、多线程 老年代 标记-整理算法 G1 GC 低暂停，并行 整堆 标记-复制算法 ZGC 低暂停，并行 整堆 标记-复制算法 STW：暂停工作线程，存在是因为Java的垃圾回收器需要扫描整个堆内存来标记和清除不再使用的对象，如果不停止应用线程的话，会导致垃圾回收器扫描时出现漏标和误删的情况。 堆：是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储对象的。也是垃圾回收器作用的主要区域。他分为新生代和老年代，两个区域比例为1:2： 新生代：包含Edan、s0（Survivor），s1三个部分，比例为8:1:1，一般对象来的时候先放到edan区，edan区里新对象来之后触发垃圾回收，把还在用的对象放全部到S0或者S1，然后更新GC次数，edan区触发垃圾回收时s0和s1会进行角色交换，每次交换GC次数也会增加，而且S0和S1两个不能同时存放对象，就是因为设计了角色交换机制，并且可以避免内存碎片化。当新生代里对象GC次数达到15次以上后，就会把对象移到老年代。这里我之前说了一般对象来的时候先放到edan区，如果来了一个很大的对象，Edan区可以放下但是s0，s1放不下，那么他后续就不会再放到s0或s1而是直接放到老年代，如果来了一个更大的对象，edan区都放不下，那么就会直接放到老年代。在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，那么年龄大于或等于该年龄的对象就可以直接进入老年代。 老年代：对象来到老年代后触发的回收机制就会和新生代不一样。 标记-复制算法：典型的空间换时间的算法，他有两块内存空间，每次只使用一个在垃圾回收时会把可达对象复制到没有用的那块内存，这样不会产生内存碎片也很高效，所以比较适合新生代这种垃圾对象多的 标记-整理算法：先对内存中存货的对象进行标记，然后清除垃圾对象，再把存活对象移到内存一段，这样也不会产生内存碎片，但是速度也慢所以适合老年代。 标记-清除算法：先对内存中存货的对象进行标记，然后清除垃圾对象，会产生内存碎片，速度较快 GC ROOT：是一组特殊的对象集合，它们作为活跃对象的根节点，垃圾收集器能够通过GC ROOT遍历整个对象引用图，从而标记出哪些对象是可达的（活跃的），哪些对象是不可达的（无用的） 初始标记：只标记GC ROOT的第一层，很快 三色标记：它将对象分为三类：白色、灰色和黑色，所有对象开始都是白色的，从 GC Root 开始，将根对象标记为灰色，然后把灰色对象的所有白色对象标记为灰色，再把这个灰色对象标记为黑色，按照这个逻辑进行重复扫描、标记。 白色：未被访问的对象，在标记阶段结束时，所有仍然是白色的对象都是不可达的，将被垃圾收集器回收 灰色：已被访问但其引用的对象还未全部被访问的对象，需要进一步扫描 黑色：黑色对象和它们引用的对象都是可达的，不会被回收 然后说回jvm的垃圾回收器，在jdk8之前，用的是Serial GC和Serial Old GC，他们会进行STW也就是暂停工作线程，他们是单线程的，jdk8之前被引入，分别针对的是Java堆中的新生代和老年代，Serial GC用的是复制算法，典型的空间换时间的算法，他有两块内存空间，每次只使用一个在垃圾回收时会把可达对象复制到没有用的那块内存，这样不会产生内存碎片也很高效，所以比较适合新生代这种垃圾对象多的。然后Serial Old GC，用的标记-整理算法，就是先对内存中存货的对象进行标记，然后清除垃圾对象，再把存活对象移到内存一段，这样也不会产生内存碎片，但是速度也慢所以适合老年代。对应的还有Parallel GC和Parallel Old GC他们对应的是Serial GC和Serial Old GC的多线程版本。 还有ParNew GC和CMS GC，不过对于CMS GC，他有个特点就是低暂停，他会先先通过GC ROOT找到直接可达的对象，我们知道GC ROOT 是特殊的特殊的对象集合，如果是完整的标记则需要通过GC ROOT遍历整个对象引用图，从而标记出哪些对象是可达的，哪些对象是不可达的，但是CMS GC是先进行初始标记，就是只标记GC Roots，这样是很快的，然后是并行标记，他把从GC ROOT遍历整个对象引用图的过程放到和用户线程并行运行，也就是没有暂停用户线程，但是同样的吞吐量会降低，因为单位时间用户线程数变少了，耗时较长，而且因为用户线程在工作，所以会产生新的对象或者之前标记的垃圾对象又变成非垃圾对象了，所以jvm通过三色标记来解决这个问题，三色标记它将对象分为三类：白色、灰色和黑色，白色表示未被访问的对象，在标记阶段结束时，所有仍然是白色的对象都是不可达的，将被垃圾收集器回收，灰色就是已被访问但其引用的对象还未全部被访问的对象，就需要进一步扫描，黑色对象和它们引用的对象都是可达的，不会被回收，一开始所有对象都是白色，然后从GC ROOT开始，把对象标记成灰色，当GC ROOT的引用对象被全部访问就标记为黑色。然后进行STW重新标记，也就是进行一些收尾动作，矫正之前标记产生的误差，是增量更新，所以耗时也不长，然后和用户线程并发清理垃圾对象和并发重置标记。所以CMS GC把标记和清理两个最耗时的操作放到和用户的线程一起并行运行，更高效。 讲讲G1 GC和ZGC最后就是G1 GC和ZGC，G1 在 1.9 版本后成为 JVM 的默认垃圾回收算法，G1 的特点是保持高回收率的同时，减少停顿。取消了堆中年轻代与老年代的物理划分，但它逻辑上仍然属于分代收集器。G1 算法将堆划分为若干个区块，默认是2048个，称作 Region，相当于把新生代代和老年代给拆分成一小块一小块的，一个区块可能是Eden或者Survivor也可能是Old或者大对象。需要注意的是ZGC虽然也采用Region但是Region并不是定长的，可以分为大区块和小区块，G1的垃圾回收过程除开新生代，新生代是直接使用STW进行标记复制算法，后续的回收为混合回收，在回收老年代的时候也会回收新生代，混合回收的过程可以简单概括为，初始标记、并发标记、再标记、清理、复制。其实其过程和CMS GC差不多，最大的不同是在回收阶段，CMS GC是并发清理垃圾对象，然后并发重置垃圾对象，而C1是筛选回收，会筛选出具有性价比的区块进行并发回收，并且可以调整STW的时间。 对于ZGC，首先在说ZGC之前需要说明两个关键技术：着色指针和读屏障技术。着色指针就是将信息存储在指针中，并且仅支持64位系统，当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址，ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。ZGC之所以设置三个虚拟地址空间，是因为它使用“空间换时间”思想，去降低GC停顿时间。“空间换时间”中的空间是虚拟空间，而不是真正的物理空间。这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。读屏障技术就是JVM向应用代码插入一小段代码，仅当应用线程从“从堆中读取对象引用”才会触发这段代码。这一小段代码可以在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。 然后就是ZGC到底是怎么进行垃圾回收的，首先初始化，整个地址视图会进行Remapped，程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入并发标记阶段。第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。标记结束后就进入并发转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。其实，在标记阶段存在两个地址视图M0和M1，上面的过程显示只用了一个地址视图。之所以设计成两个，是为了区别前一次标记和当前标记。也就是说，第二次进入并发标记阶段后，地址视图调整为M1，而非M0。在并发转移阶段，只需要设置指针地址的第42~45位即可，并且因为是寄存器访问，所以速度比访问内存更快。 ZGC为什么快？CMS GC和G1 GC性能瓶颈在哪了解，首先先说CMS GC和G1 GC性能瓶颈，我们知道CMS GC新生代的Young GC和C1 GC、ZGC都是基于标记复制算法，只是实现有很大不同，我们以G1为例，在混合回收的时候会有4个STW，其中初始标记阶段，初始标记因为只标记GC Roots，耗时较短；再标记因为是增量更新对象数少，耗时也较短；清理阶段，清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制，因为内存分区数量少，耗时也较短；复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。G1的Young GC和CMS的Young GC，其标记-复制全过程STW，就不再阐述。 全并发的ZGC：ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。ZGC只有三个STW阶段，初始标记，再标记，初始转移。其中初始标记和初始转移只需要扫描所有GC Roots处理时间都非常短，最多1ms，超过1ms则再次进入并发标记阶段。ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。 你们线上用的什么垃圾收集器？为什么要用它？我们生产环境中采用了设计比较优秀的 G1 垃圾收集器，因为它不仅能满足低停顿的要求，而且解决了 CMS 的浮动垃圾问题、内存碎片问题。G1 非常适合大内存、多核处理器的环境。 执行引擎知道JIT吗？他有什么用（待补充）JVM调优有做过 JVM 调优吗？怎么做的（待定）在没有全面监控收集到性能数据前都不适合动JVM，JVM 调优是一个非常复杂的过程，最多就是调调栈、堆的大小，比例关系，但是我任然认为在没有完整的性能数据前都不需要动jvm。我在项目里一般都是先优化自己写的代码，但是我学习了一些jvm调优的思路：","tags":[null,null],"categories":[null]},{"title":"Java多线程","path":"/intvSum/JavaThread.html","content":"工作中你是怎么使用线程的？这个看使用场景，在一些框架比如spring就里就直接new thread，用来在启动类的时候多线程去过滤自动配置类，但是呢这种一般就用一次，所以没有什么问题。但是在很多情况下，比如我们是对外服务的接口，如果没有使用线程池，就可能导致线程的大量创建，占用大量资源。所以使用线程池的好处就是可以减少线程的重复创建和销毁，进而节省系统资源开销，所以通常在开发中都是使用线程池管理线程资源。 你是怎么使用线程池的？为什么不推荐使用Executorst创建线程池Executorst里通常有三中创建方式，比如newFixedThreadPool、newSingleThreadExecutor、newCachedThreadPool，其中newFixedThreadPool可以指定创线程数，但是他设置的阻塞队列（LinkedBlockingQueue）是设置的Integer的最大值（21亿多），在高并发情况下等待队列足够多就可能造成oom，newSingleThreadExecutor 同样也是一个无界的阻塞队列，也可能会有oom的问题。newCachedThreadPool，是没有固定限制的线程池，会根据请求量动态扩容线程，线程的最大数也是Integer的最大值，所以在高并发的情况下会创建大量的线程，也可能造成oom。 线程池参数说明： corePoolSize：核心线程数量 maximumPoolSize:量最大线程数量 keepAliveTime:非核心线程的空闲状态的存活时间 unit:时间单位(天、小时..） workQueue:工作队列（阻塞队列BlockingQueue） threadFactory：线程工厂（创建线程） handler:拒绝策略 构建好线程池之后就可以使用execute提交任务了，这个过程呢会先判断核心线程数是不是满了，没有满那么直接创建线程执行任务，满了就再判断阻塞队列是不是满了，没有满就放在阻塞队列中进行排队，满了就会创建一些临时线程，不能超过最大线程数，超过了就会触发拒绝策略。在临时线程到达最大存活时间时，那么就销毁掉这些临时线程 线程池处理线程的过程以及细节： 核心满了-&gt;阻塞队列-&gt;临时线程-&gt;拒接策略 调用execute ，判断当前所有活跃线程是否小于核心线程数，如果小于，调用addWoker()方法（带有一个布尔类型的core参数，用于判断是否为核心线程，以便于把当前添加的线程数对核心线程数和最大线程数进行判断），创建worker对象，获得当前的线程工厂（创建线程池的时候设置，默认创建一个普通的线程） 如果核心线程满了，塞阻塞队列 阻塞队列没塞成功，会去创建非核心线程 非核心线程没创建（最大线程数满了），那么触发拒绝策略 再调用这个任务的run方法（主线程执行） 移除阻塞队列头部，再调用execute方法执行这个任务 用于子类拓展，无任何执行 如果线程1任务执行完了，现在又来了一个任务，那么这个任务是给线程1执行，还是把任务给创建的新线程执行 如果当前线程数小于核心线程数，那么调用addwork创建新线程 如果当前线程数达到了核心线程数，塞进阻塞队列，只有当前线程数等于0时才会创建新线程，有的话就由空闲线程去阻塞队列里拿任务，而阻塞队列也满了才会去创建临时线程 如果临时线程执行完任务了，在什么时候被销毁？ 线程去拿任务的时候，会先获取当前线程数量，再去和核心线程数比较，如果当前线程数大于核心线程数，会再继续去阻塞队列里拿线程，如果阻塞队列里没有任务那么阻塞时间就是线程的最大空闲时间，如果当前线程数小于核心线程数，就会无限阻塞。 如果线程触发了最大空闲时间的睡眠，那么会使用CAS的方式去把线程数量-1，其实也就没有严格区分核心线程和临时线程，而是随机销毁。 如果任务出现异常，线程会如何处理？ 任务出现异常，被catch捕捉到，并被抛出，然后执行finally（执行addwork，会判断线程池是否关闭，再 把当前线程销毁后加一个线程）。 如果再某些任务中没有去捕获异常，那么就会触发未捕获异常的机制，进行兜底去处理异常 线程关闭shutdown()和shutdownNow() shutdown会把线程池状态改成shutdown，调用shutdownNow会把线程池状态改为stop，而线程池只有在运行中才能往阻塞队列里添加任务。线程正在执行任务的话会调用interrupt方法中断线程（非stop()，如果通过stop会把代码直接断掉，可能产生异常，不推荐使用），而interrupt只是对线程进行标记，告诉 线程你需要关闭，具体是否中断由自己的方法体决定，线程一般会正常的执行并关闭。 如果当前线程池是shutdown并且队列为空，那么直接销毁线程，如果队列还有任务，那么可以正常往下走，如果是stop状态，那么就会直接销毁线程，不会让你拿队列里的任务，如果有线程正在拿任务，被一直阻塞在队列，那么会触发interrupt异常，捕捉到异常后把超时的标志设置为true，继续正常执行触发超时销毁。如果线程正好拿到了任务，那边把当前线程标记为interrupt，任务正常执行并关闭。 volatile 这个关键字有什么用（待定）","tags":[null],"categories":[null]},{"title":"MQ","path":"/intvSum/MQ.html","content":"为什么使用消息队列(MQ) 核心：解耦、消峰、异步"},{"title":"Java基础进阶","path":"/intvSum/JavaAdv.html","content":"序列化Java序列化与反序列化是什么？为什么需要 序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。以便能够将该对象保存到文件、数据库，或者进行网络传输 反序列化就负责从一个字节流读取Java对象。以便构建原始对象。 Serializable 接口有什么用？ Serializable接口用于标记一个类可以被序列化。这个接口没有定义任何方法，它是一个空接口 serialVersionUID 是 Java 序列化机制中用于标识类版本的唯一标识符。它的作用是确保在序列化和反序列化过程中，类的版本是兼容的，一般设置为1L，也可以有idea随机生成，只要保证在序列化和反序列化的过程中是一致的即可。当然如果不设置，java序列化机制会根据Class自动生成一个serialVersionUID。 Java序列化有什么安全问题没因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 ArrayList是怎么进行序列化的？比如数组长度为100但其实只用了70，剩下的30就不用序列化，这样不但提高效率还节省空间。 在源码中arraylist定义了readObject和writeObject用于序列化和反序列化，还使用了transient来修饰存储元素的elementData的数组，让成员属性不被序列化，在arraylist序列化的时候会先序列化没有被static、transient修饰的的字段，然后遍历数组，将存储元素的elementData的值取出来，然后写入输出流。反序列化类似，主要是在反序列化的时候需要把数组扩容到原始（被序列化前的）大小 I&#x2F;OJava 中 IO 流分为几种?Java IO 流的划分可以根据多个维度进行，包括数据流的方向（输入或输出）、处理的数据单位（字节或字符）、流的功能以及流是否支持随机访问等。 方向： 输入流（Input Stream）：从源（如文件、网络等）读取数据到程序。 输出流（Output Stream）：将数据从程序写出到目的地（如文件、网络、控制台等） 单位： 字节流（Byte Streams）：以字节为单位读写数据，主要用于处理二进制数据，如音频、图像文件等。 字符流（Character Streams）：以字符为单位读写数据，主要用于处理文本数据。 功能： 节点流（Node Streams）：直接与数据源或目的地相连，如 FileInputStream、FileOutputStream。 处理流（Processing Streams）：对一个已存在的流进行包装，如缓冲流 BufferedInputStream、BufferedOutputStream。 管道流（Piped Streams）：用于线程之间的数据传输，如 PipedInputStream、PipedOutputStream。 IO 流用到了什么设计模式？（待定）文本存储是字节流还是字符流，视频文件呢？无论是文本还是视频文件他们在物理层面都是以字节流的形式进行存放，区别在于我们怎么通过Java来处理和解释这些字节流，也就是编码后是作为字符流，还是二进制数据（字节流）。 那其实字符流就是由字节流通过虚拟机转化而来，为什么要转化？就是因为字节转化为字符比较耗时，而且还得注意编码类型。所以不如直接搞一个操作字符的IO接口，方便我们平时对字符进行操作，但是平时传音频、视频、图片这些还是使用字节流。 BIO、NIO、AIO 之间的区别？这三对应着阻塞 IO、非阻塞 IO 和异步 IO。 BIO：也就是传统的 IO，基于字节流或字符流（如 FileInputStream、BufferedReader 等）进行文件读写，基于 Socket 和 ServerSocket 进行网络通信。对于每个连接，都需要创建一个独立的线程来处理读写操作。线程在执行 I&#x2F;O 操作时被阻塞，无法处理其他任务，适用于连接数较少的场景 NIO：JDK 1.4 时引入，放在 java.nio 包下，提供了 Channel、Buffer、Selector 等新的抽象，基于 RandomAccessFile、FileChannel、ByteBuffer 进行文件读写，基于 SocketChannel 和 ServerSocketChannel 进行网络通信。实际上，“旧”的 I&#x2F;O 包已经使用 NIO 重新实现过，所以在进行文件读写时，NIO 并无法体现出比 BIO 更可靠的性能。NIO 的魅力主要体现在网络编程中，服务器可以用一个线程处理多个客户端连接，通过 Selector 监听多个 Channel 来实现多路复用，极大地提高了网络编程的性能。适用于连接数多但连接时间短的场景。 AIO 是 Java 7 引入的，放在 java.nio.channels 包下，提供了 AsynchronousFileChannel、AsynchronousSocketChannel 等异步 Channel。它引入了异步通道的概念，使得 I&#x2F;O 操作可以异步进行。这意味着线程发起一个读写操作后不必等待其完成，可以立即进行其他任务，并且当读写操作真正完成时，线程会被异步地通知。 泛型什么是Java泛型，你怎么理解他的？泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。在Java里可以用来限定集合类型、列表类型那些，也可以避免不同类型数据取出时强转引发的异常 什么是类型擦除？泛型擦除指的是参数类型在编译之后就被抹去了，也就是生成的class文件是没有泛型信息的，所以称之为擦除。但是在代码里写死的泛型类型是不会被擦除的，这也解释了为什么根据反射是可以拿到泛型信息的。因为在JDK5之前是没有泛型的，所以要保证JDK5之前编译的代码可以在之后的版本上跑，而类型擦除就是能达到这一目标的一个实现手段。（ &#x3D;&#x3D;向下兼容&#x3D;&#x3D; ） 介绍一下常用的通配符？什么是Java沃泛型的上下界限定符？ ？：未知类型 T：一个具体的Java类型 K V：键值对里的kv E：集合中的元素类型 上界限定符是extends，下界限定符是super，&lt;? extends T&gt;表示类型的上界，？这个类型要么T，要么是T的子类，&lt;? super T&gt;表示类型的下界，？这个类型是T的父类型，直到Object。也就是extends，是从我们希望类型或者子类型的数据中进行读取，是帮我们生产我们希望类型数据，而super是要往方法中传我们希望的类型，是帮我们消费。 反射你使用过Java的反射机制吗？如何应用反射？一般在业务编码中不会用到反射，在框架上用的较多，因为很多场景需要很灵活，不确定目标对的类型，届时只能通过反射动态获取对象信息。 比如在spring里就是使用使用反射机制来读取和解析配置文件，从而实现依赖注入和面向切面编等功能，比如动态代理场景可以使用反射机制在运行时动态地创建代理对象。还可以在测试的时候使用反射机制动态获取类和方法信息，实现自动化测试。 所以我认为反射的核心就两个字 动态，动态的创建对象、动态的获取类信息、动态的改变对象的行为。我们都知道 Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。 这也造成反射存在性能问题，并且因为是动态的，会破坏方法的封装性。 String为什么String要设计成Final类?字符串本质是由char数组实现的（jdk9为byte），字符串的不可变也就是char数组不可变，假如我们通过反射方法获取到字符串的字段，并且强行更改char数组的值，那么在对相同字符串进行比较的时候，会出现equals方法为true，而hashcode却不一样，这违背了Java设计规则，也就是equals相同那么hashcode也应该相同（为了保证在使用哈希结构（如 HashMap、HashSet）时的正确性）。 而且当String不可变，那么就可以放进常量池（保证指向常量池中的同一个对象），不但可以节约内存，而且更容易进行缓存和重用 String 和 StringBuilder、StringBuffer 的区别？ String：不可变的，每次对象进行修改操作（如拼接、替换等）实际上都会生成一个新的String对象。（可能会导致内存和性能开销） StringBuffer：可变且线程安全，适合多线程环境中的频繁字符串修改。StringBuffer就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类，把所有修改数据的方法都加上了synchronize，但是保证线程安全是需要付出性能代价的。 StringBuilder：可变且非线程安全，适合单线程环境中的高性能字符串处理。和SringBuffer本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。（很多情况下我们的字符串拼接操作不需要线程安全） 使用new String(“abc”）语句在Java中会创建多少个对象？这个有两种情况，首先都会在堆中创建一个未被初始化的对象，然后从常量池里那找abc，找到了abc那就直接赋值，没找到就在堆内存里创建abc的String对象，然后保存他的引用到常量池，然后从常量池里获取并赋值，所以会有1到2个对象 为什么 Java 9 String 内部将 char 数组改为 byte 数组？（待定）为了优化存储空间，char占两个字符，而byte占一个，当然我们知道汉字哪些要占两个字符的空间，所以java引用了coder变量来标识编码方式，在保持兼容性的同时，又减少了内存占用。 ListArrayList 和 LinkedList 有什么区别？ArrayList在底层是通过数组实现，而LinkedList是通过双向链表实现。我们都知道 数组在内存中是连续的，通过索引访问，这就意味着数组如果知道索引就可以在O(1)的时间内查找到数据，但是同理因为在内存中是连续的，这就导致如果在删除&#x2F;新增元素（除开尾部删除&#x2F;新增）会让后续元素填补起空缺（向前移），因为数组涉及到扩容，那么在插入的时候还可能导致触发扩容让效率更低，这也就造就了数组的特性：查询效率高，增删效率低 链表在内存是不连续的，通过设计节点结构记录其下&#x2F;上一个节点地址（单向、双向、循环、双向循环），这就意味着我们只能通过从头节点开始遍历节点元素来进行查找，而可以通直接修改某个节点的指向地址直接插入&#x2F;删除元素，这也就造就了链表的特性：查询效率低，增删效率高 当然这不是一定的，比如数组的尾插尾删效率也很高，我们不能片面的说数组增删效率一定低于链表。LinkedList 更利于增删不是体现在时间复杂度上，因为二者增删的时间复杂度都是 O(n)，都需要遍历列表；而是体现在增删的效率上，因为 LinkedList 的增删只需要改变引用，而 ArrayList 的增删可能需要移动元素。 回到题目，ArrayList和LinkedList结果显而易见： ArrayList：查询效率高、增删效率低、支持随机访问、可能导致内存浪费 LinkedList：查询效率低，增删效率高、不支持随机访问、占用内存稍大 ArrayList的扩容机制了解吗？ArrayList 确切地说，应该叫做动态数组，因为它的底层是通过数组来实现的，当往 ArrayList 中添加元素时，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就会进行扩容。扩容后的新数组长度是原来的 1.5 倍（当前数组长度加上其长度的的二进制右移一位 &gt;&gt;1 ），然后再把原数组的值拷贝到新数组中。更新ArrayList内部的引用，指向新数组。添加新元素到新数组中。 多线程相关：https://javabetter.cn/sidebar/sanfene/collection.html#_6-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0-arraylist-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%B3%95 Map能说一下 HashMap 的底层数据结构吗？在JDK8中，HashMap由一个桶数组和链表组成（哈西表），链表（O(n)）长度大于8且总长度大于64时会转化为红黑树（O(logn)）。HashMap 中每个元素称之为一个哈希桶（bucket），哈希桶包含的内容有 4 个：hash值、key、value、next 在hashmap里数据添加的流程为可以概括为，先将 key 值进行 hash 得到哈希值，根据哈希值得到元素的索引，判断索引对应位置是否为空，如果为空直接插入，不为空判断是否为红黑树，如果是红黑树则直接插入，否则判断链表是否大于 8（和统计学有关，理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为 8 的情况概率很低很低。至于红黑树转回链表的阈值为什么是 6，而不是 8？是因为如果这个阈值也设置成 8，假如发生碰撞，节点增减刚好在 8 附近，会发生链表和红黑树的不断转换，导致资源浪费），且数组长度大于 64，如果满足这两个条件则把链表转成红黑树，然后插入元素，如果不满足这两个条件中的任意一个，则遍历链表进行插入。 HashMap 的初始容量是 16，随着元素的不断添加，HashMap 的容量（也就是数组大小）可能不足，于是就需要进行扩容，阈值是capacity * loadFactor，capacity 为容量，loadFactor 为负载因子，默认为 0.75。扩容后的数组大小是原来的 2 倍，然后把原来的元素重新计算哈希值，放到新的数组中 hashCode() 是 Java 中自带的 hashCode() 方法，返回一个 int 类型的散列值，后面 hashCode 再右移 16 位（这样处理既考虑了高位的信息，又没有完全忽视低位原本的信息，尝试达到一个平衡状态），正好是 32bit 的一半，与自己本身做异或操作（相同为 0，不同为 1），主要是为了混合哈希值的高位和低位，增加低位的随机性，这样就实现了 HashMap 的哈希算法。而且为了减少hash冲突，让元素均匀地分布在数组当中，在hashmap里设计了负载因子让数组不必满了才添加，设计数组的容量为16和2倍扩容的机制，就是为了让数组长度保证为2 的整数次幂，这也符合其源码中hash值和数组长度相与（hash &amp; (n-1)）相当于取模，让每个元素相对均匀的存放（越均匀hash冲突越不容易发生）。就算发生hash冲突了，hashmap还会用eq方法进行比较，只有哈希一致和equals比较结果也相等才能说明插入的数据是同一个。 hash &amp; (n-1)-&gt;低位掩码”——这个掩码的低位最好全是 1，实际上是保留 hash 二进制表示的最低 n 位，其他高位都被清零，这样 &amp; 操作才有意义，否则结果就肯定是 0。 偶数-1 是奇数，奇数的二进制最后一位是 1，保证了 hash &amp;(length-1) 的最后一位可能为 0，也可能为 1（取决于 hash 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，这样便可以保证哈希值的均匀分布 如果初始化 HashMap，传一个 17 容量，它会怎么处理？HashMap 会将这个值转换为大于或等于 17 的最小的 2 的幂，所以，如果你传入 17 作为初始容量，HashMap 实际上会被初始化为大小为 32 的哈希表。 如果预先知道 Map 将存储大量键值对，提前指定一个足够大的初始容量可以减少因扩容导致的重哈希（rehashing）操作，从而提高性能。当然了，过大的初始容量会浪费内存，特别是当实际存储的元素远少于初始容量时。如果不指定初始容量，HashMap 将使用默认的初始容量 16。 解决哈希冲突有哪些方法呢？ 再哈希法：准备两套哈希算法，当发生哈希冲突的时候，使用另外一种哈希算法，直到找到空槽为止。对哈希算法的设计要求比较高。 开放地址法： 线性探测：从冲突的位置开始，依次往后找，直到找到空槽 二次探测：从冲突的位置 x 开始，第一次增加 1^2 个位置，第二次增加 2^2，直到找到空槽。 双重哈希：和再哈希法类似，准备多个哈希函数，发生冲突的时候，使用另外一个哈希函数 拉链法：也就是所谓的链地址法，当发生哈希冲突的时候，使用链表将冲突的元素串起来。HashMap 采用的正是拉链法。 你对红黑树了解多少？为什么不用二叉树&#x2F;平衡树呢？红黑树是一种自平衡的二叉查找树 每个节点要么是红色，要么是黑色； 根节点永远是黑色； 所有的叶子节点都是是黑色的（下图中的 NULL 节点）； 红色节点的子节点一定是黑色的； 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 二叉树是最基本的树结构，每个节点最多有两个子节点，但是二叉树容易出现极端情况，比如插入的数据是有序的，那么二叉树就会退化成链表，查询效率就会变成 O(n)。 平衡二叉树比红黑树的要求更高，每个节点的左右子树的高度最多相差 1，这种高度的平衡保证了极佳的查找效率，但在进行插入和删除操作时，可能需要频繁地进行旋转来维持树的平衡，这在某些情况下可能导致更高的维护成本。 红黑树是一种折中的方案，它在保证了树平衡的同时，插入和删除操作的性能也得到了保证，查询效率是 O(logn)。 JDK 8 对 HashMap 主要做了哪些优化呢？为什么？ 底层数据结构由数组 + 链表改成了数组 + 链表或红黑树的结构。如果多个键映射到了同一个哈希值，链表会变得很长，在最坏的情况下，当所有的键都映射到同一个桶中时，性能会退化到 O(n)，而红黑树的时间复杂度是 O(logn) 链表的插入方式由头插法改为了尾插法。头插法虽然简单快捷，但扩容后容易改变原来链表的顺序。 扩容的时机由插入时判断改为插入后判断。可以避免在每次插入时都进行不必要的扩容检查，因为有可能插入后仍然不需要扩容。 优化了哈希算法。JDK 7 进行了多次移位和异或操作来计算元素的哈希值。JDK 8 优化了这个算法，只进行了一次异或操作，但仍然能有效地减少冲突。并且能够保证扩容后，元素的新位置要么是原位置，要么是原位置加上旧容量大小。 HashMap 是线程安全的吗？多线程下会有什么问题？ 多线程下扩容会死循环。JDK1.7 中的 HashMap 使用的是头插法插入元素，在多线程的环境下，扩容的时候就有可能导致出现环形链表，造成死循环。JDK 8 时已经修复了这个问题，扩容时会保持链表原来的顺序。 多线程的 put 可能会导致元素的丢失。因为计算出来的位置可能会被其他线程的 put 覆盖。本来哈希冲突是应该用链表的，但多线程时由于没有加锁，相同位置的元素可能就被干掉了。 put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出阈值而导致出现扩容，线程 2 此时执行 get，就有可能出现这个问题。因为线程 1 执行完 table &#x3D; newTab 之后，线程 2 中的 table 此时也发生了变化，此时去 get 的时候当然会 get 到 null 了，因为元素还没有转移。 有什么办法能解决 HashMap 线程不安全的问题呢？HashMap 内部节点是有序的吗？尽管在jdk1.8的时候Java把，链表的插入方式由头插法改为了尾插法，维持维持了原链表的顺序，但是HashMap 任然是无序的，因为是根据 hash 值随机且均匀的在数组里找索引位置再插入的。如果想使用有序的 Map，可以使用 LinkedHashMap 或者 TreeMap。 hashTable和hashMap有什么区别？hashTable和hashMap都是哈希表的实现，线程安全性和允许存储null键值的能力。hashTable是线程安全的，而hashMap不是；hashMap允许存储一个null键和多个null值，而hashTable不允许。初始容量和扩容机制：Hashtable在创建时必须指定容量大小，且默认大小为11。而HashMap可以在创建时不指定容量大小，系统会自动分配初始容量，并采用2倍扩容机制 concurrentHashMap怎么实现的？和hashtable有什么不同在JDK 1.7中，concurrentHashMap使用使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。 锁粒度：基于 Segment，包含多个 HashEntry。 ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 在jdk1.8之后使用 CAS + synchronized + Node + 红黑树。 锁粒度：Node（首结点）。锁粒度降低了。 ConcurrentHashMap的Node节点与HashMap的节点有些不一样，主要在vaule和next上加了volatile关键字，用来保持可见性 区别： Hashtable 使用了全局锁，也就是在任何时刻只能有一个线程访问 Hashtable 的数据，这导致了在高并发环境下性能较差。 Set异常处理新特性 tcp:&#x2F;&#x2F;easytier.huzhihao.top:11010","tags":[null],"categories":[null]},{"title":"Java基础","path":"/intvSum/JavaBasic.html","content":"Java语言和C语言有哪些区别？ 面向过程：比如需要把大象塞进冰箱，一共是打开冰箱，塞进大象，关闭冰箱三步，关注的是大象塞进冰箱的过程 面向对象：同样的需要把大象塞进冰箱，就需要 New 大象对象、冰箱对象，基于两个对象进行操作 C语言是面向过程的语言，Java是面向对象，Java不提供指针直接访问内存，Java有自动内存管理机制 JVM、JDK 和 JRE 有什么区别？ JVM：Java Virtual Machine，也就是 Java 虚拟机，是 Java 实现跨平台的关键所在，针对不同的操作系统，有不同的 JVM 实现。JVM 负责将 Java 字节码转换为特定平台的机器码，并执行。 JRE：Java Runtime Environment，也就是 Java 运行时环境，包含了运行 Java 程序所必需的库，以及 Java 虚拟机（JVM）。 JDK：Java Development Kit，是一套完整的 Java SDK（软件开发工具包），包括了 JRE 以及编译器（javac）、Java 文档生成工具（Javadoc）、Java 调试器等开发工具。为开发者提供了开发、编译、调试 Java 程序的一整套环境。 JDK是完整的软件开发工具包，JRE是 Java 运行时环境，JVM是 Java 虚拟机，JDK 包含 JRE，JRE 包含 JVM。 说说什么是跨平台性？原理是什么 字节码是把源码 .java 通过jdk中的Javac编译成虚拟机可以识别的 .class 文件 （编译） 其中Java虚拟机就是把字节码转化为特定平台的机器码 （解释） 对应的机器执行二进制机器码 （执行） 一次编译后，可以在多个系统平台上运行。Java 程序是通过 Java 虚拟机在系统平台上运行的，只要该系统可以安装相应的 Java 虚拟机，该系统就可以运行 java 程序。 什么是自动拆箱&#x2F;装箱？为什么拆箱就是将包装类型对象转换为其对应的基本数据类型，而装箱则是将基本数据类型转换为相应的包装类型对象。 好处： 包装类型可以为 null，而基本数据类型不可以，这使得包装类型可以应用于 POJO 中，而基本数据类型则不行，因为数据库的查询结果可能是 null，如果使用基本数据类型的话，因为要自动拆箱，就会抛出 NullPointerException(空指针异常) 的异常。 包装类型可用于泛型，而基本数据类型不可以，因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本数据类型是个例外。 什么是泛型？泛型擦除是什么？使用类型参数解决了元素的不确定性——参数类型为 String 的集合中是不允许存放其他类型元素的，取出数据的时候也不需要强制类型转换了。Java 虚拟机会将泛型的类型变量擦除，并替换为限定类型（没有限定的话，就用 Object）。但是也存在一定问题，比如String 和 Date 是不同的类，他们分别作为ArrayList的限定类型时，编译后进行类型擦除，其中类型变量 String 和 Date都会消失。 这就可能让重载的方法编译成相同的方法导致编译失败。 自动类型转换、强制类型转换？1字节&#x3D;8bit &#x3D;二进制&#x3D;&gt;2^8 个数 就好比小杯水倒入大杯水、大杯水倒入小杯水，其中主要关注强制类型转换，比如把double转为float，也就是把双精度转为单精度就会导致精度丢失，在short类型在和int类型运算的时候运算结果会自动转化为int类型等 需要注意：默认情况下，没有后缀的浮点数字面量会被视为double类型。如果带有f或F后缀，则被视为float类型。所以float f&#x3D;3.4;是错误的。 char型变量中能不能存贮一个中文汉字?和int类型可以互转吗？char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。其中char类型转int（可发生自动转换）会输出其编码对应的值，同理int转char需要强制转换。 &amp;和&amp;&amp;有什么区别？ &amp; 是逻辑与，如果第一个条件如果不成立，还会进行下一个条件的比较，这里如果有username != null &amp; !username.equals(&quot;&quot;) 根本不能进行字符串的 equals 比较，否则会产生NullPointerException 异常。 &amp;&amp; 是短路运算，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;。 逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 &amp;是逻辑与，&amp;两边的条件都会进行判断；&amp;&amp;是短路与，如果&amp;&amp;的第一个条件为true才会进行下一个条件判断。 switch 是否能作用在 byte&#x2F;long&#x2F;String 上？ Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。 从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。 从 Java 7 开始，expr 还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的。 Java5以前就可以使用byte数据类型，Java5的时候支持了枚举类型，Java7开始支持字符串类型他是通过hashcode来进行比较的，但是目前Java不支持Long类型，因为switch语句要求条件表达式是一个32位的整数类型，而long类型是64位的整数类型。 用最有效率的方法计算 2 乘以 8？ 算速运算符、逻辑运算符、位运算符、逻辑运算符、赋值运算符、三元运算符 按位与操作符：&amp;，它用于将两个操作数的每一位进行对比。如果两个操作数的对应位都是1，则结果为1，否则结果为0。 按位或操作符：|，它用于将两个操作数的每一位进行对比。如果两个操作数的对应位只要有一个是1，则结果为1，否则结果为0。 按位异或操作符：^，它用于将两个操作数的每一位进行对比。如果两个操作数的对应位相同，则结果为0，否则结果为1。 按位取反操作符：~，它用于将操作数的每一位进行取反操作，即1变为0，0变为1。 左移位操作符： &lt;&lt;，它用于将操作数的二进制值向左移动指定的位数。左移位操作符的结果是原来的值乘以2的移位数次幂。 右移位操作符： &gt;&gt;，它用于将操作数的二进制值向右移动指定的位数。右移位操作符的结果是原来的值除以2的移位数次幂。 无符号右移位操作符： &gt;&gt;&gt;，它用于将操作数的二进制值向右移动指定的位数，但是它会在空位上插入0，而不是符号位的复制。 位运算直接操作内存中的二进制位，因此它们在硬件层面上非常高效，并且位运算不涉及溢出问题。 说说自增自减运算？ 当运算符放在变量之前时(前缀)，先自增&#x2F;减，再赋值 当运算符放在变量之后时(后缀)，先赋值，再自增&#x2F;减。 对于 JVM 而言，它对自增运算的处理，是会先定义一个临时变量来接收 i 的值，然后进行自增运算，最后又将临时变量赋给了 i 1234567891011121314151617181920212223public static void main(String[] args) &#123; int count = 0; for(int i = 0;i &lt; 100;i++) &#123; count = count++; // count = autoAdd(count); &#125; System.out.println(&quot;count = &quot;+count); &#125;// count++ 等同于static int autoAdd(int count) &#123; int temp = count; count = count + 1; return temp; &#125;// ++count 等同于static int autoAdd(int count) &#123; count = count + 1; int temp = count; return temp; &#125; 综上所诉：前++，先自增，再赋值，反之亦然 讲一下数据准确性高是怎么保证的？在金融计算中，保证数据准确性有两种方案，一种使用 BigDecimal，BigDecimal在计算时，实际会把数值扩大10的n次倍，变成一个long型整数进行计算，整数计算时自然可以实现精度不丢失。一种将浮点数转换为整数 int 进行计算。肯定不能使用 float 和 double 类型，它们无法避免浮点数运算中常见的精度问题，在处理小额支付或计算时，通过转换为较小的货币单位（如分），这样不仅提高了运算速度，还保证了计算的准确性。 Math.round(11.5) 等于多少？Math.round(-11.5) 等于多少 Math.round(11.5) &#x3D; 12 Math.round(-11.5) &#x3D; -11 假如画一个从左到右的数轴，Math.round的取值是向右靠的，负数靠近0，正数靠近正无穷。 面向对象编程有哪些特性？面向对象编程有三大特性：封装、继承、多态。 封装：数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。好处是减少耦合、隐藏信息和实现细节、类内部的结构可以自由修改、可以对成员进行更精确的控制，比如限定成员变量范围什么的。 继承：复用以前的代码，使用继承不仅大大的减少了代码量，也使得代码结构更加清晰可见。 多态：允许不同类的对象对同一消息做出响应，但表现出不同的行为（即方法的多样性），执行一段代码，Java 在运行时能根据对象类型的不同产生不同的结果 多态的目的？解决了什么问题是为了提高代码的灵活性和可扩展性，使得代码更容易维护和扩展。比如说动态绑定，允许在程序在运行时再确定调用的是子类还是父类的方法。 说说重载、重写的关系与区别。 重载（overload）：一个类里有多个名字相同但参数个数不同的方法。作用对象：方法 重写（override）：子类具有和父类一样的方法（参数相同、返回类型相同、方法名相同，但方法体可能不同），用于提供父类已经声明的方法的特殊实现，是实现多态的基础条件。作用对象：类之间 因为构造器不能被继承，所以构造器不能被重写，只能被重载。 访问修饰符 public、private、protected、以及不写（默认）时的区别？ private : 在同一类内可见。可以修饰变量、方法。注意：不能修饰类（外部类） default （即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。 protected : 对同一包内的类和所有子类可见。可以修饰变量、方法。注意：不能修饰类（外部类）。 public : 对所有类可见。可以修饰类、接口、变量、方法 组要区别就是在，同一个类中、同一个包中、子类中以及全局范围的可见性 this 关键字有什么作用？和super 关键字有什么区别？可以作为引用变量，指向当前对象。这样可以是调用当前类的成员变量、方法、构造方，作为当前类的引用参数传递，甚至可以作为返回值等。但是super关键字，他是指向父类对象，我们主要用它来调用父类方法、构造方法。 抽象类和接口有什么区别？和普通类呢？ 特性 抽象类 接口 类 定义 不能实例化，只能被继承的类。 定义一组方法规范。 可以实例化的具体类。 关键字 abstract interface class 方法实现 可以包含抽象方法（没有方法体）和具体方法（有方法体）。 只能包含抽象方法（Java 8+ 可以有默认和静态方法）。 只能包含具体方法（有方法体）。 成员变量 可以有成员变量（实例变量）。 只能有静态常量（使用public static final修饰）。 可以有成员变量。 继承关系 一个类只能继承一个抽象类（单继承）。 一个类可以实现多个接口（多实现）。 可以继承一个类。 访问修饰符 可以有各种访问修饰符（public, protected, private）。 方法默认是public，不能有其他修饰符。 可以有各种访问修饰符。 用途 提供一个基础实现，子类可以选择性的重写。 定义一个类需要遵循的契约或标准。 实现具体功能或行为。 多重继承 不支持（只能单继承）。 支持（一个类可以实现多个接口）。 不支持（只能单继承）。 实例化 不能直接实例化。 不能直接实例化。 可以直接实例化。 构造器 可以有构造器。 不能有构造器。 可以有构造器。 首先在定义上，抽象类不能被实例化，只能被继承，而接口是一组方法规范，只能被实现。然后他们的修饰关键字不同，比如抽象类是abstract，接口是interface，类是class。具体内容不同，比如抽象类既可以有抽象方法，也可以有具体方法，但是接口只能有抽象方法，在Java8后可以用默认方法和静态方法，类就不能有抽象方法。其中接口最为特别，他是可以被多实现和多继承的，也就是一个类可以实现多个接口，一个接口可以继承多个接口。 其次在应用上，接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用。假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码。父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。 成员变量与局部变量的区别有哪些？ 成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数。 如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。 成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。 总得来说，如果成员遍历被static修饰，那么他是属于类的，如果没有则是属于对象的，而局部变量是在⽅法中定义的变量或是⽅法的参数。 静态变量和实例变量的区别？静态方法、实例方法呢？静态：方便在没有创建对象的情况下进行调用 静态变量: 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本。 实例变量: 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 静态方法：static 修饰的方法，也被称为类方法。在外部调⽤静态⽅法时，可以使⽤”类名.⽅法名“的⽅式，也可以使⽤”对象名.方法名“的⽅式。静态方法里不能访问类的非静态成员变量和方法。 实例⽅法：依存于类的实例，需要使用”对象名.方法名“的⽅式调用；可以访问类的所有成员变量和方法。 总得来说，被static修饰的变量和方法，都是方便在没有创建对象的时候进行调用，可以通过类名或者对象名直接调用静态方法，实例方法则是依存与某一实例，通过创建对象进行访问。 是否可以从一个static方法内部发出对非static方法的调用？不可以，因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。 ==和equals方法究竟有什么区别？基本数据类型和引用数据类型 对于==，如果比较的是基本数据类型，那就比较的是值，如果比较的是引用数据类型，那比较的是地址值。而对于equals 他只能比较引用数据类型，如果没有重写Object中的equals方法，比较的就是两个对象的地址，重写了就得看是怎么重写的，比如Integer里就是比较值，而String是先地址后值、地址不同值相同返回true。 两个对象hashCode（）相同，则equals（）否也一定为true?不一定。 根据Java的规范，如果两个对象的hashCode返回值相同，那么它们可能相等，但并不保证一定相等（哈希冲突）。比如在hashset里面，如果hashCode返回值相同，还需要使用equals方法进行进一步比较。所以Java的设计原则就是，equals方法为true，那么hashcode也一定为true，但是反过来就不一样了 总结：两个对象的hashCode方法返回相同的值，并不能保证它们的equals方法一定返回true，因此在比较对象的相等性时，需要同时使用equals方法和hashCode方法 为什么重写 equals 时必须重写 hashCode ⽅法？hashcode效率更高，但存在hash冲突。equals方法效率低，但是一定正确 首先我们需要明确equals和hashcode的作用与关系，如果equals没有被重写，通过他比较的对象可以保证是相等的，但是这样比较效率并不高，在Java基于hash的集合类里面，比如HashSet、HashMap、Hashtable 等，他们都使用了hashcode方法，可以保证在最快的时间内判断两个对象是否相等，但是由于有hash冲突的存在，不能保证比较值是一定正确的，所以他们都是先计算hashcode，获取到桶的索引，在使用equals来找到正确的对象。 回到问题，我们以HashSet为例，如果存在两个属性值相同的对象 如果我们只重写了equals方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。 但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。 总得来说，hashCode 和 equals 两个方法是用来协同判断两个对象是否相等的，采用这种方式的原因是可以提高程序插入和查询的速度，如果在重写 equals 时，不重写 hashCode，就会导致在某些场景下，例如将两个相等的自定义对象存储在 Set 集合时，就会出现程序执行的异常，为了保证程序的正常执行，所以我们就需要在重写 equals 时，也一并重写 hashCode 方法才行。 final 关键字有什么作用？ 当 final 修饰一个类时，表明这个类不能被继承。比如，String 类、Integer 类和其他包装类都是用 final 修饰的。 当 final 修饰一个方法时，表明这个方法不能被重写（Override）。也就是说，如果一个类继承了某个类，并且想要改变父类中被 final 修饰的方法的行为，是不被允许的。 当 final 修饰一个变量时，表明这个变量的值一旦被初始化就不能被修改。 如果是基本数据类型的变量，其数值一旦在初始化之后就不能更改；如果是引用类型的变量，在对其初始化之后就不能再让其指向另一个对象。 Java 中如何创建一个不可变的类？需要满足以下条件： 将类声明为final，以防止继承。 将所有字段声明为private，并且不提供任何setter方法，只提供getter方法。 如果字段是可变的（如数组），需要在返回时进行深复制，以避免原始字段被修改 为什么String要设计成Final类 深拷贝和浅拷贝有什么区别？拷贝的程度：对象引用、对象实例 浅拷贝只拷贝对象引用，不创建新的对象实例。拷贝后的对象与原始对象共享同一份数据，对其中一个对象的修改会影响到另一个对象。 深拷贝创建一个全新的对象实例，并将原始对象的所有属性值复制到新对象中。拷贝后的对象与原始对象是独立的，对任一对象的修改不会影响另一个对象。 性能开销： 浅拷贝的性能开销较小，因为仅复制对象的引引用。 深拷贝的性能开销较大，因为需要创建新的对象实例并复制所有属性。 通常情况下，当我们需要复制一个对象并希望新对象与原始对象互不影响时，应使用深拷贝。而浅拷贝更适用于那些对象结构较简单、不包含引用类型成员变量或不需要独立修改的情况。 final、finally、finalize 的区别？ final 是一个修饰符，可以修饰类、方法和变量。当 final 修饰一个类时，表明这个类不能被继承；当 final 修饰一个方法时，表明这个方法不能被重写；当 final 修饰一个变量时，表明这个变量是个常量，一旦赋值后，就不能再被修改了。 finally 是 Java 中异常处理的一部分，用来创建 try 块后面的 finally 块。无论 try 块中的代码是否抛出异常，finally 块中的代码总是会被执行。通常，finally 块被用来释放资源，如关闭文件、数据库连接等。 finalize 是Object 类的一个方法， 用于在垃圾回收器将对象从内存中清除出去之前做一些必要的清理工作，而且一般我们不需要显式地调用finalize方法，而是交由垃圾回收器自动调用。finalize方法已被废弃。 Java 是值传递，还是引用传递？值传递，首先值传递是在传参的过程中原参数不变，引用传递是传递的参数本身，所以原参数会变。在Java中当一个对象被作为参数传递到方法中时，该参数的值就是该对象的引用，但是这个引用并不会影响原参数，他只是原参数的一个副本，Java只有值传递。","tags":[null],"categories":[null]},{"title":"Redis","path":"/intvSum/Redis.html","content":"zset的底层实现结构是怎样的?","tags":[null],"categories":[null]},{"title":"alist的多种搭建方式，优化分享链接，实现浏览器直接预览","path":"/workflow/Alist.html","content":"摘要展示alist的docker搭建方式，以及直接搭建。实现挂载服务器指定目录文件，并且可以对其进行预览、而不是触发下载 搭建docker搭建# 目录：/home/docker/alistmkdir /home/docker/alistcd /home/docker/alistvi docker-compose.yml 123456789101112131415161718services: alist: image: xhofe/alist:main container_name: alist restart: always mem_limit: 100m user: root ports: - &quot;5244:5244&quot; volumes: - /home/docker/nginx/certs:/opt/alist/data/cert - /home/data:/home/data - ./data:/opt/alist/data logging: driver: json-file options: max-size: &quot;1M&quot; max-file: &quot;3&quot; 这边建议您通过docker compose up -d 运行后，配置反向代理 直接搭建123456789# 默认安装在 `/opt/alist` 中。 # 自定义安装路径，将安装路径作为第二个参数添加，必须是绝对路径（如果路径以 alist 结尾，则直接安装到给定路径，否则会安装在给定路径 alist 目录下）# 如 安装到 `/home`# Installcurl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s install /home# updatecurl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s update /home# Uninstallcurl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s uninstall /home 配置注意记得去config.json里把user 值设置为root 基础设置1234567891011121314151617访问地址：http://YOUR_IP:5244/配置文件路径：/home/alist/data/config.json---------如何获取密码？--------先cd到alist所在目录:cd /home/alist随机设置新密码:./alist admin random或者手动设置新密码:./alist admin set NEW_PASSWORD----------------------------启动服务中查看状态：systemctl status alist启动服务：systemctl start alist重启服务：systemctl restart alist停止服务：systemctl stop alist 反向代理123456789101112# alistserver &#123; listen 443 ssl; server_name alist.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:5244/; &#125;&#125; 挂载目录 预览处理 把&#x2F;d的请求重定向到nginx服务，然后监听本地的80请求，再设置跟路径即可 需要注意的是：比如请求 https://alist.exp.top/d/oss/Blog/source/imgs/github.svg 他重定向后的路径在服务器中就为 http://127.0.0.1:80/oss/Blog/source/imgs/github.svg 确保root目录对应的路径下有这些文件 12345678910111213141516171819202122232425262728# alistserver &#123; listen 443 ssl; server_name alist.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:5244/; &#125; # 处理 /d/ 请求，重写路径并代理到 80 端口 location /d/ &#123; rewrite ^/p/(.*)$ /$1 break; proxy_pass http://127.0.0.1:80/; &#125;&#125;server &#123; listen 80; server_name 127.0.0.1; root /home/data; location / &#123; try_files $uri $uri/ =404; &#125;&#125; rclone挂载alist到电脑（可选）下载：rclone和winfsp 配置： 把含有exe文件的目录添加到系统环境变量 打开cmd运行窗口使用指令rclone config修改配置 填写alist登录账号 选择webdav 选择其他 输入挂载到本地的名称 用户名称就输alist账号 输入y填写并确认alist密码 按3下enter并输入q退出 开机自动挂载： 新建bat，输入以下内容，再双击查看是否成功运行 # 第一个alist是之前设置的挂载到本地的名称 # alist:/ 表示挂载根目录# D:/alist 本地的哪个路径@echo offrclone mount alist:/ D:/alist --vfs-cache-mode full --use-mmap --allow-other --no-check-certificate --no-gzip-encoding --copy-links 创建任务计划，通过在Windows搜索框中输入”任务计划程序”找到并打开，创建基本任务，触发器选 计算机启动时，选择 启动程序 后路径选择刚刚创建的bat文件，完成创建 右键点击该任务，选择“属性”，在“常规”选项卡中，勾选“使用最高权限运行”，在“操作”选项卡中，点击“编辑”（Edit）在“编辑操作”窗口中，在bat路径前添加cmd.exe /c，并在“添加参数”中输入/c start &quot;&quot; /b &quot;C:\\path\\to\\your\\mount_alist.bat&quot;。 这样就可以开机后，rclone在后台无感运行了","tags":[null,null,null],"categories":[null]},{"title":"微服务","path":"/intvSum/SpringCloud.html","content":"概述你认为什么是微服务？将一个大型的服务划分成小型、自治内恰、高内聚、低耦合的微小服务，每个服务可以独立开发、部署和拓展，既大大降低了协作开发难度，提高团队工作效率，又让应用程序更加灵活、可伸缩和可维护 微服务有哪些缺点？ 系统复杂性增加，不光是开发上，在部署上也会导致部署的版本不好控制，更难运维，在测试上也会因为测试场景复杂度的增加而让测试任务编排更加困难 服务间通信开销，传递数据需要额外的网络开销和序列化开销，可能导致性能瓶颈和增加系统延迟 数据一致性，每个微服务都有自己的数据存储，数据一致性和跨服务的事务管理变得更加复杂，需要额外解决分布式事务和数据同步的问题。 说下微服务有哪些组件 服务注册与发现：注册和发现服务实例、负载均衡等 API网关：统一鉴权、日志记录、请求分发和过滤、灰度发布等 负载均衡：分布流量、故障转移等 容错与恢复：断路器、自动重试、限流、回退等 服务通信：微服务之间需要通过某种通信协议进行交互，这种通信可以是同步的（例如 HTTP&#x2F;REST、gRPC）或异步的（例如消息队列、事件驱动） 集中式日志管理：收集各节点日志并统一管理 分布式链路追踪：直观的了解各节点间的调用链路 Spring、Spring Boot和 SpringCloud 之间的关系是什么样子的?Spring一开始只有两个核心功能，分别是IOC 和 AOP，然后在这两个功能之上，不断发展了 Spring MVC、Spring Web等产品。在此基础上，为了简化Spring应用的创建、运行、调试、部署等，Spring 官方在Spring的基础上推出了SpringBoot，SpringBoot出现的目的并不是取代Spring,而是简化Spring的开发，提高开发效率。之后，随着SpringBoot开发单体越来越成熟，微服务的理念随之愈发流行，Spring Cloud 诞生了，他在SpringBoot开发的基础上，整合了微服务的理念，最终形成一套不错的微服务解决方案 服务注册与发现你认为注册中心是什么？有什么用比如在一个分布式系统中，服务种类和数量都比较多，一种类型的服务可能部署有多个，这些服务需要进行相互调用，但是我们是没办法确定每个服务的状态，比如某些服务挂了，访问不了，再去访问就会出问题，那我们就需要一个工具也就是注册中心来描述服务的状态，管理这些服务。实际上就是一个服务治理问题 注册中心在逻辑上可以分为注册中心的服务端、服务提供者、服务消费者。其中，服务提供者向注册中心服务端注册服务，然后服务消费者向服务端获取服务，获取到服务提供者的ip、端口等信息，服务调用者就可以发送http请求调用服务提供者提供的服务，在这个基础的流程中还需要做一些事情，比如说，服务提供者主动下线服务、服务提供者和注册中心服务段的续约，也可以叫健康检查。在分布式系统中多个注册中心服务端还涉及到nacos集群的同步的问题。 为什么springboot项目启动后自动注册nacos？我们知道nacos服务如果要手动注册那么使用curl 命令也好、使用spring提供的RestTemplate也好，都是通过发送post请求进行注册，那么只需要在springboot启动的时候自动发送请求就行，在springboot中有一个设计模式——观察者模式，他是一种通知机制，又可以叫发布订阅模式。那么spingboot通过规定一系列事件，比如：ApplicationStartingEvent，这个事件可以在springboot开始运行的项目的时候，进行任何处理前触发。spingboot通过多波器发布事件，再对事件进行监听，最后触发ApplicationStartingEvent事件自动注册到nacos。需要注意的是，在springcloud中只定义注册规范，也就是他有个接口，用于让其他厂商实现其中定义的注册方法。所以说具体的注册逻辑是在springcloud alibaba 中的。 服务变更时怎么在注册中心保持更新？（待定）目前市面上有两大主要机制，一个是监听机制，一个是轮询机制。在nacos中本质上使用的轮询机制， 所有有变更通知机制，在Apache的Zookeeper中使用的是监听机制，也就是它本质上是一个树形结构，可以在树上创建临时节点，并对节点添加监听器。临时节点的客户端与该节点建立长连接，并会实时关注节点的状态，同时，客户端存在一个回调函数，当节点状态发生变化时，就会通过监听器将这种变化传递到客户端并触发回调函数。 AP和CP是什么，怎么做取舍? 一致性（Consistency） 同一时刻同一请求的不同实例返回的结果相同，这要求数据具有强一致性(Strong Consistency)，需要特别说明的这里的一致性与ACID（见上文）的一致性不是同一个概念，不要混淆 可用性（Availability） 所有读写请求在一定时间内得到正确的响应 分区容错性（Partition tolerance） 在网络异常情况下，系统仍能正常运作 AP是在异常的情况下保证可用性，CP是保证强一致性。 我们都知道nacos是既作为发现注册中心又作为配置中心的，从服务注册发现来看，服务之间需要感知对方当前提供的服务的示例信息，必须从服务发现注册中心获取，这就需要发现注册中心在任何时候都要尽可能对外提供服务。而且，nacos是采取了心跳可自动完成数据服务补偿的机制，可以快速恢复数据。很明显，在服务的发现注册来看，是需要保证高可用的（AP），所以使用最终一致性共识算法。当然，以上都是针对需要心跳机制的临时服务，对于持久化的服务，因为所有的数据都是直接使用调用Nacos服务端直接创建，因此更需要保障数据的一致性，采用强一致性共识是算法（CP）。 如果我们从配置管理来看，配置数据也是由nacos创建并管理的，因此也必须保证大部分节点都保存了次配置数据才能看作配置成功，因此也是必须采用强一致性共享算法 为什么 Nacos 选择了 Raft 以及 Distro 一致性协议？首先raft是工业生产中用的最多的强一致性共享算法，不但跟容易理解，而且还有很多成熟的实现，比如nacos采用的就是蚂蚁金服开发的JRaft，而且JRaft支持多 RaftGroup ，也是让nacos实现数据分片成为可能。对于Distro，他是最终一致性共享算法，市面上也有很多，比如 Eureka 、Gossip ，Distro算是综合了他们两个，既解决了因为Gossip随机发送而导致的重复发送问题，又引入了权威Server的概念，有效降低消息冗余的问题。 Raft怎么实现强一致性共享的？raft是一种基于一种选举机制的分布式一致性算法，通过选举产生一个主节点，所有的写操作通过主节点来处理，再由主节点同步到其他从节点，在nacos里配置变更首先在主节点上进行然后通过raft协议进行同步的。 三种一致性协议：Distor、Eureka、Gossip有什么区别？（待定） Distor：我认为其核心特点就是分布式，新加入的 Distro 节点会轮询所有的 Distro 节点，通过向其他的机器发送请求拉取全量数据，然后各个Distro 节点之间会保持心跳，发送元信息（网络传输数据量级更低）进行数据校验，如果数据不一致则会发起⼀次全量拉取请求，将数据补齐。 nacos具体怎么实现配置一致性的？首先说这个没有用数据库的，也就是注册发现中心 基于 Raft 的强一致性共享协议 通过长轮询机制：在长轮询模式下，客户端定时向服务端发起请求，检查配置信息是否发生变更。如果没有变更，服务端会”hold”住这个请求，即暂时不返回结果，直到配置发生变化或达到一定的超时时间。 心跳检测：客户端主动上报，告诉服务端自己健康状态，如果在⼀段时间没有上报，那么我们就 认为服务已经不健康。 作为配置中心时，⼀致性的核心是 Server 与 DB 保持数据⼀致性，从而保证 Server 数据⼀致；Server 之间都是对 等的。数据写任何⼀个 Server，优先持久化，持久化成功后异步通知其他节点到数据库中拉取最新配置值，并且通知写入成功。 nacos的健康检查机制是怎样的？第⼀种方式是客户端主动上报，告诉服务端自己健康状态，如果在⼀段时间没有上报，那么我们就 认为服务已经不健康。第二种，则是服务端主动向客户端进行探测，检查客户端是否还被能探测到。 其中心跳机制主要是用于临时实例，注册中心会在⼀段时间没有收到来自客户端的心跳后会将实例设置为不健康，然 后在⼀段时间后进行剔除。而永久实例在被删除之前会永久的存在于注册中心，且有可能并不知道注册中心存在，不会主动向注册中心上报心跳，那么这个时候就需要注册中心主动进行探活。 临时实例也有两种注册方法，OpenAPI和SDK，其中OpenAPI是用户根据自身需求调用 Http 接口对服务进行注册，然后通过 Http 接 口发送心跳到注册中心。在注册服务的同时会注册⼀个全局的客户端心跳检测的任务。在服务⼀段 时间没有收到来自客户端的心跳后，该任务会将其标记为不健康，如果在间隔的时间内还未收到心 跳，那么该任务会将其剔除。Nacos 2.x 版本中，SDK 的注册方式实际是通过 RPC 与注册中心保持连接，客户端会定时的通过 RPC 连接向 Nacos 注册中心发送心跳，保持连接的存活。如果客户端和注册中心的连接断开，那么注册中心会主动剔除该 client 所注册的服务，达到下线的效果。同时 Nacos 注册中心还会在注册中心启动时，注册⼀个过期客户端清除的定时任务， 用于删除那些健康状态超过⼀段时间的客户端。 对于永久实例的健康检查，实际也是使用 OpenAPI 的方式进行注册，这样可以保证，即使是客户端下线后也不会影响永久实例的健康检查。 API 网关为什么要网关，网关有什么用？每个服务有自己的地址，我们不可能让客户端直接和各个微服务进行通信，因此我们需要一个统一的入口用来负责服务请求路由、组合及协议转换，客户端的所有请求都需要经过 API 网关，然后由它将请求路由到合适的微服务。并且 API 网管还可以调用多个微服务合并结果来处理一个请求。它可以在 Web 协议（如 HTTP 与 WebSocket）与内部使用的非 Web 友好协议（RPC 等）之间转换。 此外网关还可以实现一些非功能需求，比如说日志监控，记录请求ip地址、对恶意请求进行监控报警等，还可以进行安全管理，进行统一的身份验证、授权等，还可以进行统一的限流、熔断、降级、等容错策略，当然还可以负载均衡等。 说说gateway网关的架构&#x2F;核心&#x2F;原理 gateway由若干的route组成，路由是gateway的核心，每一个route表示一个完整的网关节点，他包含路由规则和校验（断言）、过滤处理和容错处理（过滤器），一个route由若干谓词和若干过滤器再加上名字和映射地址组成 断言&#x2F;谓词（predicate）就是路由规则和简单的校验，主用于请求条件的匹配，比如说通过指定请求方法、请求路径、请求头来进行匹配 而过滤器其实就是在代理服务之前或者之后做一些事情，对请求进行处理以及转换，比如http和rpc进行转换，还可以鉴权、负载均衡、服务保护等，这些都是可以通过自定义过滤器实现的。 外部请求进网关之后，到达由名字和地址、谓词映射规则组成的集合地址中（Geteway Handler Mapping），再到由若干过滤器组成的处理器中进行代理（Geteway Web Handler），类似一个栈，最后到达各个微服务 负载均衡什么是负载均衡？为什么要负载均衡在分布式系统中，服务通常采用多节点的方式进行部署，如果某个节点请求过多，或者说该节点的服务器性能不是更好，从而影响到服务的性能和响应速度，那么负载均衡就是发请求平均分发或者通过一定的策略分（加权平均、随机、hash）发到多个节点上，让各个几点保持较高的响应速度。 载均衡能够合理分配客户端请求或网络流量到多个服务器，避免单个服务器因负载过重而成为瓶颈，从而提升整体系统性能 怎么实现负载均衡？有什么策略（待定）我们先说有什么策略 轮询：循环的顺序将请求分配给每个服务器，适用于各服务器性能相近的情况。过对自增轮询下表对服务器总数取模来实现轮询。 随机：随机选择一个服务器来处理请求，适用于服务器性能相近且负载均匀的情况。通过指定提供者服务数量范围，使用Random取随机数。 最小连接数：择当前连接数最少的服务器来处理请求，适用于长连接场景。 加权轮询：服务器的性能或权重分配请求，性能更好的服务器会获得更多的请求，适用于服务器性能不均的情况。 加权随机：服务器的权重随机选择一个服务器处理请求，适用于服务器性能不均的情况。 加权最少连接：在最少连接法的基础上增加服务器的权重分配 源地址散列法（IP Hash）：据客户端IP地址的哈希值选择服务器处理请求，确保同一客户端的请求始终被分配到同一台服务器上，适用于需要保持会话一致性的场景。 一致性哈希法（ConsistentHashing）：将请求分配给最靠近哈希值的服务器，适用于动态变化的集群环境。 首先负载均衡是多层的，举个简单的例子，用户发送了一个请求，通过外网访问cdn缓存的静态文件，然后访问到域名，这个域名对应到nginx监听的端口，把请求转到内网的服务，一般就是网关对应的端口了，在nginx处我们可以搞集群，网关也可以搞集群，这里就可以做负载均衡，然后 https://icyfenix.cn/architect-perspective/general-architecture/diversion-system/load-balancing.html 在项目中又可以分为在服务端和在客户端的负载均衡，其中在服务端我通常使用nginx进行负载均衡（在conf文件中的http段定义服务器列表即可，要实现算法也简单，直接在定义的服务器段上写算法名称就行），在客户端 我们在项目中通过定义通用的负载均衡接口、使用工厂模式（根据用户动态配置负载均衡实例）、使用SPI机制（允许用户拓展自己的负载均衡器）实现了可扩展的负载均衡器 什么是 LVS?Nginx和LVS有什么区别？（待定）https://www.mianshiya.com/question/1824355723241373697 Ribbon 和 Nginx的区别是什么？ Nginx是服务端负载均衡，能独立部署。客户端所有的请求都传到Nginx，然后由Nginx实现转发请求，即服务均衡都是由服务端实现的，实现了反向代理。 Ribbon是本地负载均衡，属于客户端负载均衡，是一个类库。在调用微服务接口的时候，会先到注册中心获取注册信息服务列表，然后缓存到JVM本地，在本地决定选择哪个服务实例进行RPC远程调用，实现了客户端自定义选择，所以是客户端负载均衡 容错与恢复什么是断路器（服务熔断）？为什么需要断路器？在微服务架构中，一个系统可能由多个服务构成，这些服务之间相互进行远程调用，比如A调用B，B调用C，C调用其他微服务等等，这个时候如果调用链路上的某个服务岩机了，或者响应时间过长比如微服务C岩机了，这个时候服务A和B之间由于调用关系，可能也会出现服务不可用的情况，然后随着调用请求的增多，对系统资源的占用页越来越多，最后导致微服务系统整体崩溃，从而导系统的全面崩盘，这种现象就是我们所说的”服务雪崩” %% 在微服务架构中，服务之间的调用关系会形成调用链路，链路中的任何一个服务都可能出现超时或者岩机的情况，而在微服务系统中，如果调用失败的话可能会引起大面积的服务瘫痪，即形成“服务雪崩”的情况，这样的话对于服务的影响是巨大的。 %% 正常情况下，断路器处于关闭状态，服务消费者正常请求微服务中的服务提供者。 当发生了服务调用请求失败的时候，并且达到了一定比例，比如70%的请求发生了失败，或者失败的请求次数达到了100等等，这个时候断路器打开，此时将服务调用者不再发起服务调用请求，这种方法是一种快速失败的方法，也称为断路方法。 断路器启用一段时间时候，自动进入“半关闭状态”，这个时候断路器允许服务调用者发起一个请求给服务提供者，如果请求调用成功了，关闭断路器，反之继续打开断路器，循环往复。 一句话：为了避免大面积超时问题，让有问题的服务快速断路，启动一段时间后进入半关闭状态，用于判断服务是否健康，健康就关闭断路器，不健康就继续打开 你是做限流熔断降级限流的？（待定）目前市面上有很多相关的解决方案，比如 Hystrix Resilience4j Dubbo Sentinel 但是我使用最多的是Sentinel，他不但有图形化界面 ，而且因为是阿里开发的，和nacos、seata可以形成一套完善的微服务解决方案，Sentinel可以通过代理模式进行数据采集，再进行清洗和整合 当然Dubbo作为一个RPC框架，也内置了负载均衡熔断降级等，也可以作为我目前学习的微服务解决方案的一部分，也有一些了解 远程调用HTTP与RPC之间的区别？其中http是基于tcp的可以使用tls&#x2F;ssl进行安全加密，通信方式为客户端发送请求，服务端响应，并且主要使用RESTFul风格，而RPC可以用更多种传输协议，通过IDL进行接口定义。 严格上讲，Http和RPC不是一个层面的东西： Http是一种应用层的协议，主要强调的是网络通信； RPC，其是一种分布式系统之间通信的方式，强调的是服务之间的远程调用。 Ribbon和Feign调用服务的区别是什么？（待定）首先要知道，feign内置ribbon，ribbon是基于http、tcp等协议的负载均衡组件，并且需要手动在代码中设置调用目标服务 Feign和Dubbo的区别?（待定）为什么FFeign第一次调用耗时很长？（待定）日志处理你们的服务是怎么做日志收集的？我们采用的ELK那套，也就是ElasticSearch主要负责数据的存储和检索，Logstash主要负责从微服务集群采集日志，然后将日志数据发送到ES，最后Kibana就负责日志数据的可视化分析 具体来说，我们先配置（Logstash）日志收集器，通过配置插件从文件输入收集、网络输入收集等，监听服务的日志输出，并对日志信息进行过滤和处理，之后把数据发送到ES，配置logstash的输出插件，把输出的日志进行存储和索引，最后把Kibana链接到ES，创建仪表盘、图表以及搜索查询，从而实时监控和分析微服务的日志数据 分布式事务什么情况下需要使用分布式事务，有哪些方案？分布式事务是由多个本地事务组成的，一般存在跨多个数据库、或者不同服务的情况下要用到分布式事务 https://www.mianshiya.com/bank/1797453053310402561/question/1797616463733981185","tags":[null],"categories":[null]},{"title":"3xui面版搭建Reality协议，使用链式代理，最简单的魔法","path":"/workflow/3XUI.html","content":"摘要通过3xui实现链式代理，自建节点，高速低延迟 搭建dokcer-compose搭建123456789101112131415161718services: 3x-ui: image: ghcr.io/mhsanaei/3x-ui:latest container_name: 3xui restart: always mem_limit: 85m ports: - 20000-20005:20000-20005/tcp - 20000-20005:20000-20005/udp - 2053:2053/tcp volumes: - ./cert:/root/cert - ./db:/etc/x-ui logging: driver: json-file options: max-size: &quot;1m&quot; max-file: &quot;3&quot; 这边建议您通过docker compose up -d 运行后配置反向代理！但是需要开放20000-20005的端口（也可以自己选自己喜欢的端口），用于节点。 脚本搭建bash &lt;(curl -Ls https://raw.githubusercontent.com/mhsanaei/3x-ui/master/install.sh) 搭建节点基本配置证书申请见：泛域名证书申请 反向代理配置如下： 123456789101112#3xuiserver &#123; listen 443 ssl; server_name xui.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:2053/; &#125;&#125; 参考配置 vmess+ws类型：协议：vmess、端口：20001、传输：WebSocket reality类型节点：协议：vless、端口：20000、安全：REALITY、用户Flow：xtls-rprx-vision，Dest：目标网站:端口，SNI：目标网站 目标网站查询指南： 选择带有域名的 不要选证书为黄色的，比如 端口和自己的节点的端口一致，比如你的端口是443，那就是整个域名，比如你的端口是8080，那就是域名后面带有端口 8080 ，比如 exp.com:8080，当然对应的Dest：exp.com:8080，SNI：exp.com:8080 ASN查询：https://tools.ipip.net/as.php目标网站：https://fofa.info 下面查询可以修改自己的country和自己服务器的相同，以及端口等 asn==&quot;25820&quot; &amp;&amp; country==&quot;US&quot; &amp;&amp; port==&quot;443&quot; &amp;&amp; cert!=&quot;Let&#x27;s Encrypt&quot; &amp;&amp; cert.issuer!=&quot;ZeroSSL&quot; &amp;&amp; status_code=&quot;200&quot; 链式代理请求-&gt;服务器A-&gt;服务器B-&gt;目的 因为阿里云服务器（服务器A）很多流媒体无法访问，如果有其他vps或者ip等等（服务器B），可以在（服务器A）设置里面配置出站规则：你的vps的节点也好、socks也好，只要可以访问到你其他vps（服务器B）,让B帮你发请求。然后在路由规则里添加Domain比如：geosite:netflix,geosite:spotify,geosite:tiktok,geosite:meta,geosite:apple,geosite:reddit,geosite:openai然后配置Outbound Tag为你出站规则里访问服务器B的标签，就实现了请求分流。","tags":[null,null,null,null],"categories":[null]},{"title":"多种方法搭建私有bitwardn服务器   bitwarden & Vaultwarden","path":"/workflow/Bitwarden.html","content":"摘要开源的密码管理工具，我们搭建的是私有服务器，可以在手机下载对应应用以及在浏览器下载对应插件对私有服务器进行链接 搭建docker-compose 搭建注意看环境配置，一般DOMAIN、ADMIN_TOKEN和SIGNUPS_ALLOWED需要修改，建议在第一次部署的时候设置SIGNUPS_ALLOWED为true，创建账户后设置为false 1234567891011121314151617181920212223242526services: vaultwarden: container_name: vaultwarden image: vaultwarden/server:latest restart: always volumes: - ./data:/data ports: - &#x27;8385:80&#x27; environment: - DOMAIN=https://pwd.exp.com # 这是您希望与您的Vaultwarden实例关联的域名。 - LOGIN_RATELIMIT_MAX_BURST=10 # 允许在一阵登录/两步验证尝试中的最大请求次数。 - LOGIN_RATELIMIT_SECONDS=60 # 这是来自同一IP的登录请求之间的平均秒数，在Vaultwarden限制登录次数之前。 - ADMIN_RATELIMIT_MAX_BURST=10 # 这与LOGIN_RATELIMIT_MAX_BURST相同，只争对admin面板。 - ADMIN_RATELIMIT_SECONDS=60 # 这与LOGIN_RATELIMIT_SECONDS相同 - ADMIN_SESSION_LIFETIME=20 # 会话持续时间 - ADMIN_TOKEN=aaa # 此值是Vaultwarden管理员面板的令牌（一种密码）。为了安全起见，这应该是一个长的随机字符串。如果未设置此值，则管理员面板将被禁用。建议openssl rand -base64 48 生成ADMIN_TOKEN确保安全 - SENDS_ALLOWED=true # 此设置决定是否允许用户创建Bitwarden发送 - 一种凭证共享形式。 - EMERGENCY_ACCESS_ALLOWED=true # 此设置控制用户是否可以启用紧急访问其账户的权限。例如，这样做可以在用户去世后，配偶可以访问密码库以获取账户凭证。可能的值：true / false。 - WEB_VAULT_ENABLED=true # 此设置决定了网络保险库是否可访问。一旦您配置了您的账户和客户端，停止您的容器，然后将此值切换为false并重启Vaultwarden，可以用来防止未授权访问。可能的值：true/false。 - SIGNUPS_ALLOWED=false # 此设置控制新用户是否可以在没有邀请的情况下注册账户。可能的值：true / false。 logging: driver: json-file options: max-size: &quot;1m&quot; max-file: &quot;3&quot; 直接搭建12345678910111213141516171819# 创建文件夹mkdir /home/vw-imagecd /home/vw-image# 拉取可执行文件wget https://raw.githubusercontent.com/jjlin/docker-image-extract/main/docker-image-extract# 给运行权限chmod +x docker-image-extract# 提取docker中的可执行程序./docker-image-extract vaultwarden/server:alpine# 拷贝文件和目录mkdir -p /home/vaultwardencd output/# 将需要用到的 文件和目录拷贝到前面建好的目录cp -rf vaultwarden web-vault/ data/ /home/vaultwarden/# 下载环境配置文件wget https://raw.githubusercontent.com/dani-garcia/vaultwarden/main/.env.template -O vaultwarden.env 修改配置文件，直接复制在顶部就行，主要修改DOMAIN、ADMIN_TOKEN、SIGNUPS_ALLOWED 1234567891011121314151617181920212223242526272829# 这是您希望与您的Vaultwarden实例关联的域名。DOMAIN=https://bitwt.exp.top # 允许在一阵登录/两步验证尝试中的最大请求次数。LOGIN_RATELIMIT_MAX_BURST=10# 这是来自同一IP的登录请求之间的平均秒数，在Vaultwarden限制登录次数之前。LOGIN_RATELIMIT_SECONDS=60 # 这与LOGIN_RATELIMIT_MAX_BURST相同，只争对admin面板。ADMIN_RATELIMIT_MAX_BURST=10 # 这与LOGIN_RATELIMIT_SECONDS相同ADMIN_RATELIMIT_SECONDS=60 # 会话持续时间ADMIN_SESSION_LIFETIME=20 # 此值是Vaultwarden管理员面板的令牌（一种密码）。为了安全起见，这应该是一个长的随机字符串。如果未设置此值，则管理员面板将被禁用。## 建议openssl rand -base64 48 生成ADMIN_TOKEN确保安全ADMIN_TOKEN=# 此设置决定是否允许用户创建Bitwarden发送 - 一种凭证共享形式。SENDS_ALLOWED=true# 此设置控制用户是否可以启用紧急访问其账户的权限。例如，这样做可以在用户去世后，配偶可以访问密码库以获取账户凭证。可能的值：true / false。EMERGENCY_ACCESS_ALLOWED=true # 此设置决定了网络保险库是否可访问。一旦您配置了您的账户和客户端，停止您的容器，然后将此值切换为false并重启Vaultwarden，可以用来防止未授权访问。可能的值：true/false。WEB_VAULT_ENABLED=true # 此设置控制新用户是否可以在没有邀请的情况下注册账户。可能的值：true / false。SIGNUPS_ALLOWED=true# 给web端发送通知用的WEBSOCKET_ENABLED=true# IP地址WEBSOCKET_ADDRESS=0.0.0.0# 运行端口WEBSOCKET_PORT=8000 创建启动脚本 vim /etc/systemd/system/vaultwarden.service 12345678910111213141516171819202122232425262728293031323334[Unit]Description=vaultwarden Server (Rust Edition)Documentation=https://github.com/dani-garcia/vaultwarden# Only sqliteAfter=network.target network-online.targetRequires=network-online.target# MariaDB# After=network.target mariadb.service# Requires=mariadb.service# Mysql# After=network.target mysqld.service# Requires=mysqld.service# PostgreSQL# After=network.target postgresql.service# Requires=postgresql.service[Service]# The location of the .env file for configurationEnvironmentFile=/home/vaultwarden/vaultwarden.env# The location of the compiled binaryExecStart=/home/vaultwarden/vaultwarden# Set reasonable connection and process limitsLimitNOFILE=1048576LimitNPROC=64# Only allow writes to the following directory and set it to the working directory (user and password data are stored here)WorkingDirectory=/home/vaultwarden[Install]WantedBy=multi-user.target 启动 12345678# 重载配置文件systemctl daemon-reload# 启动sudo systemctl start vaultwarden.service# 删除/home/vw-imagerm -rf /home/vw-image 配置反向代理123456789101112#bitwortenserver &#123; listen 443 ssl; server_name bitwt.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8000/; &#125;&#125;","tags":[null,null,null],"categories":[null]},{"title":"基于syncthing+oss+云服务器的文件同步与数据备份教程","path":"/workflow/Syncthing.html","content":"摘要从需求分析到具体实现，快速实现基于syncthing+oss+云服务器的文件同步与数据备份，此专栏的目的是充分利用云服务器，所以没有选择CDN，而是通过oss内外访问云服务，以云服务器为出口进行同步。 前言需求 数据安全，最重要的一个需求 备份容量，目前需求100G左右 价格不贵，百度云vip188&#x2F;年，以他为标准，浮动100左右 下载速度快，最起码别是100多kb&#x2F;s 可预览，可以线上看看图片、视频什么的 多端同步：最起码要可以把手机和电脑数据同步起来，最起码要有版本控制，以及多种同步类型 自动备份：要能自动备份多个不同的文件夹，比如图片、文档什么的 思路 Syncthing 是多端同步的工具，其功能类似于微力同步，但是开源，他是P2P的，这样就要求两个设备必须同时在线。 使用云服务器搭建Syncthing作为中转和备份服务器，这样就可以只一个设备在线，因为云服务器是不停机的 如果是需要经常同步的我选择直接存在服务器的云盘里 如果是备份，我在云服务器里挂载OSS为目录，通过内网访问OSS，这样就没有流量费用 使用alist挂载云服务器本地目录+rclone挂载Alist到电脑进行预览（可选） 页面展示Syncthing - 服务器 Syncthing - 电脑 Syncthing - 安卓 效果展示 服务器带宽 30M ，同步和备份时速度可接受，内存占用为100M以内 存储容量：云盘自带60G+OSS的40G &#x3D; 100G 电脑开机自启：Syncthing，完全无感 手机可以后台常驻运行Syncthing，记得开启允许后台高耗电，以及设置息屏联网，实现无感同步。 优点 可以无感备份与同步任何文件！ 速度取决于你的服务器，无限速问题 数据很安全，用的都是开源项目，数据放在阿里云的服务器和OSS里，如果还不放心可以增加容灾设计 可玩性较高，几乎完全满足需求！ 手机可以常驻后台备份！ 缺点 折腾起来比较麻烦 手机常驻后台会增加发热问题 syncthing 同步和冲突处理没有那么细的粒度 拓展 有时间可以整一个一键脚本，直接部署 香港服务器都有了，顺便整点魔法 整一个服务器监控看板 把UI面版都整上Https 如果想可以设计docker进行部署，需要注意容器编排和目录映射问题 准备好了吗！发车！ 核心：Syncthing 需要：云服务器，OSS对象存储，电脑，手机 数据安全：数据为本地存储，云端则为阿里云服务器+OSS，次方案使用的项目均为开源项目 我的配置：阿里云香港轻量服务器（debian11），9元一年OSS标准存储资源包，Win10笔记本，安卓手机 实际花费：阿里云香港轻量服务器 288&#x2F;年就够用了，我买的是408.00一年的那个 建议选择带宽较大的轻量服务器，大可以选择自己觉得便宜和稳定的，注意：服务器和oss存在地域问题！选同一个地域的，不然要nginx代理。 实操安装Syncthing服务器直接安装123456789101112131415161718192021222324252627282930cd /home# https://github.com/syncthing/syncthing/releaseswget https://github.com/syncthing/syncthing/releases/download/v1.27.10/syncthing-linux-amd64-v1.27.10.tar.gz# 解压tar -xzvf syncthing-linux-amd64-v1.27.10.tar.gz# 删除压缩包rm -f syncthing-linux-amd64-v1.27.10.tar.gz# 重命名(可选)mv /home/syncthing-linux-amd64-v1.27.10 /home/syncthing# 创建日志文件mkdir /home/logs/sudo touch /home/logs/syncthing.log# 修改`/home/username/.config/syncthing/config.xml`中的`gui`标签，把`127.0.0.1`改成`0.0.0.0`，开启远程访问# 如果你的usernam为root，那么config.xml在/root/.local/state/syncthing# 可选的！后续会开启反向代理vim /root/.local/state/syncthing/config.xml# 官方文档：https://docs.syncthing.net/users/stdiscosrv.html# 后台运行cd /home/syncthingnohup ./syncthing &gt; /home/logs/syncthing.log 2&gt;&amp;1 &amp;# 使用jobs查看运行情况jobs# 查看日志cat /home/logs/syncthing.log docker-compose 安装# 目录：/home/docker/syncthingmkdir /home/docker/syncthingcd /home/docker/syncthingvi docker-compose.yml 123456789101112131415161718services: syncthing: image: syncthing/syncthing:latest container_name: syncthing hostname: syncthing #optional restart: always mem_limit: 120m memswap_limit: -1 user: root environment: - PUID=1000 - PGID=1000 - TZ=Asia/Shanghai volumes: - ./syncthing:/var/syncthing - /home/data:/home/data # 此次配置额外添加的路径 ports: - &#x27;8384:8384&#x27; # 面版端口 PC访问：Github下载windows版本的Syncthing，直接运行即可 开机自启，后台运行： 创建bat文件写入 start &quot;Syncthing&quot; syncthing.exe -no-console -no-browser 创建快捷方式后，Win+R 输入 shell:startup，把快捷方式拖进去 Android访问：Github下载android版本的Syncthing，直接运行即可，给足权限，让他常驻后台 服务器挂载OSSoss的创建与配置资源包购买：https://oss.console.aliyun.com/packagebucket创建：https://oss.console.aliyun.com/bucket 名称随意 地域选择和自己服务器相同的地方 私有读写即可，因为我们是通过服务器出的公网流量，服务器和oss之间的访问用内网就行了，免费且高速，缺点是oss的访问速度全看服务器的带宽了。 示例：ECS地域OSS地域 挂载OSS到ECS12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 进入目录cd /home# 更新索引sudo apt-get -y update # 安装ossfssudo apt-get install automake autotools-dev g++ git libcurl4-gnutls-dev \\ libfuse-dev libssl-dev libxml2-dev make pkg-config# 克隆编译代码git clone https://github.com/aliyun/ossfs.gitcd ossfs./autogen.sh./configuremakesudo make install# 配置全局密钥，输入OSS对应的key和secret，不知道怎么获取看这个：# https://blog.csdn.net/weixin_45606067/article/details/114292972# my-access-key-id 你的key # my-access-key-secret 你的secret# my-bucket是你的存储空间名称echo my-bucket:my-access-key-id:my-access-key-secret &gt; /etc/passwd-ossfs# 也可以进行编辑vim /etc/passwd-ossfschmod 600 /etc/passwd-ossfs# 挂载oss目录# /path/to/mountpoint是你挂载到的服务器上的目录# my-oss-endpoint是你oss的访问域，一定要选内网的！ossfs my-bucket /path/to/mountpoint -ourl=my-oss-endpoint# 示例mkdir /home/data/blogossfs my-notes-blog /home/data/blog -ourl=oss-cn-hongkong-internal.aliyuncs.com# 查看挂载情况（可选）df | grep ossfs# 详细情况（可选）# /root/Data/OSS 是挂载的路径df -hT /root/Data/OSS# 删除挂载点（可选）sudo umount /root/Data/OSS 123456789101112131415161718192021222324252627282930313233# 项目地址https://github.com/aliyun/ossfs/releases# 安装命令，需要和上面项目地址查询出版本对应mkdir /home/ossfssudo wget -P /home/ossfs https://gosspublic.alicdn.com/ossfs/ossfs_1.91.3_ubuntu16.04_amd64.debsudo apt-get updatesudo apt-get install gdebi-coresudo gdebi ossfs_1.91.3_ubuntu16.04_amd64.deb### 1.将账号信息保存到账号信息配置文件/etc/passwd-ossfs下，并设置文件权限为640echo bucket-test-1:AAAI************:AAA8x************************* &gt; /etc/passwd-ossfsecho bucket-test-2:BBBI************:BBB8x************************* &gt;&gt; /etc/passwd-ossfschmod 640 /etc/passwd-ossfs### 2.创建挂载目录，将杭州地域名称为bucket-test-1、bucket-test-2的bucket分别挂载到/tmp/ossfs-1、/tmp/ossfs-2目录下mkdir /tmp/ossfs-1mkdir /tmp/ossfs-2ossfs bucket-test-1 /tmp/ossfs-1 -ourl=http://oss-cn-hangzhou.aliyuncs.comossfs bucket-test-2 /tmp/ossfs-2 -ourl=http://oss-cn-hangzhou.aliyuncs.com## 将账号信息保存到账号信息配置文件/etc/passwd-ossfs-3下，并设置文件权限为600echo bucket-test-3:CCCIbZcdVCmQ****:CCC8x0y9hxQ31coh7A5e2MZEUz**** &gt; /etc/passwd-ossfs-3chmod 600 /etc/passwd-ossfs-3\t##创建挂载目录，将杭州地域名称为bucket-test-3的bucket挂载到/tmp/ossfs-3目录下 mkdir /tmp/ossfs-3ossfs bucket-test-3 /tmp/ossfs-3 -ourl=http://oss-cn-hangzhou.aliyuncs.com -opasswd_file=/etc/passwd-ossfs-3## 将账号信息保存到账号信息配置文件/etc/passwd-ossfs-4下，并设置文件权限为600echo bucket-test-4:DDDIbZcdVCmQ****:DDD8x0y9hxQ31coh7A5e2MZEUz**** &gt; /etc/passwd-ossfs-4chmod 600 /etc/passwd-ossfs-4##创建挂载目录，将杭州地域名称为bucket-test-4的bucket挂载到/tmp/ossfs-4目录下mkdir /tmp/ossfs-4ossfs bucket-test-4 /tmp/ossfs-4 -ourl=http://oss-cn-hangzhou.aliyuncs.com -opasswd_file=/etc/passwd-ossfs-4 注意我这里挂载了两个目录，syncthing使用的oss和我后续博客上推使用的oss是两个不同的存储空间，但是都是和服务器在同一个地域 配置Syncthing搭建发现服务器先通过发现服务器 (Discosrv)发现和索引用户，当用户设备接入发现服务器后，服务器会进行设备的连接通告，当设备之间同意连接后进行连接；两台设备建立连接后，数据需要通过 NAT 穿透的方式实现交换。 1234567891011121314151617181920212223cd /home/syncthing# 仓库在：https://github.com/syncthing/discosrv/releases，想用新的直接换新链接就行wget https://github.com/syncthing/discosrv/releases/download/v1.23.4/stdiscosrv-linux-amd64-v1.23.4.tar.gz# 解压tar -xzvf stdiscosrv-linux-amd64-v1.23.4.tar.gz# 删除压缩包rm -f stdiscosrv-linux-amd64-v1.23.4.tar.gz# 重命名(可选)mv stdiscosrv-linux-amd64-v1.23.4 stdiscosrv# 创建日志文件sudo touch /home/logs/stdiscosrv.log# 官方文档：https://docs.syncthing.net/users/stdiscosrv.html# 后台运行cd stdiscosrvnohup ./stdiscosrv &gt; /home/logs/stdiscosrv.log 2&gt;&amp;1 &amp;# 使用jobs查看运行情况jobs# 查看日志cat /home/logs/stdiscosrv.log 搭建中继节点如果 NAT 穿透不成功，就需要中继 (Relaysrv)服务器传输数据，假如电脑要和手机进行笔记同步，通信过程就是：电脑-中继-手机，当然Syncthing自带有公共网络服务，但是此文章使用云服务器就是为了搭建一个中继的通信过程 1234567891011121314151617181920212223242526cd /home/syncthing# 仓库在：https://github.com/syncthing/discosrv/releases，想用新的直接换新链接就行wget https://github.com/syncthing/relaysrv/releases/download/v1.22.1/strelaysrv-linux-amd64-v1.22.1.tar.gz# 解压tar -xzvf strelaysrv-linux-amd64-v1.22.1.tar.gz# 删除压缩包rm -f strelaysrv-linux-amd64-v1.22.1.tar.gz# 重命名(可选)mv strelaysrv-linux-amd64-v1.22.1 strelaysrv# 创建日志文件sudo touch /home/logs/strelaysrv.log# 运行 # https://docs.syncthing.net/users/strelaysrv.html# pools为空是不加入公共中继节点，部署为私有cd strelaysrvnohup ./strelaysrv -pools=&quot;&quot; &gt; /home/logs/strelaysrv.log 2&gt;&amp;1 &amp;# 使用jobs查看运行情况jobs# 查看日志cat /home/logs/strelaysrv.log 可以先配置反向代理和泛域名证书，详细见nginx章节，配置文件如下： 123456789101112# syncthingserver &#123; listen 443 ssl; server_name sync.exp.com; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8384/; &#125;&#125; 再回来配置syncthing，记得给电脑、服务器、手机都配置一下，协议监听地址对应中继节点地址，全局发现服务器和全局发现的地址。还有记得开放端口：22067&#x2F;tcp 和 8443&#x2F;tcp 123456789101112# 查看日志cat /home/logs/strelaysrv.logcat /home/logs/stdiscosrv.log# 协议监听地址，中继服务URI relay://公网IP:22067?id=中继服务器device ID relay://0.0.0.0:22067/?id=DGSNZJM-MASJL6U-WJJA2RJ-GDTAALI-JZOF6NS-KPPDNQU-T4TV7OQ-YK6ATAM&amp;networkTimeout=2m0s&amp;pingInterval=1m0s&amp;statusAddr=%3A22070# 全局发现服务器 https://公网IP:8443/?id=发现服务器device ID 记得每个安装了sync的设备都要设置！ 配置说明举个例子：文件夹路径是本地计算机的路径，比如我们现在需要电脑同步到服务器，那么过程就是 打开电脑上的 syncthing http://127.0.0.1:8384/，添加文件夹，路径选择自己电脑本地的要上传的文件路径，如：D:\\My\\Notes，在共享里选择服务器上的 syncthing 打开服务器上的 syncthing ，你会看到发过来的共享请求，那么在接受后的配置里面，选择你需要保存在服务器上的地址，比如挂载后的OSS地址或者服务器的其他地方 现在如果你需要再同步给手机，那么就选择服务器上电脑发过来的共享文件夹，同样的点击共享就可以分享到手机","tags":[null,null,null,null,null,null],"categories":[null]},{"title":"Hexo搭建个人博客，Stellar主题美化教程，hexo结合obsidian实现一键发布","path":"/workflow/Hexo.html","content":"需求分析内容展示需要写在简历里，所以当点进博客主目录需要快速概览的查看到总共做了什么内容。最好以图片的形式进行展现，这就需要排序功能，把高质量的，可以彰显技术力的文章放在前面，当点进去后会看到其同类型的笔记，浏览完后想返回时会注意到文档目录和个人简介按钮，到这里应该就知道整个博客的点击流程。其中点击个人简介会展示自己开源项目详细解释与地址，以及一些技术的描述，这些技术可以通过类似点击标签的形式访问到对应的文章（如果有） 编辑发布需要方便编写，在编写完后一键发布，并且不需要再设置博客的其他配置。已发布和未发布的文章不应有太大差距，编译前后使用同一套语法，附件方便管理，每个文章有对应的附件文件夹，文章链接不应很长，需要进行高效的SEO，当然需要有评论功能，其他人也可以通过邮箱和我进行交流 效果展示 初步化建议： 一个前端编译器如：vscode、webstorm 有node环境。建议版本在20.10.0以下，如18.20.0 安装hexo安装npm install hexo-cli -ghexo init blogcd blognpm install stellara安装npm i hexo-theme-stellar# 在 `blog/_config.yml` 文件中找到并修改theme: stellar # 也可以使用源码的方式进行安装git clone https://github.com/xaoxuu/hexo-theme-stellar.git# 把他放在themes目录下即可# 在 `blog/_config.yml` 文件中找到并修改theme: stellar 运行使用 hexo s 运行或者在编译器里找到package.json文件直接点击运行 软件笔记软件推荐obsidian，地址：https://obsidian.md/download，当然其他软件也可以，但是非本地存储的软件不太使用本教程 配置hexo 配置附件相对链接# 下载插件会转为 绝对路径npm install hexo-asset-image --save 我的配置 123456new_post_name: :hash.md # 新文章的文件名称post_asset_folder: truerelative_link: false # 把链接改为与根目录的相对位址 marked: prependRoot: true postAsset: true 站点图标12345678# 在在主站点的 _config.yml 里配置## 匹配到的文件将会被不做改动地复制到 public 目录中。 您可使用 glob 表达式来匹配路径。skip_render: images/**# 在source目录下新建imgs,访问路径为 images/xx.jpg# 在在主站点的 _config.yml 里配置avatar: &#x27;/images/avatar.png&#x27; # 站点头像 favicon: &#x27;/images/favicon-28-dog.svg&#x27; # 站点icon 推送Github或者OSS1234567891011121314151617181920212223# 安装插件npm install hexo-deployer-git --savenpm install hexo-deployer-ali-oss --save# 部署设置 # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: - type: git repo: git@github.com:Missiu/missiu.github.io.git # example, https://github.com/hexojs/hexojs.github.io branch: main - type: ali-oss region: &lt;您的oss 区域代码&gt; accessKeyId: &lt;您的oss accessKeyId&gt; accessKeySecret: &lt;您的oss accessKeySecret&gt; bucket: &lt;您的bucket name&gt;\tcacheControl: images: public, max-age=15552000 # 缓存时间6个月 css: public, max-age=1209600 # 缓存时间14天 js: public, max-age=259200 # 缓存时间3天 html: public, max-age=259200 # 缓存时间3天 other: no-cache # 缓存时间0 完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148# Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: Hzh subtitle: &quot;我亦无他，唯手熟尔 | Life-long learning&quot; # 网站副标题 description: &#x27;主要分享一些学习笔记和个人见解&#x27; # 网站描述 keywords: [ &#x27;计算机&#x27;,&#x27;开发&#x27;,&#x27;编程&#x27;,&#x27;网站&#x27;,&#x27;博客&#x27;,&#x27;技术&#x27;,&#x27;学习&#x27;,&#x27;教程&#x27;,&#x27;服务器&#x27;,&#x27;Java&#x27;,&#x27;后端&#x27; ] # 网站的关键词。 支持多个关键词。 author: Huzhihao language: - zh-CN - en - zh-TW timezone: &#x27;Asia/Shanghai&#x27; avatar: &#x27;/images/avatar.png&#x27; # 站点头像 favicon: &#x27;/images/favicon-28-dog.svg&#x27; # 站点icon # URL ## 网站地址，比如github地址： ## &#x27;https://username.github.io/project&#x27; url: http://localhost:4000/ permalink: :abbrlink.html # 文章的 永久链接 格式 permalink_defaults: # 永久链接中各部分的默认值 pretty_urls: # 美化永久链接 trailing_index: true # 设置 false 以删除「页面」永久链接结尾的&#x27;index.html&#x27;部分 trailing_html: true # 设置 false 以删除「文章」永久链接结尾的&#x27;.html&#x27;部分 # Directory source_dir: source # 源文件夹。您的内容的存储位置 public_dir: public # 公共文件夹。静态站点将在哪里生成 tag_dir: tags # 标签文件夹 archive_dir: archives # 归档文件夹 category_dir: categories # 分类文件夹 code_dir: downloads/code # Include code 文件夹，source_dir 下的子目录 i18n_dir: :lang # 国际化（i18n）文件夹 # https://github.com/micromatch/micromatch#extended-globbing skip_render: [images/**] # 匹配到的文件将会被不做改动地复制到 public 目录中。 您可使用 glob 表达式来匹配路径。 # Writing new_post_name: :title.md # 新文章的文件名称 default_layout: post # 预设布局 #titlecase: false # 把标题转换为 title caseexternal_link: # 在新标签中打开链接 # enable: true # 在新标签中打开链接 # field: site # 对整个网站（site）生效或仅对文章（post）生效 # exclude: &#x27;&#x27; # 需要排除的域名。 主域名和子域名如 www 需分别配置 filename_case: 0 # 修改文件名称大小写，1 小写; 2 大写 render_drafts: false # 显示草稿 # https://hexo.io/zh-cn/docs/asset-folders # 如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。 # 然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 post_asset_folder: true # 启用 资源文件夹 #资源图片将会被自动解析为其对应文章的路径。 ## 例如： image.jpg 位置为 /2020/01/02/foo/image.jpg,这表示它是 /2020/01/02/foo/ 文章的一张资源图片 ## ![](image.jpg) 将会被解析为 &lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt; 。 relative_link: false # 把链接改为与根目录的相对位址 marked: prependRoot: true postAsset: true future: true # 显示未来的文章 # https://hexo.io/zh-cn/docs/syntax-highlight syntax_highlighter: highlight.js # 代码块的设置, 请参考 代码高亮 进行设置 # 代码块的设置, 请参考 Highlight.js 进行设置 # https://hexo.io/zh-cn/docs/syntax-highlight#Highlight-js highlight: line_number: true # 行号显示。 auto_detect: false # 自动检测代码块的语言。十分耗费资源! tab_replace: &#x27;&#x27; # 用给定字符串替换代码块内的制表符。 默认为 2 个空格。 line_threshold: 5 # 接受一个可选的阈值，只有代码块的行数超过这个阈值才显示行数。 默认值为 0。 wrap: true # 支持行号显示 hljs: false # 当 hljs 设置为 true 时，所有代码块的 HTML 输出均会给 class 添加 hljs- 前缀（无论 wrap 是否开启 # 代码块的设置, 请参考 PrismJS 进行设置 # https://hexo.io/zh-cn/docs/syntax-highlight#PrismJS prismjs: preprocess: true # Hexo 内建的 PrismJS 支持浏览器端高亮（preprocess 设置为 false）和服务器端高亮（preprocess 设置为 true）两种方式。 line_number: true # 因为 line_number 功能依赖 wrap，你无法在配置中关闭 wrap 而又开启 line_number。 如果你将 line_number 设置为 true 的话，wrap 将被自动开启 tab_replace: &#x27;&#x27; # 将代码块内的 \\t 替换为给定的字符串。 默认为 2 个空格。 line_threshold: 5 # 接受一个可选的阈值，只有代码块的行数超过这个阈值才显示行数。 默认值为 0。 # Home page setting # path: Root path for your blogs index page. (default = &#x27;&#x27;) # per_page: Posts displayed per page. (0 = disable pagination) # order_by: Posts order. (Order by date descending by default) # https://github.com/hexojs/hexo-generator-index index_generator: # 生成帖子档案，由hexo-generator-index提供支持 path: &#x27;&#x27; # 博客索引页的根路径 per_page: 10 # 每页显示的帖子。 order_by: -date # 帖子订单。默认情况下按降序日期（从新到旧）排序。 pagination_dir: page # URL格式，参见下面的分页设置 # Category &amp; Tag default_category: post # 默认分类 category_map: # 分类别名 tag_map: # 标签别名 # Metadata elements ## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta meta_generator: true # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD # 日期格式 time_format: HH:mm:ss # 时间格式 ## 当 Front Matter 中没有指定 updated 时 updated 的取值 ### mtime: 使用文件的最后修改时间。 这是从 Hexo 3.0.0 开始的默认行为。 ### date: 使用 date 作为 updated 的值。 可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变 ### empty: 直接删除 updated。 使用这一选项可能会导致大部分主题和插件无法正常工作。 updated_option: &#x27;date&#x27; # Pagination ## 每页显示的帖子数。 0 关闭分页功能 per_page: 100 pagination_dir: page # 使用以下选项可明确处理或忽略某些文件/文件夹。 可以使用 glob 表达式 进行路径匹配。 ## include 和 exclude 选项只会应用到 source/ ，而 ignore 选项会应用到所有文件夹 # https://hexo.io/zh-cn/docs/configuration include: # 包含隐藏文件（包括名称以下划线开头的文件/文件夹，* 除外） exclude: # 排除文件或文件夹 ignore: # 忽略文件/文件夹 # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: stellar# 部署设置 # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy: - type: git repo: git@github.com:Missiu/missiu.github.io.git # example, https://github.com/hexojs/hexojs.github.io branch: main - type: ali-oss region: &lt;您的oss 区域代码&gt; accessKeyId: &lt;您的oss accessKeyId&gt; accessKeySecret: &lt;您的oss accessKeySecret&gt; bucket: &lt;您的bucket name&gt;\tcacheControl: images: public, max-age=15552000 # 缓存时间6个月 css: public, max-age=1209600 # 缓存时间14天 js: public, max-age=259200 # 缓存时间3天 html: public, max-age=259200 # 缓存时间3天 other: no-cache # 缓存时间0 stellara配置文章封面# 可以在 front-matter 里配置自己的图片地址,比如cover: /workflow/IMG-20240808143434703.png 文章推荐123456789# 要实现相关文章推荐功能，您需要安装插件npm i hexo-related-popular-posts -save# 在 _config.stellar.yml 中配置## 开启后会在每篇文章的下方推荐相同类型的文章article: related_posts: enable: true title: 您可能感兴趣的文章 文章配置12345678# 在主题配置文件中：_config.stellar.ymlarticle: # 建议您通过 `description` 或者 `excerpt` 方式生成摘要，但如果您希望自动从文章内容截取一定字数的文字作为摘要，可以这样设置：\tauto_excerpt: 200 # 许可协议\tlicense: &#x27;本文由 [Mr. Hu](/about/) 原创, 采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。&#x27;\t# 分享链接\tshare: [wechat, weibo, link] 实现博客专栏这个专栏有点文章分类的那个意味，建议用于处理5篇及其一下的同类型文章 在文章 front-matter 里配置 topic 字段 # 这个值是专栏唯一值 ，比如：Java 专栏topic: java 创建一个专栏：在 blog/source/_data/ 文件夹中创建一个 topic 文件夹，在其中放入各个专栏的描述文件，文件名就是项目的 id，比如这里是 java # 这里是blog/source/_data/topic/java.ymlname: Java # 在面包屑导航上会显示较短的名字 title: Java 由Java基础到Java高级 # 在列表页会显示完整的专栏标题 description: 包含Java基础知识、JVM、Java多线程，以及常问面试题order_by: -date # 默认是按发布日期倒序排序 示例路径： 关于页面# 直接在source/about创建index.md文件即可# 建议指定 front-matter 的 menu_id为about，这会影响后续侧边栏的配置--- menu_id: about --- 实现文档功能这个文档功能可以处理很多的同类型文章，需要注意的是其存放的位置不同于其他文章，同样以Java为例： 修改wiki路径（可选）： # 在_config.stellar.yml目录下site_tree: wiki: base_dir: books # books / products ... 在 blog/source/_data/ 文件夹中创建一个 wiki 文件夹，在其中放入各个项目的文档。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 这里是blog/source/_data/wiki/java.yml# 基本信息 name: Java # 在面包屑导航上会显示较短的名字 title: Java 由Java基础到Java高级 # 在列表页会显示完整的专栏标题 description: 包含Java基础知识、JVM、Java多线程，以及常问面试题 tags: icon:# 是否显示封面cover: coverpage: false # 该文档的仓库链接（如果有） repo: Missiu/Beaudar-Comments # 配置搜索功能 search: filter: /books/java/ placeholder: 在 Java 中搜索... # 显示许可协议license: true# 显示分享share: true# 如果您希望自定义某个项目的侧边栏组件，可以设置 `sidebar` 值leftbar: - tree # 目录树 # - timeline_stellar_releases # 发布时间线 # - related # 相关文章 # 项目评论设置 comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/Missiu/Beaudar-Comments/issues) 反馈。&#x27; # 评论服务配置 comments: service: beaudar beaudar: repo: Missiu/Beaudar-Comments # 修改 wiki 路径 优先级最高，每个不同的文档可以配置不同的base_dirsite_tree: wiki: base_dir: books # books / products ...# 基础目录设置 base_dir: /books/java/ # 指定项目所在文件夹和目录树tree: &#x27;快速开始&#x27;: - workflow/workflow &#x27;基本使用&#x27;: - JVM/JVM 需要给文章添加关键字，然后该文章可能在 source/books/java/workflow目录下 # front-matterwiki: java 在 blog/source/_data/ 文件夹中创建一个 wiki.yml 文件，在其中写入需要显示的项目 - java 示例路径 侧边栏导航我的侧边栏设计为 ： 博客 + 文档 + 关于 三个部分 ，需要针对这个三个部分进行设置 1234567891011121314151617181920212223# 在_config.stellar.yml文件里# 侧边栏主功能导航菜单 menubar: columns: 3 # 一行多少个 items: # 可按照自己需求增加，符合以下格式即可 # id: 页面中高亮的 menu_id # theme: 高亮时的颜色，仅 svg 中 fill=&quot;currentColor&quot; 时有效 # icon: 支持 svg/img 标签，可以定义在 icons.yml 文件中，也支持外部图片的 URL # title: 标题 # url: 点击跳转到哪，支持相对路径和绝对路径 - id: post theme: &#x27;&#x27; icon: &#x27;&#x27; title: 专栏 url: /topic/ - id: wiki theme: &#x27;&#x27; icon: &#x27;&#x27; title: 文档 url: /wiki/ - id: about theme: &#x27;&#x27; icon: &#x27;&#x27; title: 关于 url: /about/ 侧边栏背景12345678# 在_config.stellar.yml中style: leftbar: # 可以设置：纯色/渐变色/图片作为背景 # background: var(--leftbar-bg) background-image: url(/images/background.png) blur-px: 200px blur-bg: var(--alpha50) 搜索功能12345678# 在_config.stellar.yml中search: service: local_search # local_search, algolia_search, todo... local_search: # 在 front-matter 中设置 indexing:false 来避免被搜索索引 field: all # post, page, all path: /search.json # 搜索文件存放位置 content: true # 是否搜索内容 codeblock: true # 是否搜索代码块 评论功能Beaudar 是 Utterances 的中文版本，相比 Utterances 有更多的体验优化，可以按时间倒序排序。 # _config.stellar.ymlcomments: service: beaudar beaudar: repo: Missiu/Beaudar-Comments 在obsidian中的 front-matter建议在obsidian安装插件：Templater 在其中新进文本文件比如： front-matter.txt 1234567891011121314151617181920212223242526272829---# 文章标题 title: （一）充分利用云服务器，如何围绕云服务器搭建自己的工作流# 文章创建时间date: 2024-08-18 21:01:43# 标签列表tags: []# 分类列表categories: []# 文章更新时间updated: 2024-08-18 21:01:43# 封面图片链接cover: # 文章置顶顺序，数字越大越靠前sticky:# 参考资料列表references: []# 是否允许评论comments: true# 是否允许被搜索引擎收录,设置 false 避免被搜索indexing: truetopic: []# tech/storytype: tech# 专栏 idtopic: # 文档 idwiki: --- 完整配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580######## Stellar info ######## stellar: version: &#x27;1.29.1&#x27; homepage: &#x27;https://xaoxuu.com/wiki/stellar/&#x27; repo: &#x27;https://github.com/xaoxuu/hexo-theme-stellar&#x27; main_css: /css/main.css main_js: /js/main.js ######## head tags ######## preconnect: # - https://gcore.jsdelivr.net # - https://cdn.jsdelivr.net # - https://unpkg.com open_graph: enable: true twitter_id: # for open_graph meta ######## Sidebar ######## # 左上角显示的 logo 区域，包含图标、大标题、副标题 logo: avatar: &#x27;[&#123;config.avatar&#125;](/about/)&#x27; # you can set avatar link in _config.yml or &#x27;[https://xxx.png](/about/)&#x27; title: &#x27;[&#123;config.title&#125;](/)&#x27; # you can set html tag like: &#x27;[&lt;img no-lazy height=&quot;32px&quot; src=&quot;xxx&quot;/&gt;](/)&#x27; subtitle: &#x27;&#123;config.subtitle&#125;&#x27; # &#x27;文字1 | 文字2&#x27; (鼠标放上去会切换到文字2) # 侧边栏主功能导航菜单 menubar: columns: 3 # 一行多少个 items: # 可按照自己需求增加，符合以下格式即可 # id: 页面中高亮的 menu_id # theme: 高亮时的颜色，仅 svg 中 fill=&quot;currentColor&quot; 时有效 # icon: 支持 svg/img 标签，可以定义在 icons.yml 文件中，也支持外部图片的 URL # title: 标题 # url: 点击跳转到哪，支持相对路径和绝对路径 - id: post theme: &#x27;&#x27; icon: &#x27;&#x27; title: 专栏 url: /topic/ - id: wiki theme: &#x27;&#x27; icon: &#x27;&#x27; title: 文档 url: /wiki/ - id: about theme: &#x27;&#x27; icon: &#x27;&#x27; title: 关于 url: /about/ # - id: post # theme: &#x27;#1BCDFC&#x27; # icon: solar:documents-bold-duotone # title: 博客 # url: / # - id: wiki # theme: &#x27;#3DC550&#x27; # icon: solar:notebook-bookmark-bold-duotone # title: 文档 # url: /wiki/ # - id: explore # theme: &#x27;#FA6400&#x27; # icon: solar:planet-bold-duotone # title: 探索 # url: /explore/ # - id: social # theme: &#x27;#F44336&#x27; # icon: solar:chat-square-like-bold-duotone # title: 社交 # url: /friends/ ######## Main ######## # 站点主结构树 site_tree: # -- 列表类页面 -- # # 主页配置 home: leftbar: welcome, recent rightbar: # 博客列表页配置 index_blog: base_dir: blog # 只影响自动生成的页面路径 menu_id: post # 未在 front-matter 中指定 menu_id 时，layout 为 post 的页面默认使用这里配置的 menu_id leftbar: welcome, recent # for categories/tags/archives rightbar: nav_tabs: # 近期发布 分类 标签 专栏 归档 and ... # &#x27;朋友文章&#x27;: /friends/rss/ # 博客专栏列表页配置 index_topic: base_dir: topic # 只影响自动生成的页面路径 menu_id: post # 未在 front-matter 中指定 menu_id 时，layout 为 topic 的页面默认使用这里配置的 menu_id # 文档列表页配置 index_wiki: base_dir: wiki # 只影响自动生成的页面路径 menu_id: wiki # 未在 front-matter 中指定 menu_id 时，layout 为 wiki 的页面默认使用这里配置的 menu_id leftbar: related, recent # for wiki rightbar: nav_tabs: # &#x27;more&#x27;: https://github.com/xaoxuu # -- 内容类页面 -- # # 博客文章内页配置 post: menu_id: post # 未在 front-matter 中指定 menu_id 时，layout 为 post 的页面默认使用这里配置的 menu_id leftbar: related, recent # for pages using &#x27;layout:post&#x27; rightbar: ghrepo, toc # 博客专栏文章内页配置 topic: menu_id: post # 文档内页配置 wiki: menu_id: wiki # 未在 front-matter 中指定 menu_id 时，layout 为 wiki 的页面默认使用这里配置的 menu_id leftbar: tree, related, recent # for wiki rightbar: ghrepo, toc # 笔记本列表页配置 notebooks: base_dir: notebooks # 笔记本列表页的路径。以及未指定 base_dir 的笔记本的路径前缀。 menu_id: notebooks # 笔记本列表页高亮的主导航栏菜单按钮。 # 笔记本列表页的左侧栏和右侧栏。 leftbar: recent # recent within all notebooks rightbar: null # 笔记列表页配置 notes: # 笔记列表页和笔记页高亮的主导航栏菜单按钮。 # 可以在笔记本 yaml 的 menu_id 字段中覆盖此参数。 # 可以在笔记的 front-matter/menu_id 中覆盖此参数。 menu_id: notebooks # 笔记列表页的左侧栏和右侧栏。可以在笔记本 yaml 的 leftbar 和 rightbar 字段中覆盖此参数。 leftbar: tagtree, recent # recent of current notebook rightbar: null # 笔记页配置 note: # 笔记页的左侧栏和右侧栏 # 可以在笔记本 yaml 的 note_leftbar 和 note_rightbar 字段中覆盖此参数。 # 可以在笔记的 front-matter/leftbar 和 rightbar 字段中覆盖此参数。 leftbar: tagtree, recent # recent of current notebook rightbar: toc # 作者信息配置 author: base_dir: author # 只影响自动生成的页面路径 menu_id: post leftbar: recent, timeline rightbar: timeline # 错误页配置 error_page: menu_id: post &#x27;404&#x27;: &#x27;/404.html&#x27; leftbar: recent, timeline rightbar: timeline # 其它自定义页面配置 layout: page page: leftbar: recent rightbar: toc ######## Notebook ######## notebook: # 如果没有指定 excerpt 和 description，将自动取多长的内容作为文章摘要。 auto_excerpt: 128 # 可以为某个 tag 设定图标（显示在标签树中）。 tagcons: &#x27;&#x27;: solar:hashtag-linear # 每页显示多少篇笔记。0 表示不分页，null 则 fallback 到 hexo 的配置。 # 可以在笔记本 yaml 的 per_page 字段中覆盖此参数。 per_page: null # 笔记的排序方式。默认按照 updated 降序排序。 # 可以在笔记本 yaml 的 order_by 字段中覆盖此参数。 # 注意：置顶的笔记会始终排在最前面。 # 在 front-matter 中设置 pin:true|number 或 sticky:true|number 来置顶。 order_by: -updated # 是否在笔记页面显示许可协议。false 表示不显示。true 表示沿用主题许可协议内容。也可以给定具体的文本指定协议内容。 # 可以在笔记本 yaml 的 license 字段中覆盖此参数。 # 可以在笔记的 front-matter/license 中覆盖此参数。 license: false # 是否在笔记页面显示分享按钮。 # 可以在笔记本 yaml 的 share 字段中覆盖此参数。 # 可以在笔记的 front-matter/share 中覆盖此参数。 share: false ######## Article ######## article: # 文章类型，决定布局风格，可以在 front-matter/topic/wiki 中覆盖此参数 type: tech # tech: 默认技术类文章, story: 图文类文章，文字和段落间增距大 # 缩进两个文字宽度，适合文字类博客，可以在 front-matter/topic/wiki 中覆盖此参数 indent: # true / false # 如果没有指定封面，是否根据 tags 作为关键词搜索封面图片？ auto_cover: false # search from https://source.unsplash.com/ # 封面图宽高比 cover_ratio: 2.4 # 如果没有指定横幅，是否根据 tags 作为关键词搜索横幅图片？ auto_banner: false # search from https://source.unsplash.com/ # 如果没有指定 excerpt 和 description，将自动取多长的内容作为文章摘要？ auto_excerpt: 128 # 分类颜色 category_color: &#x27;探索号&#x27;: &#x27;#f44336&#x27; # 文章许可协议 license: &#x27;本文由 [Mr. Hu](/about/) 原创, 采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。&#x27; # 分享 share: [ wechat, weibo, link ] # [wechat, weibo, email, link] # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: true title: 您可能感兴趣的文章 max_count: 5 search: service: local_search # local_search, algolia_search, todo... local_search: # 在 front-matter 中设置 indexing:false 来避免被搜索索引 field: all # post, page, all path: /search.json # 搜索文件存放位置 content: true # 是否搜索内容 codeblock: true # 是否搜索代码块（需要content: true) algolia_search: # Docsearch https://docsearch.algolia.com/apply/ 申请 appId: apiKey: indexName: ######## Comments ######## comments: service: beaudar # beaudar, utterances, giscus, twikoo, waline, artalk comment_title: 快来参与讨论吧~ lazyload: false # true / false # beaudar # https://beaudar.lipk.org/ beaudar: repo: Missiu/Beaudar-Comments issue-term: pathname issue-number: theme: preferred-color-scheme label: input-position: top # top/bottom 评论框位置 comment-order: desc # desc 排序 keep-theme: # true/false loading: false branch: main # utterances # https://utteranc.es/ utterances: repo: xxx/xxx issue-term: pathname issue-number: theme: preferred-color-scheme label: # giscus # https://giscus.app/zh-CN giscus: src: https://giscus.app/client.js data-repo: xxx/xxx # [在此输入仓库] data-repo-id: # [在此输入仓库 ID] data-category: # [在此输入分类名] data-category-id: data-mapping: pathname data-strict: 0 data-reactions-enabled: 1 data-emit-metadata: 0 data-input-position: top # top, bottom data-theme: preferred_color_scheme data-lang: zh-CN data-loading: # lazy crossorigin: anonymous # Twikoo # https://twikoo.js.org/ twikoo: js: https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js # 建议锁定版本 envId: https://xxx # vercel函数 # Waline # https://waline.js.org/ waline: js: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline.js css: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline.css meta_css: https://gcore.jsdelivr.net/npm/@waline/client@3.1.3/dist/waline-meta.css # Waline server address url, you should set this to your own link serverURL: https://waline.vercel.app # If false, comment count will only be displayed in post page, not in home page commentCount: true # Pageviews count, Note: You should not enable both `waline.pageview` and `leancloud_visitors`. pageview: false # Custom emoji # emoji: # - https://unpkg.com/@waline/emojis@1.1.0/weibo # - https://unpkg.com/@waline/emojis@1.1.0/alus # - https://unpkg.com/@waline/emojis@1.1.0/bilibili # - https://unpkg.com/@waline/emojis@1.1.0/qq # - https://unpkg.com/@waline/emojis@1.1.0/tieba # - https://unpkg.com/@waline/emojis@1.1.0/tw-emoji # - https://unpkg.com/@waline/emojis@1.1.0/bmoji # 设置自己的图床服务，替换默认的 Base 64 编码嵌入（有体积大小限制），在评论中上传图片更加方便 # imageUploader: # 适配了兰空图床V1、V2版本 # 以兰空图床V1为例，下列填写内容为： # fileName: file # tokenName: Authorization # api: https://xxxxxx/api/v1/upload # token: Bearer xxxxxxxxxxxxxx # resp: data.links.url # 以兰空图床V2为例，下列填写内容为： # fileName: image # tokenName: token # api: https://xxxxxx/api/upload # token: xxxxxxxxxxxxxx # resp: data.url # fileName: # 根据版本二选一 # tokenName: # 根据版本二选一 # api: # 图床 api 地址 # token: # 图床验证 # resp: # 图片地址返回值的字段 # Artalk # https://artalk.js.org/ artalk: css: https://unpkg.com/artalk@2.8.5/dist/Artalk.css js: https://unpkg.com/artalk@2.8.5/dist/Artalk.js server: # 后端服务地址 placeholder: &#x27;&#x27; darkMode: auto ######## Footer ######## footer: social: # github: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg&quot;/&gt;&#x27; # url: / # music: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3845874.svg&quot;/&gt;&#x27; # url: / # unsplash: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3616429.svg&quot;/&gt;&#x27; # url: / # comments: # icon: &#x27;&lt;img src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/942ebbf1a4b91.svg&quot;/&gt;&#x27; # url: /about/#comments # theme: # icon: default:theme # onclick: &#x27;switchTheme()&#x27; sitemap: # &#x27;博客&#x27;: # - &#x27;[近期](/)&#x27; # - &#x27;[分类](/)&#x27; # - &#x27;[标签](/)&#x27; # - &#x27;[归档](/)&#x27; # &#x27;项目&#x27;: # - &#x27;[开源库](/)&#x27; # &#x27;社交&#x27;: # - &#x27;[友链](/)&#x27; # - &#x27;[留言板](/)&#x27; # &#x27;更多&#x27;: # - &#x27;[关于本站](/)&#x27; # - &#x27;[GitHub](/)&#x27; content: | # 支持 Markdown 格式 本站由 [&#123;author.name&#125;](/) 使用 [&#123;theme.name&#125; &#123;theme.version&#125;](&#123;theme.tree&#125;) 主题创建。 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。 # 主题用户越多，开发者维护和更新的积极性就越高，如果您喜欢本主题，请在适当的位置显示主题信息和仓库链接以表支持。 ######## Tag Plugins ######## tag_plugins: # &#123;% box %&#125; / &#123;% note %&#125; note: default_color: &#x27;&#x27; # light, dark, red, orange, yellow, green, cyan, blue, purple, warning, error border: true # true / false # &#123;% checkbox %&#125; checkbox: interactive: false # enable interactive for user # &#123;% quot %&#125; quot: default: # 可以自行配置多种图标方案 prefix: https://bu.dusays.com/2022/10/24/63567d3e092ff.png suffix: https://bu.dusays.com/2022/10/24/63567d3e0ab55.png hashtag: prefix: https://bu.dusays.com/2022/10/24/63567d3e07da3.png question: prefix: ph:seal-question-fill # &#123;% emoji %&#125; emoji: default: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/&#123;name&#125;.gif twemoji: https://gcore.jsdelivr.net/gh/twitter/twemoji/assets/svg/&#123;name&#125;.svg qq: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/&#123;name&#125;.gif aru: https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/&#123;name&#125;.gif tieba: https://gcore.jsdelivr.net/gh/cdn-x/emoji/tieba/&#123;name&#125;.png blobcat: https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/&#123;name&#125;.png icon: # 留空时，图标和文字颜色相同 default_color: accent # theme, accent, red, orange, yellow, green, cyan, blue, purple # &#123;% button 标题 链接 %&#125; button: default_color: theme # theme, accent, red, orange, yellow, green, cyan, blue, purple # &#123;% image %&#125; image: fancybox: false # true, false # &#123;% copy xxx %&#125; copy: toast: 复制成功 # &#123;% timeline %&#125; timeline: max-height: 80vh # &#123;% mark %&#125; mark: default_color: yellow # light, dark, red, orange, yellow, green, cyan, blue, purple, warning, error # &#123;% hashtag %&#125; hashtag: default_color: # red, orange, yellow, green, cyan, blue, purple # &#123;% okr o1 percent:0.5 status:normal %&#125; okr: border: true # 是否显示边框 status: # 可以自行增加 # 进行中状态 in_track: color: blue # red, orange, yellow, green, cyan, blue, purple label: 正常 at_risk: color: yellow label: 风险 off_track: color: orange label: 延期 # 结果状态 finished: color: green label: 已完成 unfinished: color: red label: 未完成 # &#123;% gallery %&#125; gallery: layout: grid # grid / flow size: mix # s / m / l / xl / mix ratio: square # origin / square # 基础依赖 dependencies: jquery: https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js marked: https://cdn.jsdelivr.net/npm/marked@13.0.1/lib/marked.umd.min.js # 内置服务，按需加载（页面内用到了就会加载，没有用到就不会加载） data_services: # 外部 md 渲染 mdrender: js: /js/services/mdrender.js # 数据填充类 siteinfo: js: /js/services/siteinfo.js # 设置 api 可以自动提取网页标题、图标，服务部署方法：https://github.com/xaoxuu/site-info-api/ # 接口测试通过后，把按钮的 href 部分替换成 &#123;href&#125; 之后填写到下方，例如：https://api.vlts.cc/site_info/v1?url=&#123;href&#125; api: ghinfo: js: /js/services/ghinfo.js # 网格布局类 sites: js: /js/services/sites.js friends: js: /js/services/friends.js # 列表布局类 timeline: js: /js/services/timeline.js fcircle: js: /js/services/fcircle.js weibo: js: /js/services/weibo.js memos: js: /js/services/memos.js # 扩展插件接入方法：(插件名下面用 #plugin# 代替) # 1. 在这里增加 #plugin# 配置，至少赢含有 enable 字段，默认为空（不启用） # 2. 新建文件 layout/_plugins/#plugin#.ejs 文件中设置编写加载代码。 # 2.1. 在该文件中可以直接使用 conf 来读取用户在【步骤 1】填写的配置字段内容 # 2.2. 如果需要引入 css 或 js，可以使用 utils.css(xxx)、utils.js(xxx)，具体可参考 layout/_plugins/fancybox.ejs# 2.3. 如果需要本地 js 文件，请放入 /source/js/plugins 文件夹中，引入方式为：utils.js(&#x27;/js/plugins/xxx.js&#x27;); # 3. 如果这个插件只需要引入外部文件，可以在【步骤 1】处增加 inject 字段，而无需进入【步骤 2】创建 ejs，参考 katexplugins: # preload preload: enable: true service: flying_pages # flying_pages flying_pages: https://cdn.jsdelivr.net/npm/flying-pages@2/flying-pages.min.js # lazyload # https://www.npmjs.com/package/vanilla-lazyload lazyload: enable: true # [hexo clean &amp;&amp; hexo s] is required after changing this value. js: https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.min.js transition: fade # blur, fade # https://fancyapps.com/docs/ui/fancybox/ # available for &#123;% image xxx %&#125; fancybox: enable: true loader: /js/plugins/fancybox-loader.js js: https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.umd.js css: https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0/dist/fancybox/fancybox.css # 让 md 语法图片支持放大可以这样写: .md-text img:not([class]), .md-text .image img # 可以处理评论区的图片（不支持 iframe 类评论系统）例如： # 使用 twikoo 评论可以写: .tk-content img:not([class*=&quot;emo&quot;]) # 使用 waline 评论可以写: #waline_container .vcontent img selector: .timenode p&gt;img # 多个选择器用英文逗号隔开 # swiper swiper: enable: true css: https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css js: https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js # https://scrollrevealjs.org/api/reveal.html scrollreveal: enable: #true js: https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js distance: 16px duration: 800 # ms interval: 100 # ms scale: 1 # 0.1~1 # AI 摘要 # https://github.com/qxchuckle/Post-Summary-AI tianli_gpt: enable: #true js: https://jsd.onmicrosoft.cn/gh/qxchuckle/Post-Summary-AI@6.0/chuckle-post-ai.min.js field: post # all, post, wiki key: 5Q5mpqRK5DkwT1X9Gi5e # tianli_gpt key total_length: 1000 # 设置提交的字数限制，默认为1000字，上限为5000，超过5000字符将被截断 typewriter: true # 打字机动画 summary_directly: true # 是否直接显示摘要，否则显示 AI 简介 rec_method: all # all, web # 文章推荐方式，all：匹配数据库内所有文章进行推荐，web：仅当前站内的文章，默认all hide_shuttle: true # 是否隐藏矩阵穿梭 summary_toggle: false interface: name: AI摘要 introduce: &#x27;我是文章辅助AI: QX-AI，点击下方的按钮，让我生成本文简介、推荐相关文章等。&#x27; version: TianliGPT button: [&quot;介绍自己&quot;, &quot;推荐文章&quot;, &quot;生成摘要&quot;, &quot;矩阵穿梭&quot;] # Katex - The fastest math typesetting library for the web # https://katex.org/docs/autorender.html # https://github.com/KaTeX/KaTeX # 使用 hexo-renderer-markdown-it-plus 作为公式渲染器：npm uninstall hexo-renderer-marked --save npm install hexo-renderer-markdown-it-plus --save katex: enable: #true # hexo-renderer-markdown-it-plus 默认开启 katex，此选项仅用于引入样式 inject: | &lt;link rel=&quot;stylesheet&quot; href=&quot;https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css&quot; integrity=&quot;sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0&quot; crossorigin=&quot;anonymous&quot;&gt; # MathJax # 需在Markdown文件开头加入mathjax: true # 推荐使用Pandoc: npm uninstall hexo-renderer-marked --save &amp; npm install hexo-renderer-pandoc --save mathjax: enable: # true # 可以在特定文章的 front-matter 中设置 mathjax: true 来开启，也可以在这里设置全局开启 js: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML # Mermaid - markdwon to flow chart, seq chart, class chart ... # 需要安装 npm install --save hexo-filter-mermaid-diagrams # 使用时 需要在Markdown文件开头加入 mermaid: true # 使用示例： # ```mermaid # graph LR # A(Section A) --&gt;|option 1| B(Section A) # B --&gt;|option 2| C(Section C) # ``` mermaid: enable: # true # 可以在特定文章的 front-matter 中设置 mermaid: true 来开启，也可以在这里设置全局开启 style_optimization: false # use custom style in stellar # js: https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js js: https://cdn.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js # Available themes: default | dark | forest | neutral theme: neutral # 代码块复制按钮 copycode: enable: true default_text: &#x27;Copy&#x27; success_text: &#x27;Copied&#x27; toast: 复制成功 # 赫蹏 (Heti) - 专为中文网页内容设计的排版样式增强 # https://github.com/sivan/heti heti: enable: false # 此插件会和代码块冲突，仅适用于纯中文博主。 css: https://unpkg.com/heti@0.9.2/umd/heti.min.css js: https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js style: prefers_theme: auto # auto / light / dark smooth_scroll: false # true / false 开启时如果目录过长可能无法准确定位 font-size: root: 16px # 改这个会影响全局所有文字的字号 body: 17px # 影响正文区域的字号，如果改成 px 则不受 root 影响 code: 85% # 相较于其所在行的文本大小，建议用百分比 codeblock: 0.8125rem # 13px font-family: logo: &#x27;system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#x27; body: &#x27;system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#x27; code: &#x27;Menlo, Monaco, Consolas, system-ui, &quot;Courier New&quot;, monospace, sans-serif&#x27; codeblock: &#x27;Menlo, Monaco, Consolas, system-ui, &quot;Courier New&quot;, monospace, sans-serif&#x27; text-align: left prefix: h2: https://api.iconify.design/ci:heading-h2.svg border-radius: card-l: 16px # 侧边栏、文章横幅位置的圆角 card: 12px # 文章内大部分卡片的圆角 bar: 8px # 横条类元素的圆角 image: 12px # 图片圆角 color: # 动态颜色（会根据明暗主题重设明度值，只用关心色相和饱和度即可） background: &#x27;hsl(212 16% 98%)&#x27; # 浅色背景颜色 block: &#x27;hsl(212 8% 95%)&#x27; # 块背景颜色 code: &#x27;hsl(220 20% 10%)&#x27; # &#x27;hsl(14 100% 48%)&#x27; # 行内代码颜色 text: &#x27;hsl(0 0% 20%)&#x27; # 文本颜色 # 主题色配置（不会根据明暗动态调整，请设置为通用的颜色） theme: &#x27;hsl(192 98% 55%)&#x27; # 主题色 accent: &#x27;hsl(14 100% 57%)&#x27; # 强调色 link: &#x27;hsl(207 90% 54%)&#x27; # 超链接颜色 hover: &#x27;hsl(14 100% 57%)&#x27; # 按钮高亮颜色 animated_avatar: animate: auto # auto, always background: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp codeblock: scrollbar: 4px highlightjs_theme: https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css loading: loading: 正在加载 error: 加载失败，请稍后重试。 gradient: # https://webgradients.com/ start: &#x27;linear-gradient(to right, hsl(215, 95%, 64%), hsl(195, 95%, 60%), hsl(165, 95%, 56%), hsl(165, 95%, 56%), hsl(195 95% 60%), hsl(215, 95%, 64%))&#x27; leftbar: # 可以设置：纯色/渐变色/图片作为背景 # background: var(--leftbar-bg) background-image: url(/images/background.png) blur-px: 200px blur-bg: var(--alpha50) paginator: prev: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/arrow/f049bbd4e88ec.svg next: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/arrow/064b95430caf4.svg error_page: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/404/1c830bfcd517d.svg site: background-image: #&#x27;url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.14/image/site-bg1@small.webp)&#x27; # 未完全适配，慎用 blur-px: 100px blur-bg: var(--alpha75) default: avatar: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg link: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/link/8f277b4ee0ecd.svg cover: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg image: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg project: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2779789.png banner: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/banner/books.jpg topic: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/10433048.png api_host: ghapi: https://api.github.com ghraw: https://raw.githubusercontent.com gist: https://gist.github.com 自动化自动同步把博客的source和笔记的进行同步，比如：D:\\My\\Notes\\_source ---- D:\\My\\blog\\source。我这里使用FreeFileSync同步电脑本地目录，下载地址https://freefilesync.org/。 打开绿色的，拖动两个要同步的目录，就双向同步就行，保存下来。然后打开红色的，把保存下来的文件拖进去，点击开始进行自动同步。然后创建快捷方式，打开 win+r 输入 shell:startup ，把快捷方式拖进去。 自动发布编写脚本：注意日志路径，同样创建快捷方式，把它放大笔记的某个地方，点击就可以推送到github和oss 123456789101112131415161718192021222324252627282930#!/bin/bash # 设置日志文件路径（将路径替换为你想保存日志的实际路径） LOGFILE=&quot;D:/My/Notes/_drafts/deploy_log.txt&quot; # 确保日志文件为空并设置为 UTF-8 编码 : &gt; &quot;$LOGFILE&quot; # 清空文件内容 # 清理 Hexo 生成的文件 echo &quot;正在执行 hexo clean...&quot; | tee -a &quot;$LOGFILE&quot; if ! hexo clean 2&gt;&amp;1 | tee -a &quot;$LOGFILE&quot;; then echo &quot;hexo clean 执行失败，脚本终止。&quot; | tee -a &quot;$LOGFILE&quot; exit 1 fi # 生成静态文件 echo &quot;正在执行 hexo generate...&quot; | tee -a &quot;$LOGFILE&quot; if ! hexo generate 2&gt;&amp;1 | tee -a &quot;$LOGFILE&quot;; then echo &quot;hexo generate 执行失败，脚本终止。&quot; | tee -a &quot;$LOGFILE&quot; exit 1 fi # 部署生成的文件到指定的目标位置 echo &quot;正在执行 hexo deploy...&quot; | tee -a &quot;$LOGFILE&quot; if ! hexo deploy 2&gt;&amp;1 | tee -a &quot;$LOGFILE&quot;; then echo &quot;hexo deploy 执行失败，脚本终止。&quot; | tee -a &quot;$LOGFILE&quot; exit 1 fi echo &quot;所有任务完成！&quot; | tee -a &quot;$LOGFILE&quot; nginx代理详细见 nginx 章节。这里注意如果是要访问oss，那么需要在nginx.conf 里设置 user 为root 身份进行运行。 配置文件如下：配置文件在&#x2F;etc&#x2F;nginx&#x2F;conf.d里。而nginx.conf 在其上一级目录 12345678910111213141516# blogserver &#123; listen 443 ssl; server_name www.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; # 我这里是oss目录 root /home/data/blog; index index.html index.htm; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 示例图：ps aux | grep nginx","tags":[null,null,null,null,null],"categories":[null]},{"title":"Nginx 反向代理速成教学与泛域名证书的申请","path":"/workflow/Nginx.html","content":"摘要本指南介绍了三种 Nginx 安装方法：直接安装、从源码编译安装及 Docker 安装。直接安装最为简便，适合大多数情况；从源码编译安装提供更高灵活性；Docker 安装则便于容器化部署。此外，还介绍了如何配置 Nginx 实现反向代理和 HTTPS 加密访问，例如将所有 sync.exp.com 的请求转发到 http://127.0.0.1:8384。 安装直接安装(建议)sudo apt update sudo apt install nginx-full# 目录在/etc/nginxwhereis nginx 编译安装（可能缺失模块）123456789101112131415161718192021222324cd /home# https://github.com/syncthing/syncthing/releaseswget https://nginx.org/download/nginx-1.26.2.tar.gz# 解压tar -xzvf nginx-1.26.2.tar.gz # 删除压缩包rm -f nginx-1.26.2.tar.gz# 重命名(可选)mv nginx-1.26.2 nginx# 创建日志文件sudo touch /home/logs/nginx.log# 编译sudo apt-get install build-essential libpcre3 libpcre3-dev zlib1g-dev openssl libssl-dev# --prefix：Nginx主要安装路径，后续Nginx子目录依照这个变量展开./configure \\--prefix=/home/nginx/nginxmake &amp;&amp; make install# 创建链接可以在任何地方访问nginxsudo ln -s /home/nginx/nginx/sbin/nginx /usr/local/bin/nginxwhich nginx docker安装目录：&#x2F;home&#x2F;docker&#x2F;nginx mkdir /home/docker/nginxcd /home/docker/nginxvi docker-compose.yml 先注释到nginx的挂载目录 运行容器 执行命令复制配置到主机，建议绝对目录 docker cp nginx:&#x2F;etc&#x2F;nginx &#x2F;home&#x2F;docker&#x2F;nginx 取消注释 重启容器 12345678910111213141516171819202122services: nginx: restart: always container_name: nginx image: nginx:latest # 设置内存限制为120MB mem_limit: 120m memswap_limit: -1 # user: root ports: - 80:80 - 443:443 volumes: - ./nginx:/etc/nginx - ./src:/var/www/html:rw,cached - ./certs:/etc/certs - /home/data:/home/data logging: driver: json-file options: max-size: &quot;3m&quot; max-file: &quot;3&quot; docker-compsoe up -d 进行部署 基础知识基础命令1234567891011# 测试配置文件是否有语法错误 nginx -t # 查看状态sudo systemctl status nginx# 启动sudo systemctl start nginx# 停止sudo systemctl stop nginx# 重新加载sudo systemctl reload nginx 反向代理先看如下代码： 123456789server &#123; listen 8000 ; server_name [服务器的ip地址|域名]; location / &#123; proxy_pass http://127.0.0.1:8080; ##需要代理的服务器地址 index index.html; &#125;&#125; 此代码是nginx配置的一部分，他有如下作用： 用户访问你的公网 ip:8000，该请求端口因为被nginx监听，所以会被nginx发送到地址为http://127.0.0.1:8080 ，也就是把8000端口请求转到了内网8080端口，然后返回root 目录下的index.html信息。 操作示例我们之前已经搭建好了syncthing服务器，假如我们购买的域名为 exp.com ，接下来我们将进行泛域名证书申请和反向代理实现https加密访问也就是 ssl&#x2F;tls。 泛域名证书申请SSL（安全套接字层）及其后继者TLS（传输层安全性）是用于在联网计算机之间建立经过身份验证和加密的链接的协议。尽管随着 1999 年 TLS 1.0 的发布，SSL 协议已被弃用，但仍普遍将这些相关技术称为“SSL”或“SSL&#x2F;TLS”。最新版本是TLS 1.3 ，在RFC 8446 （2018 年 8 月）中定义。 12345678910111213141516# 安装acmecurl https://get.acme.sh | shcd /root/.acme.sh# DNS-API验证## 输入阿里云角色的kye和Secret## 注意！记得授权，在授权页搜索DNS，全选授权export Ali_Key=export Ali_Secret=# 注册账号./acme.sh --register-account -m 12341234@163.com# 解析域名 baidu 为例./acme.sh --issue -d exp.com -d *.exp.com --dns dns_ali# 证书目录/root/.acme.sh/exp.com_ecc 通过一键脚本申请证书# 地址## https://github.com/Missiu/debian-script## 详细说明见sudo wget -O /home/acme.py https://raw.githubusercontent.com/Missiu/debian-script/main/py/acme.py &amp;&amp; pip install termcolor &amp;&amp; sudo chmod 700 /home/acme.py &amp;&amp; sudo python3 /home/acme.py 其中证书目录似乎无法设置成功：可以使用如下命令同步到acme sudo mv /root/.acme.sh /home/acme &amp;&amp; sudo ln -s /home/acme /root/.acme.sh 反向代理并部署到nginx上复制证书cd /root/.acme.shmkdir /etc/nginx/cert# _通过该命令可将_ _`~/.acme.sh/exp.top`_ _内的证书copy到指定位置`acme.sh`签发了新证书后就自动完成该拷贝过程./acme.sh --install-cert -d exp.com --key-file /etc/nginx/cert/exp.com.key --fullchain-file /etc/nginx/cert/exp.com.cer --reloadcmd &#x27;service nginx force-reload&#x27; 最简单的配置监听80端口，把所有请求转到 443 端口，并使用证书加密，这样所有该证书的子域名都可以生效 # 我们在conf.d新建 .conf 文件，因为nginx 默认导入了该文件夹下所有 .conf 文件cd /etc/nginx/conf.dvim exp.com.conf 以下代码，会监听80和443端口，所有exp.com的子域名，和exp.com都会被重定向到https，也就是访问443端口，然后443端口开起了ssl，我们访问exp.com的子域名sync.exp.com的所有请求都会被发送到http://127.0.0.1:8384 123456789101112131415161718# http(80) -&gt; https(443/ssl)server &#123; listen 80; server_name *.exp.top exp.top; return 301 https://$host$request_uri;&#125;# syncthingserver &#123; listen 443 ssl; server_name sync.exp.com; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8384/; &#125;&#125; 教程中所有nginx配置一览12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# http(80) -&gt; https(443/ssl)server &#123; listen 80; server_name *.exp.top exp.top; return 301 https://$host$request_uri;&#125;# syncthingserver &#123; listen 443 ssl; server_name sync.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8384/; &#125;&#125;# blogserver &#123; listen 443 ssl; server_name www.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; # 我这里是oss目录 root /home/data/blog; index index.html index.htm; location / &#123; try_files $uri $uri/ =404; &#125;&#125;# alistserver &#123; listen 443 ssl; server_name alist.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:5244/; &#125; # 处理 /d/ 请求，重写路径并代理到 80 端口 location /d/ &#123; rewrite ^/p/(.*)$ /$1 break; proxy_pass http://127.0.0.1:80/; &#125;&#125;server &#123; listen 80; server_name 127.0.0.1; root /home/data; location / &#123; try_files $uri $uri/ =404; &#125;&#125;#bitwortenserver &#123; listen 443 ssl; server_name bitwt.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:8000/; &#125;&#125;#3xuiserver &#123; listen 443 ssl; server_name xui.exp.top; ssl_certificate /etc/nginx/cert/exp.top.cer; ssl_certificate_key /etc/nginx/cert/exp.top.key; location / &#123; proxy_pass http://127.0.0.1:2053/; &#125;&#125;","tags":[null,null,null,null],"categories":[null]},{"title":"充分利用云服务器！如何围绕云服务器搭建自己的工作流","path":"/workflow/Workflow.html","content":"需求 实现笔记和其他文件的同步与备份 实现笔记和博客的融合，可以很方便的进行编辑、修改、发布 实现博客和个人简历的融合 科学上网 密码管理 思路围绕云服务器进行多端同步的思路展开与工作流构建。包含大致功能如下： 同步与备份：通过搭建Syncthing的中继服务器和发现服务器，把手机、电脑、pad、服务器联系起来，其中云服务器不但可以中转、存储还能通过内网访问挂载到服务器的oss，以增加存储空间实现备份效果 预览与下载：通过Alist挂载服务器目录，配合重定向实现在浏览器上预览的图床功能，当然下载功能也不在话下。 笔记：通过Obsidian写笔记，因为笔记数据按照文件夹的形式进行本地存储，所以可以通过相对链接渲染图片、视频等，如果要放其他格式文档，比如pdf、xmind文档等，则可以从alist上获取下载链接。 博客：使用hexo静态博客，主题为Stellar。本地编译，通过同步可以把实现在Obsidian的笔记目录下写完文章自动同步到博客的目录下，再配合脚本与插件实现一件编写、发布、修改、推送一条路服务，真正把博客和笔记相互交融！ 密码管理：使用Bitwardn 自建后台服务，把密码放在自己的服务上。 科学上网：使用3-xui搭建节点，配合v2rayN实现科学上网。其中整理了部分节点种类，实现链式代理。 服务器安全与运维：因为我搭建没有采用docker进行搭建，搭建完些占用也才30%左右，而docker虽然更好管理但是占用更高。其中安全需要尽量被攻击，一般就是ddos攻击，然后对运行的服务进行监控、日志的处理、数据的备份、服务器碎片文件的处理等（待更新） SEO：搜索优化，博客都搭起来了怎么能不让别人看到，除了在csdn、掘金等其他博文聚集地发送博客引流，也需要让搜索引擎收录并放在前面。（待更新） 准备 服务器：我的是阿里云香港轻量服务器2H2G，34&#x2F;月。 oss：阿里云标准存储数据包，9&#x2F;年 知道怎么获得阿里云子用户的ccessKey ID 和 AccessKey Secret，以及对其进行授权 vscode或者webstorm，以及本地node环境，在hexo编译的时候可以用 遇到问题可以在博客评论，也可以直接发邮件问，建议先搜一下 常见问题使用密码无法远程链接登录服务器原因可能是服务器PasswordAuthentication参数为no 解决123456# 查看`/etc/ssh/sshd_config`的参数`PasswordAuthentication`配置是否有误。cat /etc/ssh/sshd_config# 将`PasswordAuthentication no`修改为`PasswordAuthentication yes`。sudo vim /etc/ssh/sshd_config# 重启SSHD服务使配置生效。sudo systemctl restart sshd.service 同步到oss目录失败，无法访问、未找到目录原因可能是用户权限不够，可以看看访问oss的应用，比如nginx，运行时的角色是什么，一般root角色才能访问访问挂载的oss目录 解决123456# 使用root用户启动应用，可以使用下面命令查看# 很详细sudo apt install htop# 看自己无法访问oss的服务是不是root用户htop nginx 出现 502错误一般是服务器网络问题，请求走不通。 先使用：curl http://127.0.0.1:端口查看服务是否运行 在确认自己的服务是docker部署还是直接安装，如果docker部署是需要使用 ip addr 命令查看docker0的ip地址，不能用127.0.0.1","tags":[null,null,null,null,null,null,null,null,null,null],"categories":[null]}]